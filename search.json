[{"title":"js位运算和权限","url":"/posts/8d54c840.html","content":"\n## 位运算\n\n### 与 &\n\n都为1则为1，否则为0\n\nA：0011010\nB：0101100\nC：0001000\n\n### 或\t |\n\n有1即为1，否则为0\n\nA：0011010\nB：0101100\nC：0111110\n\n### 非 ^\n\n不同为1，相同为0\n\nA：0011010\nB：0101100\nC：0110110\n\n## 权限控制\n\n现在有`读`、`写`和`执行`三种权限\n\n```test\n读\t写 执行 十进制 权限\n0\t 0  1     1\t\t只有执行\n0\t 1  0     2\t\t只有写\n1\t 0\t0\t\t\t4\t\t只有读\n```\n\n读写执行对应的值分别是`1`、`2`和`4`\n\n`011`即`3`对应的权限为**写和执行**，其它以此类推。\n\n### 添加权限\n\n使用`|`来添加权限\n\n用户的权限为1(`001`，只有执行)，现在需要加上读(4, `100`)\n\n```text\n1 | 4:\n0 0 1 => 1\n1 0 0 => 4\n1 0 1 => 5\n```\n\n结果为5(`101`)对应执行和读的权限\n\n### 删除权限\n\n使用`^`来删除权限\n\n用户的权限为7(`111`)，需要删除写(2, `010`)的权限\n\n```text\n7 ^ 2:\n1 1 1 => 7\n0 1 0 => 2\n1 0 1\t=> 5\n```\n\n结果为5(`101`)，对应执行和读的权限\n\n### 判断权限\n\n当拿到用户权限时，使用`&`来判断用户的权限\n\n用户的权限是6（`110`，读和写）\n\n`110` & `001` = `000`， 表示**没有**执行权限 \n\n`110` & `010` = `010`， 表示**有**写的权限\n\n`110` & `100` = `100`， 表示**有**读的权限 \n\n只有&后的结果等于所需判断的权限，就表示有该权限\n\n## 权限数的限制\n\n每增加一位权限，就需要多一位二进制位。\n\n`JavaScript`中的位运算只支持`32`位，第32位是符号为，所有js中最多能配置32种权限。\n\n使用`BigInt`能够表示更多的权限。\n\n`1n << 33n => 8589934592n`","tags":["javascript","位运算"],"categories":["JavaScript"]},{"title":"js中的数值类型","url":"/posts/9a6a2aee.html","content":"\n## IEEE 754\n\n`JavaScript`的数值类型遵循`IEEE 754`规范。`JavaScript`中的数字都是以是64-bits的双精度数的形式存储的。所以能表示有2^64种情况。\n\n### 浮点数公式\n\njs中的任何一个二进制浮点数可以由以下公式来表示：\n$$\nV = (-1)^{S} * M * 2^{E}\n$$\n\n- V：表示二进制浮点数\n- S：指数位，1位。为0正数，1为负数\n- M：有效数字，52位。\n- E：指数位，11位\n\n`M`是一个介于1和2之间的数即(`1.xxxxxxxxxxx`, 11个`x`)。第一个`1`是默认填上的所以M有`2^53 - 1`中可能。\n\n`E`的取值有`2^11`中可能，由于`E`需要能够表示负数，所以要减去一个中间数(`1023`)\n\n十进制7，二进制为111：\n$$\n7(111) = (-1)^{0} * 1.11 * 2^{2}\n= 1.11 * 100 = 111\n$$\n注意：这里是2进制的运算`2^2 = 100`\n\n`E`为2（10），这里已经减去1023。`2+1023=1025`，即十一位二进制对应的值为`1025`\n\n### E的几种情况\n\n同时指数E还可以**根据规定分为三种情况讨论**\n\n1. **E不全为0或不全为1** 这个阶段就是正常的浮点数表示，通过计算E然后减去1024即为指数\n2. **E全为0** 浮点数的指数E等于0-1023 = -1023，当指数为-1023时，**有效数字M不再加上第一位的1**，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字\n3. **E全为1** 此时如果有效数字M全为0，那么就表示+∞或者-∞，取决于第一位符号位。**但是如果有效数字M不全为0，则表示这不是一个数(NaN)**\n\n## JavaScript中的IEEE 754\n\n### 最大安全整数\n\n$$\nNumber.MAX\\_SAFE\\_INTEGER = 2^{53} - 1\n$$\n\nS为0，53位(包含首位1)有效数字都为1。减去1是排除首位0的情况。\n\n### 0.1 + 0.2 !== 0.3 ?\n\n计算机进行数值运算是，是将十进制转成二进制补码再进行计算\n\n```text\n0.1D = (-1)^0 * 1.1001..(1001循环13次)1010B * 2^-4\n0.2D = (-1)^0 * 1.1001..(1001循环13次)1010B * 2^-3\n0.3D = (-1)^0 * 1.0011..(0011循环13次)0011B * 2^-2\n```\n\n当0.1，0.2转化为二进制的时候，有效数字都是52位(4 * 12 + 4)，因为在64位精确度中，只能保持52位有效数字，如果没有52位有效数字的约束，其实在第53位中，0.1转二进制本来是1，但是有了52位约束之后，根据二进制的取舍（**0舍1入**） ，最后五位数就从1001 **1(第53位)** 变成了 1010。\n\n我们可以手动计算一下0.1的二进制加上0.2的二进制：\n$$\n0.1 + 0.2 = (-1)^{0} * 1.0011...(0011 循环13次)0011 * 2^{-2}\n$$\n那么相加结果转换为十进制其实等于`0.30000000000000004`，这就是为什么0.1 + 0.2 != 0.3 的原因了。\n\n\n\n","tags":["javascript","Number"],"categories":["JavaScript"]},{"title":"Rust学习笔记-Struct","url":"/posts/a574aaab.html","content":"\n本系列文章是笔者学习`Rust`时所做的笔记，供日后翻阅复习。\n\n## 定义Struct\n\n使用`struct`来定义一个结构体，结构体是`key-value`集合。`key`是字段名, `value`是类型。\n\n```rust\nstruct User {\n  username: String,\n  email: String,\n  sign_in_count: u64,\n  active: bool,\n}\n```\n\n> `Strut`的存在 类似其他语言的`class`\n\n## 实例化Struct\n\n实例化时，需要提供初始参数。\n\n```rust\nlet user = User {\n  email: String::from(\"someone@example.com\"),\n  username: String::from(\"someusername123\"),\n  active: true,\n  sign_in_count: 1,\n};\n```\n\n默认，user是`immutable`，如果需要`mutable`，在定义时加上`mut`\n\n```rust\nlet mut user = User {\n  email: String::from(\"someone@example.com\"),\n  username: String::from(\"someusername123\"),\n  active: true,\n  sign_in_count: 1,\n};\n\nuser.username = String::from(\"zxfan\")\n```\n\n如果加上`mut`那么，整个实例都是可变的。`rust`不允许指定字段是可变的。\n\n### 工厂模式实例化\n\n采用工厂模式来实例化Struct\n\n```rust\nfn build_user(email: String, username: String) -> User {\n  User {\n    email,\n    username,\n    active: true,\n    sign_in_count: 1,\n  }\n}\n```\n\n`email: email`可以省略为`email`。这一特性和`JavaScript`一样。\n\n### 结构体更新语法\n\n[Struct Update Syntax](https://doc.rust-lang.org/book/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax)允许创建使用一个实例来创建另一个实例\n\n```rust\nlet user1 = User {\n  email: String::from(\"someone@example.com\"),\n  username: String::from(\"someusername123\"),\n  active: true,\n  sign_in_count: 1,\n};\n\nlet user2 = User {\n  email: String::from(\"another@example.com\"),\n  username: String::from(\"anotherusername567\"),\n  ..user1\n};\n\n// owner 发生 move\n// user1 无法访问\n```\n\n通过`..`语法指定`user2`的剩余字段取`user1`的值。注意：`..`会发生`owner`的move，user1就无法再访问了\n\n## Tupple Struct\n\n没有字段名，以元组的方式定义struct\n\n```rust\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nlet black = Color(0, 0, 0);\nlet origin = Point(0, 0, 0);\n\nbalck.0 // 访问\n```\n\n通过`.`来访问其元素\n\n> 默认情况下，`struct`字段值不能是引用(`References `)。\n>\n> 在指定有`lifetime`的情况下，可以在结构体中使用引用。生命周期能够确保只有struct有效，那么其strutct内的应用也有效\n\n## 使用派生特性添加使用功能\n\n当使用`println!`直接输出一个结构体，会报错！\n\n```rust\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\"rect1 is {}\", rect1);\n}\n\n/*\n  --> src/main.rs:12:29\n   |\n12 |     println!(\"rect1 is {}\", rect1);\n   |                             ^^^^^ `Rectangle` cannot be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`\n   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: required by `std::fmt::Display::fmt`\n   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n*/\n```\n\n**`Rectangle` cannot be formatted with the default formatter**。利用派生特性可以解决struct输出的问题。\n\n`#[derive(Debug)]`：将`Debug`特性派生到自定义类型（结构体）中\n\n```rust\n// #声明注解\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\t\t\n  \t// 在输出时，加上{:?}\n    println!(\"rect1 is {:?}\", rect1);\n}\n```\n\n两种输出：\n\n- `{:?}`: 输出`rect1 is Rectangle { width: 30, height: 50 }`\n\n- `{:#?}`: 格式化输出\n\n  ```tex\n  rect1 is Rectangle {\n      width: 30,\n      height: 50,\n  }\n  ```\n\n## 结构体方法\n\n`struct`类似其它语言的`class`。类有成员方法。`stuct`也有类型概念。使用`impl`（implement）关键字来给`struct`添加成员方法\n\n```rust\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&self) -> u32 {\n        self.width * self.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        rect1.area()\n    );\n}\n\n```\n\n结构体方法的第一个参数必定为`self`，它是`struct`实例。加上`&`是因为只需要引用。\n\n使用时直接用`.`调用，无需考虑像`C/C++`那样有`.`和`->`两种调用方式。因为`Rust`能够自动引用和解引用。\n\n> 一个impl能够声明多个方法，一个struct也能有多个impl\n\n## 关联函数\n\n`impl`能够声明不以`self`作为参数的函数，被称为`关联函数`。可以理解成其他语言的**静态方法**\n\n```rust\nimpl Rectangle {\n    fn square(size: u32) -> Rectangle {\n        Rectangle { width: size, height: size }\n    }\n}\n\n// 调用\nlet sq = Rectangle::square(3)\n```\n\n使用`::`来调用关联函数。\n\n","tags":["Rust","语言学习"],"categories":["Rust"]},{"title":"web-vitals源码解读","url":"/posts/473044e6.html","content":"\n## web-vitals简介\n\n[web-vitals](https://www.npmjs.com/package/web-vitals#overview)是`google`开源的一个测量web性能指标的工具。体积才**1KB**，它可以用来测量`CLS`、`FID`、`LCP`、`FCP`、`TTFB`。\n\n可通过npm来安装`npm install web-vitals`\n\n使用也十分简单\n\n```typescript\nimport {getLCP, getFID, getCLS} from 'web-vitals';\n\ngetCLS(console.log);\ngetFID(console.log);\ngetLCP(console.log);\n```\n\n## 源码结构\n\n`web-vitals`整个项目不是很复杂，目录结构如下\n\n```text\n├─.git\n├─docs\n├─src # 源码\n├─test # 测试代码\n├─.eslintrc \n├─.gitignore\n├─base.d.ts\n├─base.js\n├─CHANGELOG.md\n├─LICENSE # 开源协议\n├─package-lock.json\n├─package.json\n├─README.md\n├─rollup.config.js # rollup构建配置\n├─tsconfig.json # ts配置\n├─wdio.conf.js # e2e测试配置\n```\n\n## 代码规范\n\n### Eslint\n\n`web-vitals`通过配置eslint来约定代码规范。通常，`eslint`配置文件位于根目录下。这样对于整个项目都通用一套`eslint`配置。这往往是不满足需求的。可能src目录需要一套eslint配置，而test目录有需要另一套eslint配置。`web-vitals`是通过`eslintrc`下的**overrides**字段配置的\n\n```json\n{\n  \"parser\": \"babel-eslint\",\n  \"env\": {\n    \"browser\": true,\n    \"es6\": true,\n    \"node\": true,\n    \"mocha\": true\n  },\n  \"parserOptions\": {\n    \"sourceType\": \"module\"\n  },\n  \"overrides\": [\n    {\n      \"files\": \"wdio.conf.js\",\n      \"extends\": [\n        \"eslint:recommended\", \"google\"\n      ],\n      \"rules\": {\n        \"max-len\": \"off\"\n      }\n    },\n    {\n      \"files\": [\"test/e2e/*.js\"],\n      \"globals\": {\n        \"$\": false,\n        \"browser\": false\n      },\n      \"extends\": [\n        \"eslint:recommended\", \"google\"\n      ],\n      \"rules\": {\n        \"no-invalid-this\": \"off\",\n        \"max-len\": [2, {\n          \"ignorePattern\": \"^\\\\s*import|= require\\\\(|^\\\\s*it\\\\(|^\\\\s*describe\\\\(\",\n          \"ignoreUrls\": true\n        }],\n      }\n    },\n    {\n      \"files\": \"src/**/*.ts\",\n      \"parser\": \"@typescript-eslint/parser\",\n      \"extends\": [\n        \"plugin:@typescript-eslint/recommended\"\n      ],\n      \"rules\": {\n        \"@typescript-eslint/no-non-null-assertion\": \"off\",\n        \"@typescript-eslint/no-use-before-define\": \"off\",\n        \"@typescript-eslint/explicit-function-return-type\": \"off\",\n        \"@typescript-eslint/explicit-module-boundary-types\": \"off\",\n        \"@typescript-eslint/ban-ts-comment\": \"off\",\n        \"@typescript-eslint/camelcase\": \"off\",\n        \"node/no-missing-import\": \"off\",\n        \"node/no-unsupported-features/es-syntax\": \"off\",\n        \"node/no-missing-require\": \"off\",\n        \"node/shebang\": \"off\",\n        \"no-dupe-class-members\": \"off\"\n      },\n      \"parserOptions\": {\n        \"ecmaVersion\": 2018,\n        \"sourceType\": \"module\"\n      }\n    }\n  ]\n}\n```\n\n`overrides`字段对应的值是一个数组，该数组中的每个元素都是一条新的eslint规则，并覆盖全局配置\n\n### husky\n\n[`husky`](https://typicode.github.io/husky/)是一个`git`钩子工具，`package.json`文件下有个`husky`字段\n\n```json\n{\n    \"scripts\": {\n        \"lint\": \"eslint \\\"*.js\\\" \\\"src/**/*.ts\\\" \\\"test/**/*.js\\\"\",\n        \"lint:fix\": \"eslint --fix \\\"*.js\\\" \\\"src/**/*.ts\\\" \\\"test/**/*.js\\\"\",\n    },\n    \"husky\": {\n        \"hooks\": {\n            \"pre-commit\": \"npm run lint\"\n        }\n    },\n}\n```\n\n它的作用是，在每次`git commit`时，触发钩子并执行`npm run lint`，也就是进行Eslint检查。如果没有通过eslint，就会commit失败。\n\n### @rollup/plugin-eslint\n\n`web-vitals`的`rollup`并没有配置[@rollup/plugin-eslint](https://github.com/rollup/plugins/tree/master/packages/eslint)。如果加上这个插件，会在构建时进行eslint检查，如果没有通过eslint，就会构建失败并给出相应的修复提示。\n\n## 构建配置\n\n`web-vitals`是通过`rollup`进行构建打包的。其配置也十分简单\n\n```javascript\n// rollup.config.js\nimport replace from '@rollup/plugin-replace';\nimport {terser} from 'rollup-plugin-terser';\nimport babel from 'rollup-plugin-babel';\n\nconst configurePlugins = ({module, polyfill = false}) => {\n  return [\n    babel({\n      presets: [['@babel/preset-env', {\n        targets: {\n          browsers: ['ie 11'],\n        },\n      }]],\n    }),\n    terser({\n      module,\n      mangle: true,\n      compress: true,\n    }),\n    replace({\n      'self.__WEB_VITALS_POLYFILL__': polyfill,\n    })\n  ]\n}\n\nconst configs = [\n  {\n    input: 'dist/modules/index.js',\n    output: {\n      format: 'esm',\n      file: './dist/web-vitals.js',\n    },\n    plugins: configurePlugins({module: true, polyfill: false}),\n  },\n  {\n    input: 'dist/modules/index.js',\n    output: {\n      format: 'umd',\n      file: `./dist/web-vitals.umd.js`,\n      name: 'webVitals',\n    },\n    plugins: configurePlugins({module: false, polyfill: false}),\n  },\n  {\n    input: 'dist/modules/index.js',\n    output: {\n      format: 'esm',\n      file: './dist/web-vitals.base.js',\n    },\n    plugins: configurePlugins({module: true, polyfill: true}),\n  },\n  {\n    input: 'dist/modules/index.js',\n    output: {\n      format: 'umd',\n      file: `./dist/web-vitals.base.umd.js`,\n      name: 'webVitals',\n      extend: true,\n    },\n    plugins: configurePlugins({module: false, polyfill: true}),\n  },\n  {\n    input: 'dist/modules/polyfill.js',\n    output: {\n      format: 'iife',\n      file: './dist/polyfill.js',\n      name: 'webVitals',\n      strict: false,\n    },\n    plugins: configurePlugins({module: false}),\n  },\n];\n\nexport default configs;\n\n```\n\n### 不同的产出文件\n\n导出的`config`是一个数组。每个数组元素是一份rollup配置\n\n| 产出文件名             | module | polyfill |\n| ---------------------- | ------ | -------- |\n| web-vitals.js          | esm    | 不含     |\n| web-vitals.umd.js      | umd    | 不含     |\n| web-vitals.base.js     | esm    | 含       |\n| web-vitals.base.umd.js | umd    | 含       |\n| polyfill.js            | iife   | -        |\n\n- `esm`：即 ES Module，在代码中直接`import`使用\n\n- `iife`：立即执行函数，就是`(function() {})(window)`这种形式\n\n- `umd`：本质上也是iife，但是它将待执行的函数作为iife的参数传入\n\n  ```javascript\n  var a = 2;\n  (function IIFE( def ) {\n    def( window );\n  })(function def( global ) {\n    var a = 3;\n    console.log( a ); // 3 \n    console.log( global.a ); // 2\n  });\n  ```\n\n`iife`和`umd`都是直接在浏览器中使用了\n\n###  tree-shaking\n\nrolup使用了`@rollup/plugin-replace`，用于替换一些常量\n\n```javascript\nreplace({\n    'self.__WEB_VITALS_POLYFILL__': polyfill,\n})\n```\n\n这会将代码中所有出现的`self.__WEB_VITALS_POLYFILL__`的地方替换成`polyfill`变量的对应的值（`true`或`false`）。在代码中出现大量的`self.__WEB_VITALS_POLYFILL__`\n\n```typescript\n// src/lib/getFirstHidden.ts \n\n// function getFirstHidden\nif (self.__WEB_VITALS_POLYFILL__) {\n    firstHiddenTime = self.webVitals.firstHiddenTime;\n    if (firstHiddenTime === Infinity) {\n        trackChanges();\n    }\n} else {\n    firstHiddenTime = initHiddenTime();\n    trackChanges();\n}\n```\n\n如果`self.__WEB_VITALS_POLYFILL__`是true，rollup在构建时，就会吧else的逻辑删掉。反之，会把if的逻辑给删掉。这样就实现了Tree Shaking——删除多余代码。\n\n### TypeScript\n\n`web-vitals`的源码是使用TS编写的，最终需要生成js文件。\n\n`web-vitals`的构建过程：\n\n- 先通过tsc生成**js文件**和**类型声明文件**。\n- 再通过**rollup**进行对**js文件**打包构建\n\n类型声明需要再`package.json`中`typings`字段指定声明文件的位置\n\n```json\n{\n    \"main\": \"dist/web-vitals.umd.js\",\n    \"module\": \"dist/web-vitals.js\",\n    \"typings\": \"dist/modules/index.d.ts\",\n    \"files\": [\n        \"base.js\",\n        \"base.d.ts\",\n        \"dist\",\n        \"src\"\n    ],\n}\n```\n\n- `main`:  定义了 npm 包的入口文件，browser 环境和 node 环境均可使用\n- `module`:  定义 npm 包的 ESM 规范的入口文件，browser 环境和 node 环境均可使用\n- 好有个`browser` : 定义 npm 包在 browser 环境下的入口文件\n\n- `files`：当`npm publish`是，指定需要上传的文件。\n\n## 开源协议\n\n`web-vitals`采用`Apache-2.0`开源协议。该协议允许开发者修改代码，并且商业发布。但是对于改动部分必须提供一份声明。\n\n## 测试\n\n`web-vitals`的测试需要真实的浏览器环境，即需要**端到端测试（e2e test）**。项目通过[wdio（webDriver.IO）]([Getting Started | WebdriverIO](https://webdriver.io/docs/gettingstarted))来实现的。\n\n```json\n{\n    \"scripts\": {\n        \"test\": \"npm-run-all build -p -r test:*\",\n        \"test:e2e\": \"wdio wdio.conf.js\",\n        \"test:server\": \"node test/server.js\",\n    }\n}\n```\n\n### 测试流程\n\n当执行`npm run test`时\n\n- 先构建打包项目\n- 启动一个HTTP服务，用于处理浏览器的资源请求\n- 启动wdio测试\n\n当执行test/e2e目录下的测试用例时，例如`getLCP-test.js`\n\n```javascript\nit('reports the correct value on hidden (reportAllChanges === false)', async function() {\n    // 浏览器不支持就跳过这条用例\n    if (!browserSupportsLCP) this.skip();\n\t\n    // 打开 /test/lcp这个网页，这是测试网页\n    await browser.url('/test/lcp');\n\n    // 等待所有图片加载完成\n    await imagesPainted();\n\n    // 跳转到空白页，触发上一个页面的 hide状态\n    await browser.url('about:blank');\n\t\n    // 检测是beacon.log中是否有数据，参数为数据条数\n    await beaconCountIs(1);\n    \n    // 对 beacon数据进行断言\n    assertStandardReportsAreCorrect(await getBeacons());\n});\n```\n\n当输入`browser.url('/test/lcp')`其实访问的地址是`http://localhost:9090/test/lcp`(在wdio.config.js中配置的)。这条请求会发送给本地的HTTP服务上。\n\n```javascript\n// src/test/server.js\n\napp.get('/test/:view', function(req, res) {\n  const data = {\n    ...req.query,\n    modulePath: `/dist/web-vitals${\n        req.query.polyfill ? `.base` : ``}.js`,\n    webVitalsPolyfill: fs.readFileSync('./dist/polyfill.js', 'utf-8'),\n  }\n  res.send(nunjucks.render(`${req.params.view}.njk`, data));\n});\n```\n\n`nunjucks`是一个模板引擎。data数据会插入到模板引擎内。当访问`/test/lcp`时，会将解析`lcp.njk`并将html返回给浏览器。\n\n```html\n<!-- src/test/view/lcp.njk -->\n{% extends 'layout.njk' %}\n\n{% block content %}\n  <h1>LCP Test</h1>\n  <p>\n    {% if not imgDelay %}\n      {% set imgDelay = 500 %}\n    {% endif %}\n    <img {% if imgHidden %}hidden{% endif %} src=\"/test/img/square.png?delay={{ imgDelay }}\">\n  </p>\n  <p>Text below the image</p>\n\n  <p><a id=\"navigate-away\" href=\"https://example.com\">Navigate away</a></p>\n\n  <!-- Include a tall element to ensure scrolling is possible. -->\n  <div style=\"height: 100vh\"></div>\n\n  <footer>Text below the full-height element.</footer>\n\n  <script type=\"module\">\n    import {getLCP} from '{{ modulePath }}';\n\n    getLCP((lcp) => {\n      // Log for easier manual testing.\n      console.log(lcp);\n\n      // Elements can't be serialized, so we convert first.\n      lcp = {\n        ...lcp,\n        entries: lcp.entries.map((e) => ({\n          element: e.element.nodeName.toLowerCase(),\n          size: e.size,\n          startTime: e.startTime,\n        })),\n      };\n\n      // 发送统计数据\n      navigator.sendBeacon(`/collect`, JSON.stringify(lcp));\n    }, self.__reportAllChanges);\n  </script>\n{% endblock %}\n```\n\nhtml中的最后一步调用了` navigator.sendBeacon(\"/collect\", JSON.stringify(lcp));`，`/collect`这个请求也是发到本地的HTTP服务。服务端会将数据写入到`src/test/beacons.log`中。\n\n### sendBeacon\n\n`navigator.sendBeacon`是专门用来发送异步统计数据的API。\n\n有一种需求：当页面跳转或关闭时，我们需要将当前页面的一些统计数据发送到服务端。往往这些数据不能提前发送。如果使用异步`XMLHttpRequest`的话，浏览器可能会忽略这个请求。如果使用同步`XMLHttpRequest`的话，会影响下个页面的加载速度。\n\n使用`navigator.sendBeacon`，会发送一个异步请求，并且不会被浏览器忽略。\n\n```javascript\ndocument.addEventListener('visibilitychange', function logData() {\n  if (document.visibilityState === 'hidden') {\n    navigator.sendBeacon('/log', analyticsData);\n  }\n});\n```\n\n> 判断页面关闭与否，建议使用`visibilitychange`事件\n>\n> safari需要使用`pagehide`事件\n\n## 代码实现\n\n### PerformanceObserver\n\n性能观察者(PerformanceObserver)用于获取性能数据。\n\n`new PerformanceObserver(callback);` 接受一个callback作为参数\n\n`observer`方法用于注册性能条目类型，type指所要观测的性能条目类型，取值情况通过`PerformanceObserver.supportedEntryTypes`属性查看。\n\n`[\"element\", \"event\", \"first-input\", \"largest-contentful-paint\", \"layout-shift\", \"longtask\", \"mark\", \"measure\", \"navigation\", \"paint\", \"resource\"]`\n\n其中:\n\n- `largest-contentful-paint`：LCP\n- `layout-shift`：CLS\n- `first-input`：FID\n\n```javascript\n// 获取lcp时间\nconst callback = (entryList) => {\n  for (const entry of entryList.getEntries()) {\n    console.log('LCP candidate:', entry.startTime, entry);\n  }\n}\n\nconst observer = new PerformanceObserver(callback)\n\nobserver.observe({type: 'largest-contentful-paint', buffered: true});\n```\n\n### LCP、FID、CLS\n\n`web-vitals`中的`LCP`、`FID`和`CLS`都是通过`PerformanceObserver`来实现的。\n\n以LCP为例：\n\n`getLCP`函数位于`src/getLCP.ts`文件中。\n\n```typescript\nexport const getLCP = (onReport: ReportHandler, reportAllChanges?: boolean) => {\n  \n  // 1 获取 第一次页面处于hidden状态的时间\n  const firstHidden = getFirstHidden();\n  let metric = initMetric('LCP');\n  let report: ReturnType<typeof bindReporter>;\n\t\n                         \n  // 2. PerformanceObserver\n  const entryHandler = (entry: PerformanceEntry) => {\n    const value = entry.startTime;\n\n    // 过滤掉切换pagehide后的 性能数据\n    if (value < firstHidden.timeStamp) {\n      metric.value = value;\n      metric.entries.push(entry);\n    }\n\n    report();\n  };\n\n  const po = observe('largest-contentful-paint', entryHandler);\n\n  if (po) {\n    report = bindReporter(onReport, metric, reportAllChanges);\n\n    const stopListening = () => {\n      if (!finalMetrics.has(metric)) {\n        po.takeRecords().map(entryHandler as PerformanceEntryHandler);\n        po.disconnect();\n        finalMetrics.add(metric);\n        report();\n      }\n    }\n\n    // 当用户点击页面时，立即触发 report\n    ['keydown', 'click'].forEach((type) => {\n      addEventListener(type, stopListening, {once: true, capture: true});\n    });\n\n    onHidden(stopListening, true);\n\t\t\n    // 当pageshow时，报告metric\n    onBFCacheRestore((event) => {\n      metric = initMetric('LCP');\n      report = bindReporter(onReport, metric, reportAllChanges);\n      requestAnimationFrame(() => {\n        requestAnimationFrame(() => {\n          metric.value = performance.now() - event.timeStamp;\n          finalMetrics.add(metric);\n          report();\n        });\n      });\n    });\n  }\n};\n```\n\n### TTFB\n\nTTFB时间直接取`performance.responseStart`","tags":["sc-web-vitals"],"categories":["web-vitals"]},{"title":"前端性能指标","url":"/posts/d43bedc2.html","content":"\n## 性能指标\n\n`google`的**Core Web Vitals**主要由三个性能指标组成\n\n- `LCP(Largest Contentful Paint)`：最大内容绘制\n\n- `FID(First Input Delay)`：首次输入延迟\n\n- `CLS(Cumlative Layout Shift)`：累积布局偏移\n\n除此之外，还有一些常见性能指标：\n\n- `FCP(First Contentful Paint)`：首次内容绘制\n\n- `TTFB(Time to First Byte)`：首字节时间\n\n## Web Vitals\n\n`Web Vitals`是`google`发起的倡议，为web性能提供统一的衡量标准。它有三部分组成——`LCP`、`FID`和`CLS`。\n\n![web vitals](../../images/Performance/web-vitals.png)\n\n- **Largest Contentful Paint (LCP)**: 用于衡量加载性能。考虑到用户体验，LCP应该在**2.5s**内\n- **First Input Delay (FID)**: 用来衡量网站的交互性。考虑到用户体验，FID应该小于**100ms**\n- **Cumulative Layout Shift (CLS)**: 用来衡量网站的视觉稳定性。考虑到用户体验，CLS应该小于**0.1**\n\n衡量一个网站的性能：如果一个网站有**75%**的页面能达到`GOOD`标准，那么该网站就满足`GOOD`级别的性能。\n\n这三个性能数据都可以通过\n\n- `Google`开源的[web-vitals](https://www.npmjs.com/package/web-vitals)\n- `lighthouse`\n\n来测量。\n\n## [Largest Contentful Paint(LCP)](https://web.dev/lcp/)\n\n最大内容绘制时间是指网页最大图像/文本块的绘制时间。当一个页面的**最大丰富内容元素**绘制完成了，就几乎可以认为是该页面渲染完成。LCP认为的**最大丰富内容元素**有：\n\n- `img`元素\n- `svg`里的`image`元素\n- `video`元素\n- `css`中`url()`加载的图片\n- 包含文本元素的块级元素\n\n### 分阶段加载\n\n页面的加载是分阶段的，页面上的最大元素可能会发生变化。\n\n当页面首帧绘制完毕后，浏览器会实例一个化[`PerformanceEntry`](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry)对象，并且将其`entryType`属性设置为`largest-contentful-paint`。用于标识首帧元素的绘制\n\n当页面出现新的最大元素时，又会再创建一个`PerformancenEntry`对象。如何有任何元素大于大于上一个最大元素，就会创建一个`PerformanceEntry`对象\n\n![lcp vs fcp](../../images/Performance/lcpvsfcp.png)\n\nFCP是值首次内容绘制时间，指的是页面出现第一个绘制完成元素的时间。所以FCP比LCP要快。\n\n### 影响LCP的因素\n\n- 服务端响应慢\n- css和js阻塞渲染\n- 资源加载时间\n- 客户端渲染\n\n## [First Input Delay](https://web.dev/fid/)\n\n首次输入延迟（FID）度量标准有助于衡量用户对网站的交互性和响应性的第一印象。\n\nFID衡量的是从用户首次与页面进行交互（即当他们单击链接，点击按钮或使用自定义的JavaScript事件）到浏览器实际上能够开始处理事件处理程序的时间\n\n> FID仅在事件处理中测量“延迟”。它不会测量事件处理时间本身。\n\n![fid](../../images/Performance/fid.svg)\n\n当用户**第一次与页面交互**（例如点击页面）。但是这时**JS线程**正在执行，它会阻塞渲染线程的执行，所以此时，页面是没有给用户反馈的。这段时间就是**FID**\n\n要再强调**首次**，FID只衡量第一次的交互。第一个输入延迟将是用户对您网站的响应度的第一印象，而第一印象对于塑造我们对网站质量和可靠性的整体印象至关重要。\n\n再次强调FID只测量**输入延迟**，记录首次交互到事件开始的事件，并不记录事件执行的事件。\n\n## [Cumlative Layout Shift](https://web.dev/cls/)\n\n累积布局偏移会测量在页面整个生命周期中发生的每个*意外的布局移位*的所有个别*布偏移分数*的总和\n\n**布局偏移**是指页面上的课件元素下一阵偏移到其它位置。\n\n### 布局偏移分数\n\n`Layout Shift Score`计算，是通过视窗口中两个渲染帧之间元素的运动，取该运动中两个度量的乘积：**冲击分数（Impact Fraction）**和**距离分数（Distance Fraction）**\n\n$layout shift score = impact fraction * distance fraction$\n\n### Impact Fraction\n\n![impact fraction](../../images/Performance/impact_fraction.png)\n\n在上图中，有一个元素在一帧中占据了视口的一半。然后，在下一帧中，元素下移视口高度的25％。红色的虚线矩形表示两个帧中元素的可见区域的并集，在这种情况下，其为总视口的75％，因此其*影响分数*为`0.75`。\n\n### Distance Fraction\n\n![distance_fraction.png](../../images/Performance/distance_fraction.png)\n\n在上面的示例中，最大视口尺寸是高度，不稳定元素已移动了视口高度的25％，这使得*距离分数*为0.25。\n\n因此，在此示例中，*碰撞分数*为`0.75`，*距离分数*为`0.25`，因此*布局偏移分数*为`0.75 * 0.25 = 0.1875`。\n\n### [如何改善CLS ](https://web.dev/cls/#how-to-improve-cls)\n\n对于大多数网站，可以遵循一些指导原则来避免所有意外的布局变化：\n\n- **务必确保图片和视频元素有正确的尺寸**，通过`padding-top`实现**宽高等比例**，容器内容使用**绝对定位**\n- **除非响应用户交互，否则切勿在现有内容上方插入内容。**这样可以确保可以预期发生任何版式移位。\n- **与将动画（animation）触发布局更改的属性动画相比，转换（transform）动画更可取。**对过渡进行动画处理，以提供状态与状态之间的上下文和连续性。\n\n## First Contentful Paint\n\n**首次内容绘制**衡量页面开始加载到页面首个元素渲染完成的事件。通常可以用来代表网页的白屏时间。通常`LCP`时间是大于或等于`FCP`时间\n\n## Time To First Bytes\n\n**首字节时间**是指客户端（浏览器）接收到服务端发来的第一个字节所经历的时间。包括**DNS解析**、**TCP三次握手**、**TLS协商**以及**服务端处理请求**\n\n## 其它性能数据\n\n通过`performance`对象，能获取到详细的网页性能数据\n\n`performance.timing`对象结构：\n\n```typescript\ninterface PerformanceTiming {\n    readonly connectEnd: number;\n    readonly connectStart: number;\n    readonly domComplete: number;\n    readonly domContentLoadedEventEnd: number;\n    readonly domContentLoadedEventStart: number;\n    readonly domInteractive: number;\n    readonly domLoading: number;\n    readonly domainLookupEnd: number;\n    readonly domainLookupStart: number;\n    readonly fetchStart: number;\n    readonly loadEventEnd: number;\n    readonly loadEventStart: number;\n    readonly navigationStart: number;\n    readonly redirectEnd: number;\n    readonly redirectStart: number;\n    readonly requestStart: number;\n    readonly responseEnd: number;\n    readonly responseStart: number;\n    readonly secureConnectionStart: number;\n    readonly unloadEventEnd: number;\n    readonly unloadEventStart: number;\n    toJSON(): any;\n}\n```\n\n\ntiming对象提供了各种与浏览器处理相关的时间数据。具体如下表\n\n| 名称                       | 作用（这里所有时间戳都代表UNIX毫秒时间戳）                   |\n| -------------------------- | ------------------------------------------------------------ |\n| connectEnd                 | 浏览器与服务器之间的连接建立时的时间戳，连接建立指的是所有握手和认证过程全部结束 |\n| connectStart               | HTTP请求开始向服务器发送时的时间戳，如果是持久连接，则等同于fetchStart。 |\n| domComplete                | 当前网页DOM结构生成时，也就是Document.readyState属性变为“complete”,并且相应的readystatechange事件触发时的时间戳。 |\n| domContentLoadedEventEnd   | 当前网页DOMContentLoaded事件发生时，也就是DOM结构解析完毕、所有脚本运行完成时的时间戳。 |\n| domContentLoadedEventStart | 当前网页DOMContentLoaded事件发生时，也就是DOM结构解析完毕、所有脚本开始运行时的时间戳。 |\n| domInteractive             | 当前网页DOM结构结束解析、开始加载内嵌资源时，也就是Document.readyState属性变为“interactive”、并且相应的readystatechange事件触发时的时间戳。 |\n| domLoading                 | 当前网页DOM结构开始解析时,也就是Document.readyState属性变为“loading”、并且相应的readystatechange事件触发时的时间戳。 |\n| domainLookupEnd            | 域名查询结束时的时间戳。如果使用持久连接，或者从本地缓存获取信息的，等同于fetchStart |\n| domainLookupStart          | 域名查询开始时的时间戳。如果使用持久连接，或者从本地缓存获取信息的，等同于fetchStart |\n| fetchStart                 | 浏览器准备通过HTTP请求去获取页面的时间戳。在检查应用缓存之前发生。 |\n| loadEventEnd               | 当前网页load事件的回调函数结束时的时间戳。如果该事件还没有发生，返回0。 |\n| loadEventStart             | 当前网页load事件的回调函数开始时的时间戳。如果该事件还没有发生，返回0。 |\n| navigationStart            | 当前浏览器窗口的前一个网页关闭，发生unload事件时的时间戳。如果没有前一个网页，就等于fetchStart |\n| redirectEnd                | 最后一次重定向完成，也就是Http响应的最后一个字节返回时的时间戳。如果没有重定向，或者上次重定向不是同源的。则为0 |\n| redirectStart              | 第一次重定向开始时的时间戳，如果没有重定向，或者上次重定向不是同源的。则为0 |\n| requestStart               | 浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳。 |\n| responseEnd                | 浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的时间戳 |\n| responseStart              | 浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳。 |\n| secureConnectionStart      | 浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回0。 |\n| unloadEventEnd             | 如果前一个网页与当前网页属于同一个域下，则表示前一个网页的unload回调结束时的时间戳。如果没有前一个网页，或者之前的网页跳转不是属于同一个域内，则返回值为0。 |\n| unloadEventStart           | 如果前一个网页与当前网页属于同一个域下，则表示前一个网页的unload事件发生时的时间戳。如果没有前一个网页，或者之前的网页跳转不是属于同一个域内，则返回值为0。 |\n\n**常用指标计算公式如下**\n\n1. DNS解析耗时: domainLookupEnd - domainLookupStart\n2. TCP连接耗时: connectEnd - connectStart\n3. SSL安全连接耗时: connectEnd - secureConnectionStart\n4. 网络请求耗时(TTFB): responseStart - requestStart\n5. 数据传输耗时: responseEnd - responseStart\n6. DOM解析耗时: domInteractive - responseEnd\n7. 资源加载耗时: loadEventStart - domContentLoadedEventEnd\n8. 首包时间: responseStart - domainLookupStart\n9. 首次渲染时间 / 白屏时间: responseEnd - fetchStart\n10. 首次可交互时间: domInteractive - fetchStart\n11. DOM Ready时间: domContentLoadEventEnd - fetchStart\n12. 页面完全加载时间: loadEventStart - fetchStart\n","tags":["网络","Nodejs"],"categories":["Performance"]},{"title":"依赖注入-vu3源码","url":"/posts/dafb6b4a.html","content":"\n## 如何使用\n\n在`setup`中使用：\n\n```typescript\n// 生产组件\nimport { defineComponent, provide, inject, ref } from \"vue\";\n\ndefineComponent({\n  setup() {\n    const name = ref(\"name\");\n    provide(\"name\", name);\n  },\n});\n\n// 消费组件\ndefineComponent({\n  setup() {\n    const name = inject(\"name\"); // 会保留响应式\n    return { name };\n  },\n});\n\n```\n\n全局`provide`\n\n```typescript\nimport { createApp } from \"vue\";\n\nconst app = createApp()\n\napp.provide(name, 'ZXFAN')\n```\n\n## 处理过程\n\n在**父组件**的`setup`中使用`provide`函数，会在放在组件实例上的`provides`对象上。**注意：每个组件实例上的`provides`对象的原型对象都是其父组件的`provides`对象**，根组件的原型对象为null。这样在查找时，就会自动在原型链上寻找。\n\n在**子组件**的`setup`中使用`inject`函数，会在组件实例上找，实例上没有就去**原型链**（父组件的`provides`对象）去找。\n\n全局`provide`即`app.provide(xx, xx)`的形式，会将注入的内容存放在上下文对象的`providers`上\n\n## `provides`原型链的形成\n\n具有嵌套的组件的provides对象构成了原型链，这是为了方便做查找操作\n\n原型链的最顶是null，这是在创建应用上下文对象时初始化的。\n\n```typescript\n// runtime-core/src/apiCreateApp.ts\n\nexport function createAppContext(): AppContext {\n  return {\n    app: null as any,\n    config: {\n      isNativeTag: NO,\n      performance: false,\n      globalProperties: {},\n      optionMergeStrategies: {},\n      isCustomElement: NO,\n      errorHandler: undefined,\n      warnHandler: undefined\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: Object.create(null)\n  }\n}\n```\n\n`Object.create(null)`会创建并返回一个空对象，并且将这个空对象的原型对象设置为参数`null`。\n\n然后是组件实例创建时，会自动初始化`provides`对象。\n\n```typescript\nexport function createComponentInstance(\n  vnode: VNode,\n  parent: ComponentInternalInstance | null,\n  suspense: SuspenseBoundary | null\n) {\n  // ...\n\n  const instance: ComponentInternalInstance = {\n    // ...\n    provides: parent ? parent.provides : Object.create(appContext.provides),\n    // ...\n  }\n  //...\n\n  return instance\n}\n```\n\n显示判断**是否存在父组件**，若存在直接取父组件的**provides对象**\n若没有父组件，则说明是**根组件**，则取**上下文对象**的**provides对象**\n\n## provide函数\n\n```typescript\n// runtime-core/src/apiInject.ts\n\nexport function provide<T>(key: InjectionKey<T> | string | number, value: T) {\n  if (!currentInstance) {\n    if (__DEV__) {\n      warn(`provide() can only be used inside setup().`)\n    }\n  } else {\n    let provides = currentInstance.provides\n    // 默认，实例会继承其父组件的原型对象\n    // 当组件本身需要provide，它会创建自己的provides对象，并将父组件的provides对象设为其原型对象\n    // 这样在使用inject函数注入时，就能利用原型链自动向父组件查找。\n    const parentProvides =\n      currentInstance.parent && currentInstance.parent.provides\n    if (parentProvides === provides) {\n      provides = currentInstance.provides = Object.create(parentProvides)\n    }\n    // TS doesn't allow symbol as index type\n    provides[key as string] = value\n  }\n}\n```\n\n当`parentProvides === provides`为`true`时，说明这是当前组件第一次调用`provide`函数。因为如果一个组件不需要provide，那么实例的`provides`就指向其父组件的`provides`对象。这样就缩短了原型链的长度。\n\n## inject函数\n\n```typescript\nexport function inject(\n  key: InjectionKey<any> | string,\n  defaultValue?: unknown,\n  treatDefaultAsFactory = false\n) {\n  // fallback to `currentRenderingInstance` so that this can be called in\n  // a functional component\n  const instance = currentInstance || currentRenderingInstance\n  if (instance) {\n    // #2400\n    // to support `app.use` plugins,\n    // fallback to appContext's `provides` if the intance is at root\n    const provides =\n      instance.parent == null\n        ? instance.vnode.appContext && instance.vnode.appContext.provides\n        : instance.parent.provides\n\n    if (provides && (key as string | symbol) in provides) {\n      // TS doesn't allow symbol as index type\n      return provides[key as string]\n    } else if (arguments.length > 1) {\n      return treatDefaultAsFactory && isFunction(defaultValue)\n        ? defaultValue()\n        : defaultValue\n    } else if (__DEV__) {\n      warn(`injection \"${String(key)}\" not found.`)\n    }\n  } else if (__DEV__) {\n    warn(`inject() can only be used inside setup() or functional components.`)\n  }\n}\n```\n\ninject就是去`provides`对象找对应`key`的过程。\n注意：这里判断`instance.parent == null`是来判断当前组件是不是根组件。","tags":["Vue","sc-vue3"],"categories":["Vue"]},{"title":"Vue指令-vue3源码","url":"/posts/c445157e.html","content":"\n## 如何使用\n\n在根实例上**注册全局指令**\n\n```typescript\nimport { createApp } from \"vue\"\nimport App from 'app.vue'\n\nconst app = createApp(App)\n\napp.derectives(\"focus\", {\n  // ...\n})\n```\n\n通过选项来**注册局部指令**\n\n```typescript\nimport { defineComponent } from \"vue\"\n\ndefineComponent({\n  // ...\n  directives: {\n    focus: {\n      // ...\n    }\n  }\n  //...\n})\n```\n\n在template中使用：\n\n```vue\n<template>\n\t<input v-focus />\n</template>\n```\n\n在render函数中使用\n\n```typescript\nimport { defineComponent, h, withDirectives, vShow } from \"vue\"\n\ndefineComponent({\n  // ...\n  data: {\n    value: true\n  },\n  render() {\n   \treturn withDirectives(h(\"input\"), [vShow, this.value])\n  }\n  //...\n})\n```\n\n`withDirectives`的函数签名：\n\n- 第一个参数是VNode\n- 第二个参数是指令（可以是自定义指令）\n\n```typescript\nfunction withDirectives<T extends VNode<RendererNode, RendererElement, {\n    [key: string]: any;\n}>>(vnode: T, directives: DirectiveArguments): T\n```\n\n## 指令生命周期\n\n指令有两种类型——对象和函数\n\n```typescript\nexport type Directive<T = any, V = any> =\n  | ObjectDirective<T, V>\n  | FunctionDirective<T, V>\n\n\nexport interface ObjectDirective<T = any, V = any> {\n  created?: DirectiveHook<T, null, V>\n  beforeMount?: DirectiveHook<T, null, V>\n  mounted?: DirectiveHook<T, null, V>\n  beforeUpdate?: DirectiveHook<T, VNode<any, T>, V>\n  updated?: DirectiveHook<T, VNode<any, T>, V>\n  beforeUnmount?: DirectiveHook<T, null, V>\n  unmounted?: DirectiveHook<T, null, V>\n  getSSRProps?: SSRDirectiveHook\n}\n\nexport type FunctionDirective<T = any, V = any> = DirectiveHook<T, any, V>\n```\n\n对象就是声明指令的每个生命周期\n\n函数，只会生命`mounted`和`update`\n\n> 一个指令定义对象可以提供如下几个钩子函数 (均为可选)：\n>\n> - `created`：在绑定元素的 attribute 或事件监听器被应用之前调用。在指令需要附加须要在普通的 `v-on` 事件监听器前调用的事件监听器时，这很有用。\n> - `beforeMount`：当指令第一次绑定到元素并且在挂载父组件之前调用。\n> - `mounted`：在绑定元素的父组件被挂载后调用。\n> - `beforeUpdate`：在更新包含组件的 VNode 之前调用。\n>\n> - `updated`：在包含组件的 VNode **及其子组件的 VNode** 更新后调用。\n> - `beforeUnmount`：在卸载绑定元素的父组件之前调用\n> - `unmounted`：当指令与元素解除绑定且父组件已卸载时，只调用一次。\n\n## 处理过程\n\n全局注册指令，会在**上下文对象**上的**directives（Array类型）**中添加指令\n\n局部指令注册，会将指令存放在**组件实例**\n\n在`template`中使用指令，构建工具将其转换成`render函数`。\n\n运行时，先去app上下文或者组件实例上寻找指令。然后将指令绑定到`VNode`。每个`VNode`都会有一个`dirs`数组，用来存放绑定到该`VNode`的全部指令。\n\n最后在各个阶段执行指令相应的生命周期函数\n\n## 注册流程\n\n### 全局注册\n\n```typescript\nimport { createApp } from \"vue\"\nimport App from 'app.vue'\n\nconst app = createApp(App)\n\napp.derectives(\"focus\", {\n  // ...\n})\n```\n\n指令全局注册是通过`createApp`函数返回的app对象上的**directives方法**来注册的\n\n观察一下**createApp函数**\n\n```typescript\n// runtime-core/src/apiCreateApp.ts\n\nexport function createAppAPI<HostElement>(\n  render: RootRenderFunction,\n  hydrate?: RootHydrateFunction\n): CreateAppFunction<HostElement> {\n  return function createApp(rootComponent, rootProps = null) {\n\n    const context = createAppContext()\n    const installedPlugins = new Set()\n\n    let isMounted = false\n\n    const app: App = (context.app = {\n      // 省略其它代码...\n      directive(name: string, directive?: Directive) {\n        if (__DEV__) {\n          validateDirectiveName(name)\n        }\n\n        if (!directive) {\n          return context.directives[name] as any\n        }\n        if (__DEV__ && context.directives[name]) {\n          warn(`Directive \"${name}\" has already been registered in target app.`)\n        }\n        context.directives[name] = directive\n        return app\n      }\n      // 省略其它代码...\n    })\n\n    return app\n  }\n}\n```\n\ndirective函数做了三件事\n\n- 通过`validateDirectiveName`函数吗，判断是否是内置指令(`v-if`、`v-show`等)。如果是，在开发环境下会报一个警告\n- 如果只传了`name`，认为是取指令操作并返回对应name的指令。如果传了`directive`则认为是注册指令操作\n- 注册指令：在`context.directives`对象上保存指令\n\n> `context`是一个上下文对象。通过`createAppContext`函数创建的\n\n### 局部注册\n\n选择局部注册的方式，指令写在`directives选项`中。单文件组件会通过构建工具生成**组件实例**，也等价于**defineComponent**。在生成`VNode`时，将组件实例绑定到`VNode`的`type`属性上。\n\n局部注册的指令存放在组件实例上。后续会通过`VNode.type.directives`来访问指令\n\n## 绑定与执行\n\n在template模版上使用指令，如：\n\n```vue\n<template>\n\t<input v-focus />\n</template>\n```\n\n构建工具编译生成**render函数**：\n\n```javascript\nimport { resolveDirective as _resolveDirective, createVNode as _createVNode, withDirectives as _withDirectives, openBlock as _openBlock, createBlock as _createBlock } from \"vue\"\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _directive_focus = _resolveDirective(\"focus\")\n\n  return _withDirectives((_openBlock(), _createBlock(\"input\", null, null, 512 /* NEED_PATCH */)), [\n    [_directive_focus]\n  ])\n}\n\n```\n\n可以看出，render内调用了两个方法：\n\n- `_resolveDirective`：接受指令名称作为参数。该函数的作用是去app上下文或者组件实例上寻找指令\n- `_withDirectives`：将指令绑定到VNode上。\n\n### 解析指令\n\n解析指令找到需要使用的指令，也就是`resolveDirective`的过程。分析源码，发现`resolveDirective`调用`resolveAsset`。\n\n```typescript\n// runtime-core/helpers/resolveAssets.ts\n\nconst COMPONENTS = 'components'\nconst DIRECTIVES = 'directives'\n\nexport function resolveDirective(name: string): Directive | undefined {\n  return resolveAsset(DIRECTIVES, name)\n}\n\nfunction resolveAsset(\n  type: typeof COMPONENTS | typeof DIRECTIVES,\n  name: string,\n  warnMissing = true\n) {\n  const instance = currentRenderingInstance || currentInstance\n  if (instance) {\n    const Component = instance.type\n\n    // 省略 组件处理...\n\n    const res =\n      // 局部注册\n      // check instance[type] first for components with mixin or extends.\n      resolve(instance[type] || (Component as ComponentOptions)[type], name) ||\n      // 全局注册\n      resolve(instance.appContext[type], name)\n    \n    return res\n  }\n}\n\nfunction resolve(registry: Record<string, any> | undefined, name: string) {\n  return (\n    registry &&\n    (registry[name] ||\n      registry[camelize(name)] ||\n      registry[capitalize(camelize(name))])\n  )\n}\n```\n\n`instance`是组件实例，`instance.type`等于`VNode.type`即组件实例（也就是注册局部指令的地方）。`instance.appContext`是全局上下文（也就是注册全局指令的地方）\n\n解析组件的过程：\n\n- 先寻找局部注册的指令，在组件实例`instance`上寻找，找不到去组件实例（`instance.type`）去找。\n- 如果找不到局部注册指令，就寻找全局注册指令。直接在上下文对象`intance.appContext`上找\n\n> 可以发现，局部注册的指令会覆盖全局注册指令。\n\n### 绑定指令\n\n绑定指令到VNode是通过`withDirectives`函数实现的\n\n```typescript\n// runtime-cor/src/directives.ts\n\nexport type DirectiveArguments = Array<\n  | [Directive]\n  | [Directive, any]\n  | [Directive, any, string]\n  | [Directive, any, string, DirectiveModifiers]\n>\n\n/**\n * Adds directives to a VNode.\n */\nexport function withDirectives<T extends VNode>(\n  vnode: T,\n  directives: DirectiveArguments\n): T {\n  const internalInstance = currentRenderingInstance\n  if (internalInstance === null) {\n    __DEV__ && warn(`withDirectives can only be used inside render functions.`)\n    return vnode\n  }\n  const instance = internalInstance.proxy\n  const bindings: DirectiveBinding[] = vnode.dirs || (vnode.dirs = [])\n  for (let i = 0; i < directives.length; i++) {\n    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i]\n    if (isFunction(dir)) {\n      dir = {\n        mounted: dir,\n        updated: dir\n      } as ObjectDirective\n    }\n    bindings.push({\n      dir,\n      instance,\n      value,\n      oldValue: void 0,\n      arg,\n      modifiers\n    })\n  }\n  return vnode\n}\n```\n\n`withDirectives`函数遍历了`directives`数组，并将其元素绑定到`VNode.dirs`上。\n\n**特别注意**：如果指令是一个函数，只会给`mounted`和`updated`赋值，并且执行逻辑是一样的。\n\n指令对象的结构：\n\n- `instance`：使用指令的组件实例。\n- `value`：传递给指令的值。例如，在 `v-my-directive=\"1 + 1\"` 中，该值为 `2`。\n- `oldValue`：先前的值，仅在 `beforeUpdate` 和 `updated` 中可用。值是否已更改都可用。\n- `arg`：参数传递给指令 (如果有)。例如在 `v-my-directive:foo` 中，arg 为 `\"foo\"`。\n- `modifiers`：包含修饰符 (如果有) 的对象。例如在 `v-my-directive.foo.bar` 中，修饰符对象为 `{foo: true，bar: true}`。\n- `dir`：一个对象，在注册指令时作为参数传递。例如，在以下指令中\n\n### 执行指令\n\n指令绑定到`VNode`后，就会在相应的时候调用指令\n\n观察指令的类型签名，有两种——对象指令，和函数指令。其中对象指令声明了很多`hook(钩子函数)`，这些是指令的生命周期。\n\n比如，在`mountElement`函数中就有很多触发指令的代码，例如：\n\n```typescript\n// runtime-core/src/render.ts\n\n// function mountElement\n\nif (dirs) {\n  invokeDirectiveHook(vnode, null, parentComponent, 'created')\n}\n```\n\n`invokeDirectiveHook`是用来触发指令，它和`withDirectives`都位于`runtime-core/src/directives.ts`文件中。\n\n```typescript\nexport function invokeDirectiveHook(\n  vnode: VNode,\n  prevVNode: VNode | null,\n  instance: ComponentInternalInstance | null,\n  name: keyof ObjectDirective\n) {\n  const bindings = vnode.dirs!\n  const oldBindings = prevVNode && prevVNode.dirs!\n  for (let i = 0; i < bindings.length; i++) {\n    const binding = bindings[i]\n    if (oldBindings) {\n      binding.oldValue = oldBindings[i].value\n    }\n    const hook = binding.dir[name] as DirectiveHook | undefined\n    if (hook) {\n      callWithAsyncErrorHandling(hook, instance, ErrorCodes.DIRECTIVE_HOOK, [\n        vnode.el,\n        binding,\n        vnode,\n        prevVNode\n      ])\n    }\n  }\n}\n```\n\n每个生命周期钩子的执行都会传入4个参数\n\n- `el`： vnode对应的element元素\n- `binding`：当前vnode绑定的所有指令对象\n- `vnode`：虚拟节点\n- `prevVNode`：上一个虚拟节点，仅在 `beforeUpdate` 和 `updated` 钩子中可用\n\n## v-model指令\n\nvue内置了众多指令，其中`v-model`用来实现**双向绑定**。\n\n### v-model不是单指一个指令\n\n当在template中使用v-model:\n\n```vue\n<input v-model=\"username\"/>\n<input type=\"radio\" v-model=\"gender\"/>\n<input type=\"checkbox\" v-model=\"gender\"/>\n\n<!-- 自定义组件 -->\n<my-component v-model=\"isShow\"/>\n```\n\n被构建工具编译后的渲染函数\n\n```javascript\nimport { vModelText as _vModelText, createVNode as _createVNode, withDirectives as _withDirectives, vModelRadio as _vModelRadio, vModelCheckbox as _vModelCheckbox, resolveComponent as _resolveComponent, Fragment as _Fragment, openBlock as _openBlock, createBlock as _createBlock } from \"vue\"\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_my_component = _resolveComponent(\"my-component\")\n\n  return (_openBlock(), _createBlock(_Fragment, null, [\n    _withDirectives(_createVNode(\"input\", {\n      \"onUpdate:modelValue\": $event => (_ctx.username = $event)\n    }, null, 8 /* PROPS */, [\"onUpdate:modelValue\"]), [\n      [_vModelText, _ctx.username]\n    ]),\n    _withDirectives(_createVNode(\"input\", {\n      type: \"radio\",\n      \"onUpdate:modelValue\": $event => (_ctx.gender = $event)\n    }, null, 8 /* PROPS */, [\"onUpdate:modelValue\"]), [\n      [_vModelRadio, _ctx.gender]\n    ]),\n    _withDirectives(_createVNode(\"input\", {\n      type: \"checkbox\",\n      \"onUpdate:modelValue\": $event => (_ctx.gender = $event)\n    }, null, 8 /* PROPS */, [\"onUpdate:modelValue\"]), [\n      [_vModelCheckbox, _ctx.gender]\n    ]),\n    _createVNode(_component_my_component, {\n      modelValue: _ctx.isShow,\n      \"onUpdate:modelValue\": $event => (_ctx.isShow = $event)\n    }, null, 8 /* PROPS */, [\"modelValue\", \"onUpdate:modelValue\"])\n  ], 64 /* STABLE_FRAGMENT */))\n}\n\n// Check the console for the AST\n```\n\n可以观察到，渲染函数使用`withDirectives`分别给三个`input`元素绑定了三个指令`vModelText`、`vModelRadio`、`vModelCheckbox`。然而并未给**组件**绑定指令。\n\n### 不同元素的v-model行为不一样\n\n针对不同元素，实现双向绑定的方式不同。默认情况下:\n\n- 针对组件，传递`modelValue`，并监听`update:modelValue`事件\n- 针对文本输入框，`vModelText`会将值绑定到`value`属性，并监听`input`或`chang`(有lazy修饰符)事件\n- 针对单选按钮和复选框，`vModelRadio`和`vModelCheckobx`都会将值绑定到`checked`属性，并监听其`change`事件\n- 针对下拉框，`vModelSelect`会遍历所有`option`并对比option的value属性与v-model的值是否一致，若一致给该`option`添加`selected=true`。并监听`change`事件响应更改。\n\n这些`v-model`指令的源码位于`runtime-dom/src/directives/vModel.ts`，看一下`vModelText`的源码\n\n```typescript\n// v-model和其它指令一样会绑定到VNode上\n// 如果不使用v-model，这部分代码会被tree-shaking\nexport const vModelText: ModelDirective<\n  HTMLInputElement | HTMLTextAreaElement\n> = {\n  created(el, { modifiers: { lazy, trim, number } }, vnode) {\n    el._assign = getModelAssigner(vnode)\n    const castToNumber = number || el.type === 'number'\n    addEventListener(el, lazy ? 'change' : 'input', e => {\n      if ((e.target as any).composing) return\n      let domValue: string | number = el.value\n      if (trim) {\n        domValue = domValue.trim()\n      } else if (castToNumber) {\n        domValue = toNumber(domValue)\n      }\n      el._assign(domValue)\n    })\n    if (trim) {\n      addEventListener(el, 'change', () => {\n        el.value = el.value.trim()\n      })\n    }\n    if (!lazy) {\n      addEventListener(el, 'compositionstart', onCompositionStart)\n      addEventListener(el, 'compositionend', onCompositionEnd)\n      // Safari < 10.2 & UIWebView doesn't fire compositionend when\n      // switching focus before confirming composition choice\n      // this also fixes the issue where some browsers e.g. iOS Chrome\n      // fires \"change\" instead of \"input\" on autocomplete.\n      addEventListener(el, 'change', onCompositionEnd)\n    }\n  },\n  // set value on mounted so it's after min/max for type=\"range\"\n  mounted(el, { value }) {\n    el.value = value == null ? '' : value\n  },\n  beforeUpdate(el, { value, modifiers: { trim, number } }, vnode) {\n    el._assign = getModelAssigner(vnode)\n    // avoid clearing unresolved text. #2302\n    if ((el as any).composing) return\n    if (document.activeElement === el) {\n      if (trim && el.value.trim() === value) {\n        return\n      }\n      if ((number || el.type === 'number') && toNumber(el.value) === value) {\n        return\n      }\n    }\n    const newValue = value == null ? '' : value\n    if (el.value !== newValue) {\n      el.value = newValue\n    }\n  }\n}\n```\n\n`vModelTest`声明了三个生命周期函数——`created`、`mounted`和`beforeUpdate`\n\n- `created`\n  - 根据`lazy`来判断绑定`input`和`change`事件。在该事件下触发`VNode`上的`onUpdate:modelValue`事件来更新数据\n  - 如果绑定`trim`修饰符，每次`input`后修改`value`属性\n  - 如果没有`lazy`修饰符，会做组合键输入优化，这对中文输入很有效。在`compositionend`上触发`input`元素的`input`事件\n- `mounted`：将`v-model`的值绑定到`input`的`value`属性上\n- `beforeUpdate`：主要是对标签的一些属性进行更新\n\n","tags":["Vue","sc-vue3"],"categories":["Vue"]},{"title":"手撕Promise","url":"/posts/d884e9d5.html","content":"\n## Promise快速回顾\n\n`Promise`是一个用来处理异步任务的强大的API。\n\n### 三种状态\n\n`Promise`有**三种状态**:\n\n- `pending`: 等待状态\n- `fulfilled`: 完成状态（终态）\n- `rejected`: 拒绝状态（终态）\n\n> `promise`的状态只会改变一次，从`pending`->`fullfilled`或者从`pending`->`rejected`。状态是不可逆的。\n\n### Promise原型方法\n\n一个`Promise`对象的原型有**三个方法**，它们都接受一个回调函数作为参数\n\n- `Promise.prototype.then(onFulfilled, onRejected)`：当`pending`->`fullfilled`时触发`then`的`onFulfilled`\n- `Promise.prototype.catch(onRejected)`：当`pending`->`rejected`时出发`catch`\n- `Promise.prototype.finally(onFinally)`：当状态为终态时，最后一定会触发`finally`\n\n> `then`和`catch`的回调函数一定会返回一个Promise\n>\n> - 当直接reutrn a; 相当于 return Promise.resolve(a)\n>\n> - 当直接throw err; 相当于 return Promise.reject(err)\n>\n> - 当直接return pormise；那么就返回这个promise对象\n\n### Promise的方法\n\n- [`Promise.all(iterable)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/all)\n\n  - all接受一个可迭代对象（例如数组）。每个迭代元素可以是Promise也可以不是Promise\n  - 如果迭代元素是Promise会被依次执行。\n  - 如果所有Promise成功执行，则状态修改成`fulfilled`，并将可迭代对象的所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致。\n  - 如果这个新的promise对象触发了失败状态（rejected），它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息\n\n  > 无论最终状态是`fulfilled`还是`rejected`，`iterable`中所有Promise都会被执行。因为Promise被定义时就会执行。\n\n- [`Promise.allSettled(iterable)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled)\n\n  与`Promise.all`十分类似，区别在于：\n\n  - 当发生`rejected`时，`promise.all`直接把第一个失败的promise对象的错误信息返回而`promise.allSettled`会等所有promise全部执行后在返回\n  - 结果数组不是promise执行结果的集合，而是状态集合 [fulfilled, rejected, fulfilled]\n\n- [`Promise.any(iterable)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/any)\n\n  接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。\n\n- [`Promise.race(iterable)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/race)\n\n  当iterable参数里的任意一个子promise被成功或失败后，以这个promise返回\n\n- [`Promise.reject(reason)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject)\n\n  返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法\n\n- [`Promise.resolve(value)`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve)\n\n  返回一个状态由给定value决定的Promise对象。\n\n  - 如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；\n  - 否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。\n\n  > 通常而言，如果不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。\n\n## 手写Promise\n\n我们要写一个符合[`Promise/A+`](https://promisesaplus.com/)规范的Promise\n\n### 基础结构\n\n先看一个如何使用的Demo\n\n```typescript\nnew FakePromise<any>((resolve, reject) => {\n  setTimeout(() => {\n    console.log(\"进入setTimeout\")\n    resolve()\n  }, 1000)\n  console.log(\"FakePromise\")\n}).then((res) => {\n  console.log(res)\n  throw \"发生错误了\"\n}).catch(err => {\n  console.log(err)\n})\n```\n\n根据api，先写出基础结构\n\n```typescript\ninterface IPromiseCallback {\n  (resolve: Function, reject: Function): void;\n}\n\n// Promise的三种状态\nconst PENDING = \"pending\";\nconst FULFILLED = \"fulfilled\";\nconst REJECTED = \"rejected\";\n\nclass FakePromise<T> {\n  private state: string; // 保存promise状态\n  private value!: T;\t// resolve的值\n  private reason: any; // reject的值\n\n  constructor(executor: IPromiseCallback) {\n    this.state = PENDING;\n\n    const resolve = (value: T) => {\n      \n    };\n    const reject = (reason?: any) => {\n      \n    };\n\n    try {\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }\n\n  then(onFulfilled: Function, onRejected: Function) {}\n  catch(onRejected: Function) {}\n}\n```\n\n当执行`new FakePromise`时，立即修改状态（Pending）。**然后执行回调**（可以看出Promise一旦被创建就会立即执行），并传入两个参数`resolve`和`reject`\n\n`FakePromise`的回调中会调用`resolve`或者`reject`函数，接下来完善`resolve`和`reject`\n\n```typescript\n// ...\n\nconst resolve = (value: T) => {\n\tsetTimeout(() => {\n    if (this.state !== PENDING) return;\n    this.value = value;\n    this.state = FULFILLED\n  })\n};\nconst reject = (reason?: any) => {\n  setTimeout(() => {\n    if (this.state !== PENDING) return;\n    this.reason = reason;\n    this.state = REJECTED\n  })\n};\n\n// ...\n```\n\n此处目前做了三个工作：\n\n- `resolve`和`reject`应该都是异步的，所以这里用`setTimout`来模拟。\n- 保存value和reason的值\n- 更改promise的状态\n\n### then\n\n由于`resolve`的执行是异步的，此时应该先调用同步的`then`\n\n```typescript\nclass FakePromise<T> {\n  //...\n  \n  private onFulfilledFns: Function[] = [];\n  private onRejectedFns: Function[] = [];\n  \n  // ...\n  \n  then(onFulfilled?: (res: T) => any, onRejected?: Function) {\n    onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : (x) => x;\n    onRejected =\n      typeof onRejected === \"function\"\n        ? onRejected\n        : (x: any) => {\n            throw x;\n          };\n    const promise = new FakePromise((resolve, reject) => {\n      switch (this.state) {\n        case FULFILLED:\n          setTimeout(() => {\n            try {\n              resolve(onFulfilled!(this.value))\n            } catch (err) {\n              reject(err);\n            }\n          });\n          break;\n        case REJECTED:\n          setTimeout(() => {\n            try {\n              resolve(onRejected(this.reason));\n            } catch (err) {\n              reject(err);\n            }\n          });\n          break;\n        case PENDING:\n          // store and wait\n          this.onFulfilledFns.push(() => {\n            try {\n              resolve(onFulfilled(this.value));\n            } catch (err) {\n              reject(err);\n            }\n          });\n          this.onRejectedFns.push(() => {\n            try {\n              resolve(onRejected(this.reason));\n            } catch (err) {\n              reject(err);\n            }\n          });\n          break;\n      }\n    });\n    return promise;\n  }\n  // ...\n}\n```\n\n`then`函数：\n\n- 第一步，对两个参数进行处理，如果不是函数就赋一个默认值（函数）\n- 然后定义了一个`FakePromise`并最终将其返回，因为then就是应该返回一个`Promise`，这样才能挂载多个then从而链式调用\n- 分别对每个状态进行处理，无论什么状态都是异步的\n  - `fulfilled`：直接调用`onFulfilled`，传入value并捕获起异常\n  - `rejected`：直接调用`onRejected`，传入reason并捕获起异常\n  - `pending`：说明当执行`then`时，（异步）promise还在执行。那我们就需要把回调存下来，存到`onFulfilledFns`和`onRejectedFns`中，注意它们必须是数组，因一个为`FakePromise`可以有多个`then`。等到（异步）promise执行完毕（`resolve`或者`rejected`）时再去调用。\n\n`pending`状态的回调已经保存下来了。我们需要再`resolve`和`reject`中去处理\n\n```typescript\n// ...\n\nconst resolve = (value: T) => {\n\tsetTimeout(() => {\n    if (this.state !== PENDING) return;\n    this.value = value;\n    this.state = FULFILLED\n    this.onFulfilledFns.forEach((fn) => fn()); // 添加这一行\n  })\n};\nconst reject = (reason?: any) => {\n  setTimeout(() => {\n    if (this.state !== PENDING) return;\n    this.reason = reason;\n    this.state = REJECTED\n    this.onRejectedFns.forEach((fn) => fn()); // 添加这一行\n  })\n};\n\n// ...\n```\n\n就是遍历数组，执行每一个函数。\n\n`then`的两个回调参数——`onFulfilled`和`onRejected`。的返回值有很多情况。我们目前没有对这些情况判断而是直接`resolve(x)`或者`reject(x)`（见上方代码）\n\n`Promise/A+`规范规定:\n\n- 情况 1： x 等于 promise（当前的promise对象）\n\n  抛出一个 TypeError 错误，拒绝 promise。\n\n- 情况 2：x 为 Promise 的实例\n\n  如果 x 处于等待状态，那么 promise 继续等待至 x 执行或拒绝，否则根据 x 的状态执行/拒绝 promise。\n\n- 情况 3：x 为对象或函数\n\n  该情况的核心是取出 x.then 并调用，在调用的时候将 this 指向 x。将 then 回调函数中得到结果 y 传入新的 Promise 解决过程中，形成一个递归调用。其中，如果执行报错，则以对应的错误为原因拒绝 promise。\n\n  这一步是处理拥有 then() 函数的对象或函数，这类对象或函数我们称之为“**thenable**”。注意，它只是拥有 then() 函数，并不是 Promise 实例。\n\n- 情况 4：如果 x 不为对象或函数\n\n  以 x 作为值，执行 promise。\n\n接下来根据`Promise/A+`规范来实现`resolvePromise`函数\n\n```typescript\nclass FakePromise<T> {\n  // ...\n  \n  private resolvePromise(\n    promise: FakePromise<any>,\n    x: any,\n    resolve: Function,\n    reject: Function\n  ) {\n      // 情况1: x等于当前promise对象，直接抛出TypeError\n      if (promise === x) {\n        return reject(new TypeError(\"x can not be equal to promise\"));\n      } \n      \n      // 情况2：x是 FakePromise的实例\n      // 取决于x的状态\n      else if (x instanceof FakePromise) {\n        if (x.state === FULFILLED) {\n          resolve(x.value);\n        } else if (x.state === REJECTED) {\n          reject(x.reason);\n        } else {\n          // PENDING\n          x.then((y) => {\n            this.resolvePromise(promise, y, resolve, reject);\n          }, reject);\n        }\n      } \n      \n      // 情况3: x是对象或者函数\n      else if (\n        x !== null &&\n        (typeof x === \"object\" || typeof x === \"function\")\n      ) {\n        // excute记录是否执行过，防止重复执行\n        let executed: boolean = false;\n        try {\n          // 取出 对象或函数（也是对象）的then属性\n          const then = x.then;\n          \n          // then是函数，执行\n          if (typeof then === \"function\") {\n            // 然后执行\n            then.call(\n              x,\n              (y: any) => {\n                if (executed) return;\n                executed = true;\n                this.resolvePromise(promise, y, resolve, reject);\n              },\n              (e: any) => {\n                if (executed) return;\n                executed = true;\n                reject(e);\n              }\n            );\n          }\n          \n          // then不是函数，直接resolve\n          else {\n            resolve(x);\n          }\n        } catch (e) {\n          if (executed) return;\n          executed = true;\n          reject(e);\n        }\n      } \n      \n      \n      // 情况4: 其他情况，直接resolve\n      else {\n        resolve(x);\n      }\n  }\n  \n  // ...\n}\n```\n\n然后修改`then`函数\n\n```typescript\nclass FakePromise<T> {\n  //...\n  \n  private onFulfilledFns: Function[] = [];\n  private onRejectedFns: Function[] = [];\n  \n  // ...\n  \n  then(onFulfilled?: (res: T) => any, onRejected?: Function) {\n    onFulfilled = typeof onFulfilled === \"function\" ? onFulfilled : (x) => x;\n    onRejected =\n      typeof onRejected === \"function\"\n        ? onRejected\n        : (x: any) => {\n            throw x;\n          };\n    const promise = new FakePromise((resolve, reject) => {\n      switch (this.state) {\n        case FULFILLED:\n          setTimeout(() => {\n            try {\n              this.resolvePromise(\n                promise,\n                onFulfilled!(this.value),\n                resolve,\n                reject\n              );\n            } catch (err) {\n              reject(err);\n            }\n          });\n          break;\n        case REJECTED:\n          setTimeout(() => {\n            try {\n              this.resolvePromise(\n                promise,\n                onRejected!(this.reason),\n                resolve,\n                reject\n              );\n            } catch (err) {\n              reject(err);\n            }\n          });\n          break;\n        case PENDING:\n          // store and wait\n          this.onFulfilledFns.push(() => {\n            try {\n              this.resolvePromise(\n                promise,\n                onFulfilled!(this.value),\n                resolve,\n                reject\n              );\n            } catch (err) {\n              reject(err);\n            }\n          });\n          this.onRejectedFns.push(() => {\n            try {\n              this.resolvePromise(\n                promise,\n                onRejected!(this.reason),\n                resolve,\n                reject\n              );\n            } catch (err) {\n              reject(err);\n            }\n          });\n          break;\n      }\n    });\n    return promise;\n  }\n}\n```\n\n把之前所有`resolve`和`reject`的地方改成调用`resolvePromise`函数，该函数接受四个参数：当前then返回的promise对象，`onFulfilled`或`onRejected`的执行结果，resolve还有reject函数\n\n### catch\n\n`catch`和`then`的第二个参数一样，用于捕获异常。\n\n当then第二个参数没传，它会被默认赋值一个异常处理函数`(x: any) => { throw x }`，这里直接抛出异常。\n\n```typescript\nnew FakePromise((resolve, reject) => {\n  // p0\n  setTimeout((() => {\n    reject('hi')\n  }, 1000))\n}).then(() => {\n  // p1\n  console.log('p1')\n  return 'p1 done'\n}).then(() => {\n  // p2\n  console.log('p2')\n  return 'p2 done'\n}).catch(err => {\n  console.log(err)\n})\n```\n\n在`p0`中reject。由于`p0`的`then`没有传`onRejected`。所以当执行then函数时，会默认赋一个抛出异常的函数。这个异常被`p1`的`try catch`捕获到了，进而`p1`也`reject`了。进而执行`p1`的**onRejected**，不过也没传，继续抛异常再reject。继续执行p2的**onRejected**。`p2`没有调用then函数了但是调用了**catch**函数。所以此时catch函数只要将其回调绑定到`then`函数的第二个参数（onRejected）上就可以被执行了。\n\n```typescript\nclass FakePromise<T> {\n  // ...\n  \n  catch(onRejected: Function) {\n    return this.then(undefined, onRejected);\n  }\n  \n  // ...\n}\n```\n\n调用`catch`会给当前Promise对象添加一个`then`函数并且传递了`onRejected`。\n\n> 当**promise**链中有一个环节reject了。他就会一直向下寻找**onRejected**，直到找到为止。\n>\n> 如果catch执行之后返回一个**fulfilled**的**promise**，**catch**之后的**then**继续执行\n>\n> 如果**catch**执行之后返回一个**rejected**的**promise**，继续往后寻找**onRejected**\n\n### finally\n\n无论promise最终状态是`fulfilled`还是`rejected`。`finally`都会执行。那我们在`Promise`链的最后去执行finally即可\n\n```typescript\nclass FakePromise<T> {\n  // ...\n  \n  finally(onFinally: Function) {\n    this.then(\n      (value: T) => {\n        onFinally();\n        return value;\n      },\n      (reason: any) => {\n        onFinally();\n        throw reason;\n      }\n    );\n  }\n  \n  // ...\n}\n```\n\n### Promise.resolve\n\n`resolve`用来讲一个普通的变量包装成`fulfilled`的`promise`对象，处理过程需要符合`Promise/A+`规范，也就是那四种情况。\n\n```typescript\nclass FakePromise<T> {\n  // ...\n  \n  static resolve(value: any) {\n    const promise = new FakePromise((resolve, reject) => {\n      setTimeout(() => {\n        this.prototype.resolvePromise(promise, value, resolve, reject);\n      });\n    });\n    return promise;\n  }\n  \n  // ...\n}\n```\n\n### Promise.reject\n\n`reject`用来将一个普通的变量包装成`rejected`的`promise`对象，处理过程需要符合`Promise/A+`规范，也就是那四种情况。\n\n```typescript\nclass FakePromise<T> {\n  // ...\n  \n  static reject(value: any) {\n    const promise = new FakePromise((resolve, reject) => {\n      reject(value);\n    });\n    return promise;\n  }\n  \n  // ...\n}\n```\n\n### Promise.all\n\n直接上代码\n\n```typescript\nclass FakePromise<T> {\n  // ...\n  \n  static all(it: Array<any>) {\n    const result: Array<any> = [];\n    let count = 0;\n    return new FakePromise<Array<any>>((resolve, reject) => {\n      it.forEach((cb, index) => {\n        FakePromise.resolve(cb).then((res) => {\n          count++;\n          result[index] = res;\n          if (count === it.length) resolve(result);\n        }, reject);\n      });\n    });\n  }\n  \n  // ...\n}\n```\n\n参数`it`应该是一个可迭代对象，为了简化就用数组来模拟。循环中使用`FakePromise.resolve`来将`cb`包装成`Promise`对象。当发生错误直接调用reject，。如果没有错误，当count等于it的长度（即it所有元素处理完毕）时，将结果`result`给`resolve`出去。\n\n### Promise.race\n\n`race`就更简单了，当第一个`promise`执行后就直接`resolve`\n\n```typescript\nclass FakePromise<T> {\n  // ...\n  \n  static race(it: Array<any>) {\n    return new FakePromise<any>((resolve, reject) => {\n      it.forEach((cb) => {\n        FakePromise.resolve(cb).then(res => {\n          resolve(res)\n        }, reject);\n      });\n    });\n  }\n  \n  // ...\n}\n```\n\n> 十分重要：无论`all`还是`race`。传入的所有`promise`都会执行。只是有些`promise`可能不会添加`then`或者`catch`来处理\n\n[源码](https://github.com/zxffan/playground/blob/main/fake_promise/index.ts)\n\n## async和await\n\n### 谁的语法糖？\n\n`async`和`await`是 ES2017 标准推出的用于处理异步操作的关键字。它是`Generator`函数（生成器函数）的语法糖\n\n`Generator`函数是 ES6 提出的除 Promise 之外的另一种异步解决方案。\n\n```typescript\nfunction* gen() {\n  console.log(\"first\");\n  yield 1;\n  console.log(\"second\");\n  yield 2;\n  console.log(\"third\");\n}\n\nconst iterator = gen() // 返回一个迭代器对象\n\niterator.next() // 返回 { value: 1, done: false }\niterator.next() // 返回 { value: 2, done: false }\niterator.next() // 返回 { value: undefined, done: true }\n```\n\n### async和await原理\n\n`async/await` 做的事情就是将` Generator函数`转换成` Promise`\n\n```typescript\nfunction generatorToPromise(generator: GeneratorFunction) {\n  return function () {\n    const iterator = generator.apply(this, Array.of(arguments));\n    return new Promise((resolve, reject) => {\n      function step(action: keyof typeof iterator, arg?: any): any {\n        try {\n          const { value, done } = iterator[action](arg);\n          if (done) {\n            resolve(value);\n          } else {\n            return Promise.resolve(value).then(\n              (val) => step(\"next\", value),\n              (err) => step(\"throw\", err)\n            );\n          }\n        } catch (err) {\n          return reject(err);\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n}\n```\n\n","tags":["JavaScript","Promise"],"categories":["JavaScript"]},{"title":"Emit分析-vue3源码","url":"/posts/9c1e6144.html","content":"\n## 如何使用\n\n`template`中绑定自定义事件\n\n```vue\n<template>\n\t<child-component @show-info=\"showInfo\" @delete.once=\"deleteItem\"/>\n</template>\n```\n\n在`child-component`子组件中使用emit\n\n`this.emit(\"show-info\")`\n\n## 处理过程\n\nvue会将所有`v-on`指令绑定的事件全部存放到**组件实例**的**props**中，并对其改名, `show-info`会变成`onShowInfo`。这部分工作由构建工具完成。\n\n如果没有使用`template`，而使用渲染函数，需要手动写成`onShowInfo`的形式\n\n当在子组件中使用emit时，也是会先修改名称再去props中寻找相应事件并执行。\n\n## Emit函数\n\nemit函数用来触发事件，其源码位于`rumtime-core/src/componentEmits.ts`下\n\n```typescript\n// ...\n\nexport function emit(\n  instance: ComponentInternalInstance,\n  event: string,\n  ...rawArgs: any[]\n) {\n  const props = instance.vnode.props || EMPTY_OBJ\n\n  let args = rawArgs\n\n  // ----------------------\n  // 此处是处理 update:xxx 事件的(v-model)\n  const isModelListener = event.startsWith('update:')\n  const modelArg = isModelListener && event.slice(7)\n  if (modelArg && modelArg in props) {\n    const modifiersKey = `${\n      modelArg === 'modelValue' ? 'model' : modelArg\n    }Modifiers`\n    const { number, trim } = props[modifiersKey] || EMPTY_OBJ\n    if (trim) {\n      args = rawArgs.map(a => a.trim())\n    } else if (number) {\n      args = rawArgs.map(toNumber)\n    }\n  }\n  // ----------------------\n\n  // 如果 event是  custom-event\n  let handlerName = toHandlerKey(camelize(event))\n  // handlerName 变成 onCustomEvent\n  let handler = props[handlerName]\n\n  // 如果v-model update:xxx的事件，处理则不同\n  if (!handler && isModelListener) {\n    // 如果 event是 update:modelValue\n    handlerName = toHandlerKey(hyphenate(event))\n    // handlerName 变成 update:model-value\n    handler = props[handlerName]\n  }\n\n  if (handler) {\n    // 执行 函数\n    callWithAsyncErrorHandling(\n      handler,\n      instance,\n      ErrorCodes.COMPONENT_EVENT_HANDLER,\n      args\n    )\n  }\n\t\n  // 寻找有没有 once修饰符的事件，\n  // 如果有判断是否执行过，用emmited记录\n  // 如果有则直接返回，没有记录emited并执行\n  const onceHandler = props[handlerName + `Once`]\n  if (onceHandler) {\n    if (!instance.emitted) {\n      ;(instance.emitted = {} as Record<string, boolean>)[handlerName] = true\n    } else if (instance.emitted[handlerName]) {\n      return\n    }\n    callWithAsyncErrorHandling(\n      onceHandler,\n      instance,\n      ErrorCodes.COMPONENT_EVENT_HANDLER,\n      args\n    )\n  }\n}\n\n//...\n```\n\n源码中有3种处理：v-model的update:xxx、自定义事件、once事件\n\n- v-model的**update:xxx**：\n- 自定义事件：先修改event，再去props里寻找对应事件，调用\n- once：在`instance.emited`中记录调用次数，并在事件名称后加上**Once**\n\n`emit`函数会在组件实例创建是被挂载在组件实例上\n\n```typescript\n// runtime-core/src/components\n\nexport function createComponentInstance(\n  vnode: VNode,\n  parent: ComponentInternalInstance | null,\n  suspense: SuspenseBoundary | null\n) {\n  // ...\n  instance.emit = emit.bind(null, instance)\n  // ...\n}\n```\n\n## v-on事件处理\n\n通过[vue-template-explore](https://vue-next-template-explorer.netlify.app/)来观察一下如何处理自定义事件\n\n`<child-component @show-info=\"showInfo\" @delete.once=\"deleteItem\">Hello</child-component>`\n\n```javascript\nimport { createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock } from \"vue\"\n\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_child_component = _resolveComponent(\"child-component\")\n\n  return (_openBlock(), _createBlock(_component_child_component, {\n    onShowInfo: _ctx.showInfo,\n    onDeleteOnce: _ctx.deleteItem\n  }, {\n    default: _withCtx(() => [\n      _createTextVNode(\"Hello\")\n    ]),\n    _: 1 /* STABLE */\n  }, 8 /* PROPS */, [\"onShowInfo\", \"onDeleteOnce\"]))\n}\n\n// Check the console for the AST\n```\n\n`createBlock`函数位于`runtime-core/src/vnode.ts`中。用来创建区块根节点。它的第二个参数就是props。可以观察到`show-info`变成了`onShowInfo`，`delete`变成了`onDeleteOnce`。\n\n下面是`createBlock`的函数签名。\n\n```typescript\nfunction createBlock(\n\ttype: VNodeTypes | ClassComponent, \n  props?: Record<string, any> | null | undefined,\n  children?: any,\n  patchFlag?: number | undefined, \n  dynamicProps?: string[] | undefined\n): VNode\n```\n\n## 与vue2的区别\n\nvue2的emit是挂载在`vue.prototype`上的方法\n\nvue3的emit是挂载在实例上的方法","tags":["Vue","sc-vue3"],"categories":["Vue"]},{"title":"Nodejs搭建vue服务端渲染","url":"/posts/af3ae610.html","content":"\n## 何为服务端渲染\n\n与**服务端渲染**相对应的是**客户端渲染**。区别他们的方法就是判断网页（具有完整HTML结构）是由服务端生成的还是由客户端生成。以vue为例：\n\n- 客户端渲染：用户输入网址，服务端返回一个html文件（没有完整的HTML结构，通常只有`<div id=\"app\"></div>`）。浏览器解析HTML，遇到许多script外链，进而请求这些脚本。然后再执行这些脚本，最终在生成相应dom节点。\n- 服务端渲染：用户输入网址，服务端收到请求后。在服务端执行相关脚本，生成相应的dom节点。最后将渲染后的具有完整HTML结构的html文件直接发送给客户端浏览器。这时，浏览器就可以展示页面了，之后再解析HTML文件，请求外链脚本。比较重要的是客户端需要激活服务端生成的那些节点。\n\n由此，服务端渲染相对于客户端有以下好处：\n\n1. 比客户端更快的首屏速度，快了请求下载脚本和执行脚本的时间\n2. 更好的SEO，服务器返回的是一个完整的HTML页面。\n\n## 技术选型\n\n**服务端渲染**必须有一个服务端来担任渲染网页的职责。nodejs是最好的选择。\n\n- 中间件系统：Koa\n- Vue相关：vue、vuex、vue-router、vue-server-renderer\n- 构建：webpak相关\n- 开发语言：TypeScript\n\n## 实现蓝图\n\n![ssr蓝图](../../images/nodejs/vue_ssr_blueprint.jpg)\n\n首先项目是由webpack打包构建的，项目有两个入口文件`server entry`和`client entry`。一个用于服务端一个用于客户端。把服务端和客户端的公共逻辑（例如创建vue、vuex、vue-router实例）抽离出来放入`app.js`。\n\nwebpack构建后会生成两份`bundle`——`server bundle`和`client bundle(manifest)`。这两个文件会传递给`vue-server-renderer`用来创建`render`（渲染器），从而在服务端渲染出html。\n\n[源码地址](https://github.com/zxffan/vue2-ssr)\n\n## vue-server-renderer\n\n这是vue官方提供的一个服务端渲染工具。vue的ssr实现是基于它的。\n\n配置webpack生成所需要的bundle和manifest\n\n```typescript\nimport VueSSRServerPlugin from \"vue-server-renderer/server-plugin\";\nimport VueSSRClientPlugin from \"vue-server-renderer/client-plugin\";\n// client\nexport default {\n  // ...省略\n  plugins: [new VueSSRClientPlugin()],\n  // ...省略\n}\n\n// server\nexport default {\n  // ...省略\n  plugins: [new VueSSRServerPlugin()],\n  // ...省略\n}\n```\n\n`vue-server-renderer`提供两个**plugin**——`server plugin`和`client plugin`。前者会在打包过程中生成**bundle**文件，后者会生成**manifest**文件\n\n使用例子：\n\n```typescript\nimport { createBundleRenderer } from \"vue-server-renderer\";\n// 这两个文件是webpack打包后自动生成的\nconst bundle = require(\"../dist/vue-ssr-server-bundle.json\");\nconst clientManifest = require(\"../dist/vue-ssr-client-manifest.json\");\n\n// 传入clientManifest和bundle\nconst renderer = createBundleRenderer(\n  bundle,\n  {\n    clientManifest,\n    template: readFileSync(ab(\"./src/index.html\"))?.toString(),\n    runInNewContext: false,\n    basedir: ab(\"./dist\"),\n  }\n);\n\n// 使用\n// async function\nconst html = await renderer.renderToString(context)\n// html 即 渲染后的html结构\n```\n\n一旦bundle和manifest配置完毕，`vue-server-render`会自动帮我们做很多工作，例如客户端激活。\n\n还有需要在html模版文件中的body标签哪加上**<!--vue-ssr-outlet-->**，这样`vue-server-renderer`就会将生成的vue实例挂载在对应位置。\n\n## 集成vue-router\n\n从两个角度来说：\n\n一是服务端，当一个路由请求发送到服务端，这是路由匹配发生在服务端\n\n```typescript\n// server entry\nimport { createApp } from \"./app\";\n\ninterface IServerContext {\n  url: string;\n  state: any,\n  meta: any\n}\n\nexport default function (ctx: IServerContext) {\n  const { app, router, store } = createApp(); // 此处创建vue实例\n  return new Promise<typeof app>((resolve, reject) => {\n    router.push(ctx.url); // 匹配路由\n\t\t\n    // 在onReady做一些处理操作\n    router.onReady(() => {\n      // 获得所有以已经匹配的组件\n      const matchedComponents = router.getMatchedComponents();\n      if (matchedComponents.length <= 0) {\n        return reject({ code: 404 });\n      }// 没有说明 没有匹配此路由的组件，返回404\n\t\t\t\n      // 我们约定存在 asyncData选项\n      // 它返回Promise，并且在服务端执行\n      // 当 asyncData执行完毕后才会生成html返回给客户端\n      Promise.all(\n        matchedComponents.map((com: any) => {\n          if (com.asyncData !== undefined) {\n            return com.asyncData({ store, router: router.currentRoute });\n          }\n        })\n      ).then(() => {\n        resolve(app);\n      });\n    }, reject);\n  });\n}\n```\n\n二是客户端，当在客户端使用router跳转时，也需要去先执行asyncData，待其执行完毕后在返回页面。\n\n```typescript\n// client entry\n// ...\n\n// 处理路由 update的情况\nVue.mixin({\n  beforeRouteUpdate(to, from, next) {\n    Promise.all(\n      to.matched.map((c) => {\n        const options = c.components.$options;\n        const asyncData = (options as any).asyncData;\n        if (asyncData) {\n          return asyncData({\n            store: store,\n            route: to,\n          });\n        }\n      })\n    ).finally(next);\n  },\n});\n\nrouter.onReady(() => {\n  router.beforeResolve((to, from, next) => {\n    const matched = router.getMatchedComponents(to);\n    const prevMatched = router.getMatchedComponents(from);\n\t\t\n    // 对比 两条路由下的组件有否有不同，若都相同就就直接跳转\n    let diffed = false;\n    const activated = matched.filter((c, i) => {\n      return diffed || (diffed = prevMatched[i] !== c);\n    });\n\n    if (activated.length <= 0) next();\n\n    // 这里可以显示加载器\n    const render = createLoading();\n\n    render\n      .mount()\n      .then(() =>\n        Promise.all(\n          activated.map((c: any) => {\n            if (c.asyncData) return c.asyncData({ store, router: to });\n          })\n        )\n      )\n      .then((res) => {\n        // TODO 将结果 合并到data选项\n      })\n      .finally(() => {\n        // 这里可以关闭加载器\n        render.hide();\n        next();\n      });\n  });\n  app.$mount(\"#app\");\n});\n```\n\n上面这种路由策略，是必须先asyncData执行完毕，再展示画面，这通常会有一个全屏的loading页。\n\n还有一种策略是，直接显示页面，当aysncData执行完毕再将其填充组件，这样对于每一个组件都应该有一个loading状态。\n\n## 集成vuex\n\n服务端收到路由请求，先匹配路由，执行asyncData，其可能会修改store的值。待所有路由组件的asyncData执行完毕后。会在返回给客户端的html中插入一段**script**\n\n```html\n<script>\nwindow.__INITIAL_STATE__ = {\n  // state的值\n}\n</script>\n```\n\n客户端需要将**\\_\\_INITIAL_STATE\\_\\_**的值插入store实例中。\n\n```typescript\n// client entry\nconst initalState = (window as any).__INITIAL_STATE__;\nif (initalState) {\n  store.replaceState(initalState);\n}\n```\n\n在服务端中需要加上一段\n\n```typescript\nexport default function (ctx: IServerContext) {\n  const { app, router, store } = createApp();\n  return new Promise<typeof app>((resolve, reject) => {\n    router.push(ctx.url);\n    ctx.meta = app.$meta()\n\n    router.onReady(() => {\n      const matchedComponents = router.getMatchedComponents();\n      if (matchedComponents.length <= 0) {\n        return reject({ code: 404 });\n      }\n\n      Promise.all(\n        matchedComponents.map((com: any) => {\n          if (com.asyncData !== undefined) {\n            return com.asyncData({ store, router: router.currentRoute });\n          }\n        })\n      ).then(() => {\n        // 在上下文加上 state\n        ctx.state = store.state\n        resolve(app);\n      });\n    }, reject);\n  });\n}\n```\n\n在服务端入口文件中导出的这个function，会在使用`render.renderToString(context)`是自动调用，其ctx对于传入的context参数。这个context也会被`vue-server-render`使用到。\n\n## 开发环境的构建\n\n生产环境直接打包启用服务即可。\n\n在开发环境下，需要实现热更新。当用户代码发生修改时，重新打包，并通过socket通知浏览器更新相应内容。\n\n客户端的热更新：由于我们使用的是koa，所以这里使用`koa-webpack`插件，它集成了两个插件：\n`webpack-dev-middleware`：打包项目到内存中，并允许客户端访问到\n`webpack-hot-client`：实现热更新\n\n```typescript\n// 获取webpack配置\nconst clientConfig = createClientConfig();\n// 生成compiler\nconst clientCompiler = webpack(clientConfig);\nkoaWebpack({\n  compiler: clientCompiler,\n  devMiddleware: {\n    publicPath: clientConfig.output?.publicPath,\n  },\n}).then((middleware) => app.use(middleware)); // 注册中间件\n```\n\n服务端的热更新，直接用webpack watch模式来打包。但是注意需要修改文件输出的文件系统，我们需要将打包后的文件放在内存中而不是磁盘上。\n\n```typescript\n// * 处理服务端 更新获取bundle\nconst serverConfig = createServerConf();\nconst serverCompiler = webpack(serverConfig);\n\n// 使用 memory-fs 来修改 webpack默认的文件系统\nconst mfs = new MemoryFs();\nserverCompiler.outputFileSystem = mfs;\n\n// watch模式 打包\nserverCompiler.watch({}, (err, stats) => {\n  if (err) throw err;\n  const result = stats.toJson();\n  if (result.errors.length) return;\n\n  // TODO 打包成功\n});\n```\n\n## css支持\n\ncss的支持只需要有正确的webpack loader配置即可。\n\n需要注意的是，使用`vue-style-loader`来代替`style-loader`。前者支持服务端渲染。\n\n还有一个坑是，`css-loader`的默认配置与`vue-style-loader`冲突，需要关闭`esModule`\n\n```typescript\nexport default {\n  // 省略\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          isDev ? \"vue-style-loader\" : extractLoader,\n          {\n            loader: \"css-loader\",\n            options: {\n              esModule: false, // 关闭 esModule\n            },\n          },\n        ],\n      },\n    ],\n  },\n  // 省略\n};\n```\n\n还可以加上`postcss-loader`、`sass-loader`等\n\n## HEAD支持\n\n为了更好得支持`SEO`。提供了自定义head的能力。我们通过[vue-meta](https://vue-meta.nuxtjs.org/guide/ssr.html)来实现。\n\n先注册插件\n\n```typescript\nimport Vue from 'vue'\nimport VueMeta from 'vue-meta'\n\nVue.use(VueMeta)\n```\n\n在服务端入口文件\n\n```typescript\nexport default function (ctx: IServerContext) {\n  const { app, router, store } = createApp();\n  return new Promise<typeof app>((resolve, reject) => {\n    router.push(ctx.url);\n    // 加上这句\n    ctx.meta = app.$meta()\n\n    // 省略...\n}\n```\n\n最后修改html模版文件\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n  <meta charset=\"UTF-8\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  {{{ meta.inject().title ? meta.inject().title.text() : '' }}}\n  {{{ meta.inject().meta ? meta.inject().meta.text() : '' }}}\n</head>\n\n<body>\n  <!--vue-ssr-outlet-->\n</body>\n\n</html>\n```\n\n使用：在metaInfo选项中配置\n\n```typescript\nexport default {\n  metaInfo: {\n    title: \"Home页面\",\n    meta: [{ charset: \"utf-8\" }, { name: \"description\", content: \"foo\" }],\n  },\n}\n```\n\n## 客户端激活\n\n客户端激活的工作已经由`vue-server-renderer`完成了。我们分析一下它是如何实现的。\n\n在服务端，由`vue-server-renderer`生成html。会在相应的html上打上标记，例如`<div id=\"app\" data-server-rendered=\"true\">`。客户端识别到`data-server-rendered`属性，就会知道这部分html是由服务端如渲染而来的，随后客户端就会激活这些静态的HTML\n\n## 缓存\n\n每次请求，服务端都需要创建组件实例，这会有一定的性能损耗。对于**非用户特定的页面**（对不同的用户展示相同内容的页面），我们可以进行缓存\n\n### 缓存页面\n\n以页面为单位，缓存html文本\n\n```typescript\nimport LRU from \"lru-cache\";\n\nconst pageCache = new LRU({\n  max: 100,\n  maxAge: 1000, // 重要提示：条目在 1 秒后过期。\n});\n\nasync function renderPage(ctx: Context) {\n  console.log(\"路由匹配:\", ctx.url);\n  try {\n    // 判断 是否命中缓存\n    const cacheable = isCacheable(ctx.url);\n    if (cacheable && pageCache.get(ctx.url)) {\n      ctx.status = 200;\n      ctx.body = pageCache.get(ctx.url);\n      return;\n    }\n    const context: any = {\n      url: ctx.url,\n    };\n    const html = await renderer.renderToString(context);\n\n    ctx.res.setHeader(\"Content-Type\", \"text/html\");\n    ctx.status = 200;\n    ctx.body = html;\n\t\t\n    // 设置缓存\n    if (cacheable) {\n      pageCache.set(ctx.url, html);\n    }\n  } catch (err) {\n    // 省略\n  }\n}\n\nfunction isCacheable(url: string) {\n  return [\"/about\", \"/profiles\"].indexOf(url) >= 0;\n}\n```\n\n### 缓存组件\n\n一组件为单位来缓存。`vue-server-renderer` 内置支持组件级别缓存。只需要在创建`renderer`时传递`cache`参数。\n\n```typescript\nimport LRU from \"lru-cache\";\n\nconst renderer = createRenderer({\n  cache: LRU({\n    max: 10000,\n    maxAge: 1000\n  })\n})\n```\n\n在组件内，设置`serverCacheKey`选项来启用缓存。\n\n```typescript\nexport default {\n  name: 'item', // 必填选项\n  props: ['item'],\n  serverCacheKey: props => props.item.id,\n  render (h) {\n    return h('div', this.item.id)\n  }\n}\n```\n\n注意：\n\n- `serverCacheKey`的返回值表示缓存，当前发生变化缓存失效。若返回常量表示组件将被永久缓存\n- `name`唯一\n\n通常来说，组件缓存比较适用于一种场景。`v-for`渲染大组件列表。通常数据都会有个id和最后更新时间。通过这两个属性可以决定缓存是否有效\n\n```typescript\nexport default {\n  serverCacheKey: props => props.item.id + '::' + props.item.last_updated\n}\n```\n\n","tags":["Nodejs","vue2","ssr"],"categories":["Nodejs","Server"]},{"title":"Nodejs搭建服务端","url":"/posts/9e0c0ca5.html","content":"\n## 服务端\n\n服务端顾名思义就是提供服务的一方。\n\n先回顾一下四层模型：`应用层（最顶层）`-> `传输层` -> `网络层` -> `数据链路层（最底层）`\n\n其中传输层使用的是`TCP/UDP`协议\n应用层使用的协议有`http`、`ftp`等\n\n任何一种网络服务都必须遵从一种协议。\n\n`nodejs`内置了若干模块，实现了常见的网络协议，并向用户提供了便利的接口。\n\n> 四层模型只是理论模型\n\n## Net模块\n\n[`net`](https://nodejs.org/dist/latest-v14.x/docs/api/net.html)模块在[认识RPC](/posts/91c0fa71.html#搭建多路复用的RPC通道)中提到过，当时是用来搭建RPC通道。\n\n它可以建立基于流的TCP服务端和客户端。\n简单的说，就是建立两端——服务端和客户端，两者之间通过TCP连接。数据以流的方式传输（`Buffer`）\n\n```typescript\n// server.ts\nimport { createServer } from \"net\";\n\nconst server = createServer((socket) => {\n  //\n  socket.on(\"data\", (buffer) => {\n    console.log(\"server: receive data from server: \", buffer.toString());\n  });\n\n  socket.write(\"hello client!\");\n});\n\nserver.listen(8081);\n\n// ---------------------------------------------\n\n// client.ts\nimport { createConnection } from \"net\";\n\nconst socket = createConnection({\n  host: \"localhost\",\n  port: 8081,\n});\n\nsocket.on(\"data\", (buffer) => {\n  console.log(\"client: receive data from server: \", buffer.toString());\n\n  socket.write(\"hello server!\")\n});\n\nsocket.on(\"close\", () => {\n  console.log(\"client: close connection\");\n});\n```\n\n服务端通过`createServer`创建一个TCP服务，其回调函数接受`socket`作为参数。\n客户端通过`createConnection`来连接服务端，其返回`socket`\n\n`sokect`是服务端和客户端用来通信的工具\n\n```typescript\n// 通过on来监听data事件\n// 有消息发送过来 就会触发该事件\n// 参数为buffer，使用toString toJSON等方法来获取原始值，参考nodejs buffer模块\nsocket.on(\"data\", buffer => {\n  // TODO\n  // buffer.toString()\n  // buffer.toJSON()\n})\n\n// socket.write(data[, encoding][, callback])\n// write方法用来发送数据\nsocket.write(\"hello\")\n```\n\n`buffer`的编解码可以使用[`Protocol Buffers`](https://github.com/protocolbuffers/protobuf)\n\n## HTTP模块\n\n[`http`模块](https://nodejs.org/dist/latest-v14.x/docs/api/http.html)实现了`HTTP协议`。`HTTP协议`是基于`TCP协议`的，所以`nodejs`的`http`模块是基于`net`模块的。\n\n传统的web网站主要使用的就是http协议\n\n```typescript\nimport { createServer } from \"http\";\nimport { readFileSync } from \"fs\";\n\nconst buffer = readFileSync(\"./index.html\");\n\nconst server = createServer((req, res) => {\n  res.end(buffer);\n});\n\nserver.listen(\"8080\");\n```\n\n在浏览器输入`localhost:8080`就可以访问`index.html`。一个极简的http服务就搭建成了。\n\n`http`模块也提供了客户端方法——`request`\n\n```typescript\nimport { request } from 'http'\n\nconst postData = querystring.stringify({\n  'msg': 'Hello World!'\n});\n\nconst options = {\n  hostname: 'www.google.com',\n  port: 80,\n  path: '/upload',\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Content-Length': Buffer.byteLength(postData)\n  }\n};\n\nconst req = http.request(options, (res) => {\n  console.log(`STATUS: ${res.statusCode}`);\n  console.log(`HEADERS: ${JSON.stringify(res.headers)}`);\n  res.setEncoding('utf8');\n  res.on('data', (chunk) => {\n    console.log(`BODY: ${chunk}`);\n  });\n  res.on('end', () => {\n    console.log('No more data in response.');\n  });\n});\n\nreq.on('error', (e) => {\n  console.error(`problem with request: ${e.message}`);\n});\n\n// Write data to request body\nreq.write(postData);\nreq.end();\n```\n\n## HTTPS模块\n\n在`HTTP`和`TCP`之间有加了一层`TLS/SSL`，以解决明文传输的安全问题\n\n`HTTPS`在`HTTP`基础上添加了`TLS/SSL`加密功能。在`nodejs`中`TLS/SSL`也是一个独立的模块。`HTTPS`模块基于`HTTP`模块和`TLS/SSL`模块。\n\n对于开发者，使用`HTTPS`就是多了一步——**配置私钥和证书**。\n\n### 生成私钥和证书\n\n首选确认正确安装`openssl`。将通过命令行来生成私钥和证书\n\n第一步，生成私钥key , `ryans-key.pem`\n\n```bash\nopenssl genrsa -out ryans-key.pem 2048\n```\n\n第二步，根据私钥，生成证书注册请求（Certificate Signing Request， CSR）, `ryans-csr.pem`，会提问一堆问题（密码记住）\n\n```bash\nopenssl req -new -sha256 -key ryans-key.pem -out ryans-csr.pem\n```\n\n第三步，把CSR发给CA机构签名，我们这一步采用自签名的方式，获得证书`ryans-cert.pem`\n\n```bash\nopenssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem\n```\n\n至此，我们获得了私钥和`cer证书`。\n\n我们还可以进一步获取`pfx证书`,`ryans.pfx`\n\n```bash\nopenssl pkcs12 -export -in ryans-cert.pem -inkey ryans-key.pem -out ryans.pfx\n```\n\n### https模块使用\n\n```typescript\nimport { createServer } from \"https\";\nimport { fstat, readFileSync } from \"fs\";\n\nconst options = {\n  key: readFileSync(\"./certs/ryans-key.pem\"),\n  cert: readFileSync(\"./certs/ryans-cert.pem\"),\n};\n\nconst html = readFileSync('../index.html')\n\nconst server = createServer(options, (req, res) => {\n  res.end(html)\n});\n\nserver.listen(443) // https默认是443端口\n```\n\n使用Chrome来测试，首先需要允许`localhost`使用无效证书（没有经过CA签名）。`chrome://flags/#allow-insecure-localhost`，设为`Enabled`即可\n\n在浏览器中输入`https://localhost:443`。就可以看到页面了\n\n还可以使用pfx证书，pfx证书相对于cer证书：\n\n- cer证书只包含公钥\n- pfx证书包含公钥和私钥\n\n```typescript\nimport { createServer } from \"https\";\nimport { fstat, readFileSync } from \"fs\";\n\nconst options = {\n  pfx: readFileSync('./certs/ryans.pfx'),\n  passphrase: '' // pfx证书的密码\n};\n\nconst html = readFileSync('../index.html')\n\nconst server = createServer(options, (req, res) => {\n  res.end(html)\n});\n\nserver.listen(443)\n```\n\n`https`模块也有`https.request`方法用来发起https请求\n\n## HTTP/2\n\n### HTTP/2 特点\n\n`http`通常指`http/1.1`。`http/2`相较于`http/1.1`做了很多提升:\n\n- **`TLS/SSL`加密**：和https一样。所以也需要配置证书和私钥\n- **二进制传输**：`http/1.1`传输的是文本，`http/2`传输的是二进制流\n- **多路复用**：`http/2`有两个概念——**帧**和**流**。`http/2`将数据报文分成一个个二进制**帧（Frame）**，在一个TCP连接中，不同的帧组合在一起发送（**二进制分帧**）形成**流（Stream）**。在接收方根据帧首部信息在组合起来。`HTTP/1.1`只能一个个请求报文排队发送。\n- **header压缩**：http请求有这繁多冗长的首部，`http/2`会对首部进行压缩\n- **服务端推送**：能够主动给客户端推送资源\n  - `http/1.1`加载网页的顺序：请求html，解析html，再请求js、css等文件\n  - `http/2`：当服务端收到html请求时，服务端就主动吧html、css、js以及图片等资源发送给客户端\n\n> 前4个都是`http/2`自动实现的。服务端推送需要开发者手动配置。\n\n### Nodejs实现\n\n`nodejs`内置了`http2`模块，实现了`http/2`协议。\n\n```typescript\nimport { createSecureServer } from \"http2\";\nimport { readFileSync } from \"fs\";\n\nconst options = {\n  pfx: readFileSync(\"./certs/ryans.pfx\"),\n  passphrase: \"\",\n};\n\nconst html = readFileSync(\"../index.html\");\n\nconst server = createSecureServer(options);\n\nserver.on(\"stream\", (stream, headers) => {\n  stream.respond({\n    \"content-type\": \"text/html; charset=utf-8\",\n    \":status\": 200,\n  });\n  stream.end(html);\n});\n\nserver.listen(443);\n```\n\n`http2`模块有两个创建服务的方法——`createServer`和`createSecureServer`。前者是不带TLS/SSL加密的，后者带加密。目前主流浏览器只支持带`TLS/SSL`加密的`HTTP/2`\n\n监听`http2Server`的`stream`事件，当请求发来就来触发该事件（http2数据是以二进制流的形式传输）\n\n`http2Stream`是一个双工流。既可以发送数据也可以接受数据。`ServerHttp2Stream`是其实现，其：\n\n- `http2stream.pushStream(headers[, options], callback)`：实现服务端主动推送\n- `http2stream.respond([headers[, options]])`：发送回应，可以在这设置响应头\n- `stream`是一个流，使用`stream.write()`向其写入内容或`stream.end(content)`结束这个流\n\n### 服务端推送(Server Push)\n\n这是http/2的一大特点。nodejs中实现通过`pushStream`方法即可实现\n\n```typescript\nimport { createSecureServer } from \"http2\";\nimport { readFileSync } from \"fs\";\n\nconst options = {\n  pfx: readFileSync(\"./certs/ryans.pfx\"),\n  passphrase: \"\",\n};\n\nconst html = readFileSync(\"../index.html\");\nconst png = readFileSync(\"../hello.jpg\");\n\nconst server = createSecureServer(options);\n\nserver.on(\"stream\", (stream, headers) => {\n  stream.respond({\n    \"content-type\": \"text/html; charset=utf-8\",\n    \":status\": 200,\n  });\n  stream.pushStream({ \":path\": \"/hello.jpg\" }, (err, pushStream, headers) => {\n    if (err) throw err;\n    pushStream.respond({ \":status\": 200 });\n    pushStream.end(png);\n  });\n  stream.end(html);\n});\n\nserver.listen(443);\n\n```\n\n上例在用户请求`https://localhost`时，将index.html和`https://localhost/hello.jpg`一起发送给客户端。\n\n### 客户端\n\n`http2`模块也提供了客户端实现。\n\n```typescript\nimport { connect } from \"http2\";\nimport { readFileSync } from \"fs\";\n\nconst client = connect(\"https://www.zxffan.com:443\", {\n  ca: readFileSync(\"./certs/ryans-cert.pem\"),\n});\n\nconst req = client.request({ \":path\": \"/\" });\n\nreq.on(\"response\", (headers, flags) => {\n  for (const name in headers) {\n    console.log(`${name}: ${headers[name]}`);\n  }\n});\n\nreq.setEncoding(\"utf8\");\nlet data = \"\";\nreq.on(\"data\", (chunk) => {\n  data += chunk;\n});\nreq.on(\"end\", () => {\n  console.log(`\\n${data}`);\n  client.close();\n});\nreq.end();\n```\n\n客户端需要配置ca证书\n\n## Express\n\n`Express`是`ndoejs`的第三方库，它对网络模块做了增强。来个例子：\n\n```typescript\nimport express from \"express\";\nimport { createServer } from 'http'\n\nconst app = express();\nconst server = createServer(app)\n\napp.get(\"/\", (req, res) => {\n  // TODO\n  res.send('hello express!')\n});\n\napp.use((req, res, next) => {\n  console.log('Time: %d', Date.now())\n  next()\n})\n\nserver.listen(3000);\n```\n\n将app传给`createServer`。这样`express`就拦截了所有请求，在收到请求到响应之间就可以添加很多**中间件**。\n\n- 中间件系统，`app.use`来注册一个中间件，所有请求回按照中间件注册顺序依次调用。\n\n- 路由系统，`express`新增了路由，`app.get`、`app.post`。路由本质上也是中间件\n\n### 中间件——洋葱模型\n\n```typescript\nimport express from \"express\";\nimport { createServer } from \"http\";\n\nconst app = express();\nconst server = createServer(app);\n\napp.use(\n  function m1(req, res, next)  {\n    console.log('m1 start');\n    next()\n    console.log('m1 end')\n  },\n  function m2(req, res, next)  {\n    console.log('m2 start');\n    next()\n    console.log('m2 end')\n  },\n  function m3(req, res, next)  {\n    console.log('m3 start');\n    next()\n    console.log('m3 end')\n  },\n);\n\napp.get(\"/\", (req, res) => {\n  // TODO\n  res.send(\"hello express!\");\n});\n\nserver.listen(3000);\n```\n\n上例注册了3个中间件——`m1`,`m2`和`m3`\n\n输出顺序：\n\n```text\nm1 start\nm2 start\nm3 start\nm3 end\nm2 end\nm1 end\n```\n\n中间件就像一个洋葱，`m1`是外表皮，`m2`是中间表皮，`m2`是内表皮。从洋葱的一层穿透到另一个，经过顺序必然是：`m1->m2->m3->m3->m2->m1`。、\n\n![洋葱模型](../../images/nodejs/中间件洋葱模型.png)\n\n但是`express`的洋葱模型又个问题——异步支持不好。如果m2中进行一个异步操作（RPC，查数据库等），其它中间件不会等待操作结果。`Koa`的出现弥补了这个缺点。\n\n### https和http2\n\nhttps\n\n```typescript\nimport express from \"express\";\nimport { createServer } from \"https\";\nimport { readFileSync } from \"fs\";\n\nconst options = {\n  pfx: readFileSync(\"./certs/ryans.pfx\"),\n  passphrase: \"\",\n};\n\nconst app = express();\nconst server = createServer(options, app);\n\nconst html = readFileSync(\"../index.html\", \"utf-8\");\n\napp.get(\"/\", (req, res) => {\n  // TODO\n  res.send(html);\n});\n\nserver.listen(3000);\n```\n\n使用方法和`http`模块类似。\n\n至于`http2`模块，`express`目前还无法与其兼容。参见官方[issue](https://github.com/expressjs/express/issues/2761#issuecomment-142610897)\n如果想在`http2`模块中使用`express`的路由，可以使用[`router`](https://github.com/pillarjs/router)，它是从express独立出来的并且兼容`http2`，参考[issue](https://github.com/expressjs/express/issues/2761#issuecomment-142612001)\n搜索资料，发现可以使用`spdy`这个库来结合express实现`http2`\n\n## Koa\n\n`Koa`是`express`原班人马打造的。`koa`就是一个**中间件系统**。他的中间件支持两种函数——普通函数和**异步函数**\n\n```typescript\nimport Koa from \"koa\";\nimport { createServer } from \"http\";\n\nconst app = new Koa();\nconst server = createServer(app.callback());\n\napp.use(async (ctx, next) => {\n  await next();\n  ctx.body = 'hello koa!'\n});\n\nserver.listen(3000);\n```\n\n我这里的写法都是通过原生`http`模块，这是为了体现`koa`、`express`只不过是一套中间件层。底层的网络服务还是nodejs提供的。\n\n也可以简写\n\n```typescript\nimport Koa from \"koa\";\n\nconst app = new Koa();\n\napp.use(async (ctx, next) => {\n  await next();\n  ctx.body = 'hello koa!'\n});\n\napp.listen(3000);\n```\n\nkoa中间件支持nodejs的`async`和`await`语法，从而优雅的实现异步。\n\n### https\n\n使用https，也就是更换底层网络协议。\n\n```typescript\nimport Koa from \"koa\";\nimport { createServer } from \"https\";\nimport { readFileSync } from \"fs\";\n\nconst options = {\n  pfx: readFileSync(\"./certs/ryans.pfx\"),\n  passphrase: \"\",\n};\n\nconst app = new Koa();\nconst server = createServer(options, app.callback());\n\nconst html = readFileSync(\"../index.html\", \"utf-8\");\n\napp.use(async (ctx, next) => {\n  await next();\n  ctx.body = html;\n});\n\nserver.listen(3000);\n```\n\n### http/2\n\n`Koa`是兼容`http2`模块的：\n\n```typescript\nimport Koa from \"koa\";\nimport { createSecureServer } from \"http2\";\nimport { readFileSync } from \"fs\";\n\nconst options = {\n  pfx: readFileSync(\"./certs/ryans.pfx\"),\n  passphrase: \"\",\n};\n\nconst html = readFileSync(\"../index.html\", \"utf-8\");\n\nconst app = new Koa();\nconst server = createSecureServer(options, app.callback());\n\napp.use(async (ctx, next) => {\n  await next();\n  ctx.\n  ctx.body = html;\n});\n\nserver.listen(443);\n```\n\nkoa如何使用服务端推送，目前还没有查到😂。\n\n查了下官方issue，开发者只提到兼容HTTP/2。没提`server push`，不过有人建议通过`ctx.stream`的形式获得流，进而使用`stream.pushStream()`\n\n## HTTP/3\n\n`HTTP/1.x`、`HTTPS`以及`HTTP/2.0`都离不开底层的`TCP`协议。\n\n`HTTP/2.0`采用多路复用，多个数据包使用一个`TCP`连接。`TCP`是可靠连接，但发生丢包时，会进行重传。所以网络状态差的情况下，某些数据包频繁重传，从而导致拥塞，后面的HTTP包都穿不出去。这叫做**头部阻塞（Head of line Blocking）**\n\n`HTTP/3.0`就开始考虑放弃`TCP`转向`UDP`协议。起初`Google`搞出来个`QUIC`协议，后来`IETF`标准化了`QUIC`协议形成`HTTP/3`。其底层采用`UDP`，基于`UDP`实现做了众多增强：\n\n- 0RTT：`TPC`建立连接每次都需要三次握手，就存在数据包的三次往返即**3RTT**。而`QUIC`首次建立连接只需要`1RTT`。其后的连接可以直接复用，只需要**0RTT**\n- 连接迁移：当`源IP`、`源端口`、`目的IP`、`目的端口`其中一个发生变化就需要重新建立TCP连接。只要**Connection ID**没有变化。`HTTP/3`可以继续复用连接\n- 头部阻塞：由于使用`UDP`，发生丢包时，也不会立即重传，阻塞连接。\n- 拥塞控制\n- 前向纠错\n- 更多特性 请参考[文章](https://zhuanlan.zhihu.com/p/143464334)\n\nnodejs目前未支持`HTTP/3`。\n\nchrome只支持 `Google QUIC`。对`IETF QUIC`的支持处于`WIP`状态\n\n","tags":["Nodejs","服务"],"categories":["Nodejs","Server"]},{"title":"Nginx","url":"/posts/d0156050.html","content":"\n> nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server\n>\n> nginx是一个HTTP服务器、反向代理服务器、邮件代理服务器、通用TCP/UDP代理服务器\n\n总而言之，`nginx`能够在你的机器上跑起HTTP服务，我们可以在这个服务上部署传统的Web系统。\n\n## Nginx配置\n\n安装什么的就不提了。nginx的配置框架如下\n\n```nginx\n\n#user  nobody;\nworker_processes  1; #配置工作进程数目\n\n#配置全局错误日志及类型 [debug|info|notice|warn|error|crit(致命错误)] 默认error\n#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;\n\n#配置进程pid文件\n#pid        logs/nginx.pid;\n\n\n#配置工作模式和连接数\nevents {\n  #配置每个worker的最大连接数\n  #nginx最大连接数 = worker_process * worder_connections\n  worker_connections  1024;\n}\n\n#配置http\nhttp {\n  #include 用来引入其他文件的配置\n  #当收到静态资源请求时，会根据资源的后缀名去mime.types里找对应的mime类型，再根据mime来设置响应头中的Content-Type\n  include       mime.types;\n  default_type  application/octet-stream; #设置默认响应类型\n\n  #设置日志格式\n  #log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n  #                  '$status $body_bytes_sent \"$http_referer\" '\n  #                  '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n  #access_log  logs/access.log  main;\n\n  #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，\n  #对于普通应用，必须设为 on,\n  #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，\n  #以平衡磁盘与网络I/O处理速度，降低系统的uptime.\n  sendfile        on;\n  #tcp_nopush     on; #累计一定量的数据包一起发送\n  #tcp_nodelay\t\ton; #默认延后0.2s后发送整合数据包（避免频繁发送小数据包）。on则关闭这个特性\n\n  #连接超时时间\n  #keepalive_timeout  0;\n  keepalive_timeout  65;\n\n  #开启gzip压缩\n  gzip  on;\n\n  server {\n    listen       8080; #配置监听端口\n    server_name  localhost; #配置服务名\n\n    #编码\n    #charset koi8-r;\n\n    #设置日志存放路径，格式为 main（在http中定义的）\n    access_log  logs/host.access.log  main;\n\n    #默认的匹配规则\n    location / {\n      root   html;\n      index  index.html index.htm;\n    }\n\n    #error_page  404              /404.html;\n\n    # redirect server error pages to the static page /50x.html\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n      root   html;\n    }\n\n    # 代理所有url中含有api的请求，并转发到 http://127.0.0.1\n    location /api/ {\n      proxy_pass   http://127.0.0.1:8080;\n    }\n\n    # 拒接所有ht文件请求\n    location ~ /\\.ht {\n      deny  all;\n    }\n  }\n\n  include servers/*;\n}\n\n```\n\n## 虚拟主机\n\n**虚拟主机技术**可以将一台物理服务器划分成多个**虚拟主机**。可以在每个虚拟主机部署网站。\n\n### 基于端口\n\n`server`下的`listen`字段可以设置所需监听的端口\n\n```nginx\nserver {\n  listen 8080;\n  root /project1/\n  \n  location / {\n    index index.html\n  }\n}\n```\n\n`localhost:8080`即可访问到虚拟主机（server）上部署的网站\n\n### 基于虚拟主机名\n\n`server_name`：配置虚拟主机的名称。可以配置成访问的域名\n\n```nginx\n# A\nserver {\n  listen  80;\n  server_name www.test1.com;\n  # ...\n}\n\n# B\nserver {\n  listen  80;\n  server_name www.test2.com;\n  # ...\n}\n```\n\n虚拟主机A和B监听同一个端口，但是通过配置不同的`server_name`来区分\n\n- `http://www.test1.com/index.html`将访问到虚拟主机A\n- `http://www.test2.com/index.html`将访问到虚拟主机B\n\n## location匹配规则\n\n`location [=|~|~*|^~] /uri/ { … }`\n\n- `=` 开头表示精确匹配\n\n- `^~` 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。\n\n- `~` 开头表示区分大小写的正则匹配\n\n- `~*` 开头表示不区分大小写的正则匹配\n\n- `!~`和`!~*`分别为区分大小写不匹配及不区分大小写不匹配 的正则\n\n- `/` 通用匹配，任何请求都会匹配到。\n\n## root和alias\n\n`rooot`和`alias`都是用来指定文件路径的\n\n```nginx\nlocation ^~ /public/ {\n\troot /www/root/html;\n}\n```\n\n当访问`/public/index.html`时会在`/www/root/html/public/index.html`路径下寻找文件\n\n```nginx\nlocation ^~ /public/ {\n\talias /www/root/html/;\n}\n```\n\n当访问`/public/index.html`时会在`/www/root/html/index.html`路径下寻找文件\n\n所以，区别就是在查找文件时，root会加上location配置路径，而alias不会\n\n## 初始页\n\n```nginx\nserver {\n  listen 80;\n  server_name www.test.com;\n  \n  location / {\n    root /website/project1;\n    index index.html welcome.html\n  }\n}\n```\n\n当访问`www.test.com`时，会在`/website/project1/`目录下寻找`index.html`文件，有则返回否则继续寻找`welcome.html`\n\n## 错误页\n\n对于一些错误页面（404，500等），可以通过以下配置来访问\n\n```nginx\nerror_page 404 =200 /404.html;\nlocation = /404.html {\n    root /website;\n}\n\nerror_page 500 502 503 =200 /50x.html;\nlocation = /50x.html {\n    root /website;\n} \n```\n\n当请求发生404时（访问到不存在的页面），会跳转到`/404.html`。为了防止找不到，加了个`location`指定文件所在位置（`/website/404.html`）。\n\n对于单页面应用，通常只有一个`index.html`。在配置404等错误时，需要返回`index.html`\n\n```nginx\nerror_page 404 =200 /404.html;\nlocation = /404.html {\n  root /website;\n  try_files $uri $uri/ /index.html;\n}\n```\n\n解释：发生404时，重定向到`/404.html`。匹配到`/404.html`的`location`。然后遇到`try_files`指令\n\n**`try_files $uri $uri/ /index.html;`**\n\n访问`/public/somepage.html`时，会前去找`$uri`(就是`/public/somepage.html`)，找不到寻找`$uri/`。找不到最后返回`/index.html`\n\n## 代理\n\n反向代理和正向代理都需要通过`proxy_pass`指令来实现。\n\n需要代理的场景一般有三种角色：\n\n- 客户端：一般指浏览器\n- 代理服务器：指nginx\n- 服务端：真正需要访问的服务器\n\n```nginx\nserver {\n  listen 80;\n  root /websites/demo;\n  \n  location / {\n    try_files $uri $uri/ /index.html;\n    index index.html;\n  }\n  \n  location ^~ /api {\n    proxy_pass http://localhost:8081/ #末尾加/ 转发就不会包含/api(location的路径配置)\n  }\n}\n```\n\n客户端访问`/api/get-user-info`。请求到达代理服务器，匹配到`/api`转发给`http://localhost:8081/get-user-info`。\n\n反向代理和正向代理本质上都是请求和响应的转发。根据代理的目的来划分它们。\n\n代理一般都是指**正向代理**，目的是**帮助内网的客户端访问外网**。比如通过科学上网访问google，它在国外假设一台没有被禁的代理服务器。国内访问这台代理服务器，代理服务器再去访问google。\n\n**反向代理**正好相反。它是**帮助外网的客户端访问内网**。比如访问baidu。客户端（浏览器）访问百度，会访问到baidu的代理服务器，通过代理服务器来访问baidu的内网服务器。\n\nnginx的反向代理常常被提到。因为它的性能真的很好。最重要的是反向代理可以来做**负载均衡**。\n\n## 负载均衡\n\n还以访问百度为例，当代理服务器收到客户端的请求时，代理服务器根据负载均衡规则（算法）来选择百度的内网服务器（百度的服务器肯定不止一台）来转发请求。\n\n### 配置\n\n```nginx\nhttp {\n  upstream backend {\n    server 127.0.0.1:3000 weight=3; # weight权重 越大访问的机率越高\n    server 127.0.0.1:5000 weight=1; \n  }\n  \n  server {\n    listen 80;\n    root /websites/demo\n    location / {\n      proxy_pass http://backend;\n    }\n  }\n}\n```\n\n所有请求都会代理转发到`upstream`中配置的服务器。按照权重分配\n\n### 策略\n\n#### 1.轮询（默认）\n\n```nginx\nupstream backserver { \n  server 127.0.0.1:3000; \n  server 127.0.0.1:5000; \n} \n```\n\n每个请求都会按照时间循序依次分配到所配置的后端服务器，如果服务器宕机则自动剔除\n\n#### 2.权重\n\n```nginx\nupstream backend {\n  server 127.0.0.1:3000 weight=3; # weight权重 越大访问的机率越高\n  server 127.0.0.1:5000 weight=1; \n}\n```\n\n指定轮询机率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n\n#### 3.IP哈希\n\n服务端可能需要访问session，如果每一次处理请求的服务端不同，是无法获取正确的session的。IP哈希是指每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，从而解决session的问题。\n\n```nginx\nupstream backserver { \n  ip_hash;\n  server 127.0.0.1:3000; \n  server 127.0.0.1:5000; \n} \n```\n\n#### 4.fair\n\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。 \n\n```nginx\nupstream backserver {\n  server 127.0.0.1:3000; \n  server 127.0.0.1:5000;\n  fair;\n} \n```\n\n#### 5.URL哈希\n\n根据请求URL的hash来分配，相同hash分配至同一台服务器\n\n```nginx\nupstream backserver {\n  server 127.0.0.1:3000; \n  server 127.0.0.1:5000;\n  hash $request_uri;\n  hash_method crc32;\n}\n```\n\n### 其它配置\n\n```nginx\nupstream backserver {\n  server 127.0.0.1:3000 down; # down表示服务宕机，不参与分配 \n  server 127.0.0.1:5000;\n  server 127.0.0.1:6000;\n  server 127.0.0.1:7000 backup; # backup表示这是备用服务，只有当其它服务全部down，才会启用备用服务\n}\n```\n\n\n\n## 设置头信息\n\n设置响应头有两个指令——`add_header`和`proxy_set_header`。\n\n- `add_header key value [always]`：**设置响应头给浏览器**，对20x和30x的响应码有效，加上`always`强制生效\n- `proxy_set_header key value`：**设置请求头给上游服务器**\n\n```nginx\n# nginx 设置cors跨域\nadd_header 'Access-Control-Allow-Origin' '*';\nadd_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, DELETE';\nadd_header 'Access-Control-Allow-Headers' 'Content-Type';\nlocation ^~ /api {\n  if ($request_method = 'OPTIONS') {\n    return 200;\n  }\n  proxy_set_header Host $http_host;\n  proxy_pass http://127.0.0.1:8081/;\n}\n```\n\n## 变量参数\n\nnginx内置了很多变量，使用形式`$变量名`\n\n```nginx\n$args                    #请求中的参数值\n$query_string            #同 $args\n$arg_NAME                #GET请求中NAME的值\n$is_args                 #如果请求中有参数，值为\"?\"，否则为空字符串\n$uri                     #请求中的当前URI(不带请求参数，参数位于$args)，可以不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改，$uri不包含主机名，如\"/foo/bar.html\"。\n$document_uri            #同 $uri\n$document_root           #当前请求的文档根目录或别名\n$host                    #优先级：HTTP请求行的主机名>\"HOST\"请求头字段>符合请求的服务器名.请求中的主机头字段，如果请求中的主机头不可用，则为服务器处理请求的服务器名称\n$hostname                #主机名\n$https                   #如果开启了SSL安全模式，值为\"on\"，否则为空字符串。\n$binary_remote_addr      #客户端地址的二进制形式，固定长度为4个字节\n$body_bytes_sent         #传输给客户端的字节数，响应头不计算在内；这个变量和Apache的mod_log_config模块中的\"%B\"参数保持兼容\n$bytes_sent              #传输给客户端的字节数\n$connection              #TCP连接的序列号\n$connection_requests     #TCP连接当前的请求数量\n$content_length          #\"Content-Length\" 请求头字段\n$content_type            #\"Content-Type\" 请求头字段\n$cookie_name             #cookie名称\n$limit_rate              #用于设置响应的速度限制\n$msec                    #当前的Unix时间戳\n$nginx_version           #nginx版本\n$pid                     #工作进程的PID\n$pipe                    #如果请求来自管道通信，值为\"p\"，否则为\".\"\n$proxy_protocol_addr     #获取代理访问服务器的客户端地址，如果是直接访问，该值为空字符串\n$realpath_root           #当前请求的文档根目录或别名的真实路径，会将所有符号连接转换为真实路径\n$remote_addr             #客户端地址\n$remote_port             #客户端端口\n$remote_user             #用于HTTP基础认证服务的用户名\n$request                 #代表客户端的请求地址\n$request_body            #客户端的请求主体：此变量可在location中使用，将请求主体通过proxy_pass，fastcgi_pass，uwsgi_pass和scgi_pass传递给下一级的代理服务器\n$request_body_file       #将客户端请求主体保存在临时文件中。文件处理结束后，此文件需删除。如果需要之一开启此功能，需要设置client_body_in_file_only。如果将次文件传 递给后端的代理服务器，需要禁用request body，即设置proxy_pass_request_body off，fastcgi_pass_request_body off，uwsgi_pass_request_body off，or scgi_pass_request_body off\n$request_completion      #如果请求成功，值为\"OK\"，如果请求未完成或者请求不是一个范围请求的最后一部分，则为空\n$request_filename        #当前连接请求的文件路径，由root或alias指令与URI请求生成\n$request_length          #请求的长度 (包括请求的地址，http请求头和请求主体)\n$request_method          #HTTP请求方法，通常为\"GET\"或\"POST\"\n$request_time            #处理客户端请求使用的时间,单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。\n$request_uri             #这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI，不包含主机名，例如：\"/cnphp/test.php?arg=freemouse\"\n$scheme                  #请求使用的Web协议，\"http\" 或 \"https\"\n$server_addr             #服务器端地址，需要注意的是：为了避免访问linux系统内核，应将ip地址提前设置在配置文件中\n$server_name             #服务器名\n$server_port             #服务器端口\n$server_protocol         #服务器的HTTP版本，通常为 \"HTTP/1.0\" 或 \"HTTP/1.1\"\n$status                  #HTTP响应代码\n$time_iso8601            #服务器时间的ISO 8610格式\n$time_local              #服务器时间（LOG Format 格式）\n$cookie_NAME             #客户端请求Header头中的cookie变量，前缀\"$cookie_\"加上cookie名称的变量，该变量的值即为cookie名称的值\n$http_NAME               #匹配任意请求头字段；变量名中的后半部分NAME可以替换成任意请求头字段，如在配置文件中需要获取http请求头：\"Accept-Language\"，$http_accept_language即可\n$http_cookie　　　　　　　 #请求的所有cookie\n$http_host               #请求地址，即浏览器中你输入的地址（IP或域名）\n$http_referer            #url跳转来源,用来记录从那个页面链接访问过来的\n$http_user_agent         #用户终端浏览器等信息\n$http_x_forwarded_for    #客户端的IP和代理服务器的IP，以逗号隔开；可伪造\n$http_x_forwarded_proto  #请求的协议\n$sent_http_NAME          #可以设置任意http响应头字段；变量名中的后半部分NAME可以替换成任意响应头字段，如需要设置响应头Content-length，$sent_http_content_length即可\n$sent_http_cache_control\n$sent_http_connection\n$sent_http_content_type\n$sent_http_keep_alive\n$sent_http_last_modified\n$sent_http_location\n```\n\n## https\n\n在nginx中使用https，配置一下证书就可以\n\n```nginx\n# HTTPS server\n#\nserver {\n  listen       443 ssl;\n  server_name  localhost;\n\n  ssl_certificate      cert.pem; # 公钥，会被发送给每一个访问的客户端\n  ssl_certificate_key  cert.key; # 私钥，用来解密客户端发送的数据\n\n  ssl_session_cache    shared:SSL:1m; # 设置ssl/tls会话缓存的类型和大小\n  ssl_session_timeout  5m; # ssl参数的过期时间\n\n  ssl_ciphers  HIGH:!aNULL:!MD5; # 选择加密套件\n  ssl_prefer_server_ciphers  on; # on代表 设置协商加密算法时，优先使用服务端的加密套件，而不是客户端的加密套件\n\n  location / {\n    root   html;\n    index  index.html index.htm;\n  }\n}\n```\n\n## HTTP/2\n\n在https的例子上，做一处改动：在listen后加上http2即可\n\n```nginx\nlisten       443 ssl http2;\n```\n\n## Nginx日志切割\n\n如果把所有日志都打在一个日志文件中，当文件很大时，读写就会变慢从而影响nginx性能\n\n可以通过shell脚本按大小来切割日志文件。\n\n在nginx中，也可以按照时间来切割文件\n\n```nginx\nif ($time_iso8601 ~ \"^(\\d{4})-(\\d{2})-(\\d{2})\") {\n  set $year $1;\n  set $month $2;\n  set $day $3;\n}\naccess_log /var/log/nginx/$year-$month-$dayaccess.log json;\n```\n\n上例是把同一天的日志放在一个日志文件中。","tags":["Server","Nginx","Web"],"categories":["Server","Nginx"]},{"title":"JavaScript沙箱","url":"/posts/72bec40a.html","content":"\n> **沙盒**（英语：sandbox，又译为**沙箱**）是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用 **by wikipedia**\n\n简单的说，沙箱就是一个隔离的环境。沙箱里外互不影响。\n\n## Node的沙箱环境\n\n`nodejs`内置了一个`vm`模块，他可以让我们直接在 V8 虚拟机上下文中编译和运行代码，使用方法如下：\n\n```javascript\nconst vm = require(\"vm\");\n\n// 创建需要运行的脚本\nconst script = new vm.Script(\"a + b\");\n\n// 创建上下文 context\nconst context = vm.createContext({a: 1, b: 2});\n\n// 在上下文context下运行脚本\nconst result = script.runInContext(context)\n\nconsole.log(result) // 输出：3\n\n\n// 或者直接\nvm.runInContext(\"a + b\", context) // 输出：3\n```\n\n在nodejs中创建一个沙箱还是挺容易的。\n\n但是值得注意的是，`vm`模块并非绝对安全，由它创建的的沙箱内部通过一些手段还是可以访问到外部环境的。所以`nodejs`官方文档明确标注： **`vm` 模块不是安全的机制。 不要使用它来运行不受信任的代码**。\n\n也有一些社区模块：\n比如`vm2`，它内部使用`vm`模块，并且使用Proxy来阻止沙箱脚本逃逸。\n\n[`Safeify`](https://www.npmjs.com/package/safeify)是一个基于`vm2`的第三方库，它创建了个进程池，把代码放入进程池中执行。进程间通过IPC通讯。\n\n## 浏览器的沙箱环境\n\n浏览器环境没有`vm`这个API，实现将有所不同。\n\n### eval\n\n这是一个令人诟病的api，`eval(\"window\")`是能够访问到`window`对象的，所以它并不能隔离。\n\n### new Function()\n\n```javascript\nfn = new Function(...args, 'functionBody');\n```\n\n`new Function`依然能够访问到全局作用域。\n\n### with\n\n这个冷门的API，可能大多数JS开发者都没听说过\n\n```javascript\nfunction createRuntimeSandbox(src) {\n  src = 'with (context) {' + src + '}'\n  return new Function('context', src)\n}\n\nconst func = createRuntimeSandbox(\"console.log(window)\")\nfunc({window: 123}) // 输出 123\n```\n\n`with`关键字会使用`in`运算符来判断是否在`context`中。如果context存在就去context取。反之去全局作用域中取。\n\n### Proxy\n\n在with的例子上做些改动\n\n```javascript\nfunction createRuntimeSandbox(src) {\n  src = 'with (context) {' + src + '}'\n  const func = new Function('context', src)\n  return context => {\n    const fakeContext = {}\n    const proxy = new Proxy(fakeContext, {\n      has() { return true }, // 确保 xx in fakeContext 永远为true，不去全局作用域找\n      get(target, param) {\n        return target[param] || context[param]\n      }\n    })\n    return func(proxy)\n  }\n}\n\nconst func = createRuntimeSandbox(\"console.log(name);name='hello';console.log(name)\")\n\nconst context = { name: \"zxffan\", console }\nfunc(context) // 输出：zxffan hello\nconsole.log(context.name) // 输出：zxffan\n```\n\n上例使用了`proxy`，将上下文（context）做了代理。在沙箱里修改context的name属性不会影响到沙箱外。\n\n还有个问题，`proxy`只代理了`context`，如果context里又包含对象，那么在沙箱里是可以修改的。写一个通用的代理方法来解决\n\n```javascript\nfunction createProxySandbox(context, handler = {}) {\n  const fakeContext = {};\n  return new Proxy(fakeContext, Object.assign({\n    get(target, param) {\n      return Reflect.get(target, param) || Reflect.get(context, param)\n    }\n  }, handler))\n}\n\nfunction createRuntimeSandbox(src) {\n  src = 'with (context) {' + src + '}'\n  const func = new Function('context', src)\n  return context => {\n    const proxy = createProxySandbox(context, { has() { return true } })\n    return func(proxy)\n  }\n}\n\n\nconst func = createRuntimeSandbox(\"window.aa='zxffan';console.log(window.aa)\")\n\nconst fakeWindow = createProxySandbox(window)\nfakeWindow.window = fakeWindow\n\nfunc(fakeWindow) // 输出：zxffan\nconsole.log(window.aa) // 输出：undefined\n```\n\n这样使用，可以自定义需要暴露给沙箱的全局对象。\n\n`createProxySandbox`相当于代理提供的对象，并返回一个代理后的对象。对代理后的对象的修改不影响原对象，这本身就是一个**数据沙箱**。\n\n`createRuntimeSandbox`提供了一个指定上下文的JS执行环境。该环境确保不会直接访问和修改沙箱外的作用域的数据，这相当于一个**运行时沙箱**。\n\n## 总结\n\n沙箱的作用是隔离上下文环境，保证不会造成JS污染。\n\n应用场景：\n\n- 在微前端场景下，可以利用沙箱来保证各个微应用之间以及微应用和主应用之间不会造成JS污染。\n- 通常也可以将不受信（存在安全隐患）的代码放在沙箱中运行，以阻止其破坏主程序。\n\n推荐使用`with`、`new Function`以及`Proxy`构成的沙箱实现\n\n","tags":["javascript"],"categories":["JavaScript"]},{"title":"云计算的发展","url":"/posts/8aa364dc.html","content":"\n最近对`serverless`提起了兴趣，于是提笔写几篇学习笔记。\n\n## 时代历程\n\n总的来说云计算的发展经过了**物理机时代**、**虚拟机时代**、**容器时代**以及当下的**Serverless**。\n\n### 物理机时代\n\n发布一个网站，需要购买一台物理机服务器。然后手动安装操作系统和许多的软件环境。那时服务器发生故障时，服务迁移是一件很痛苦的事。而且购买物理机的成本也很高。\n\n### 虚拟机时代\n\n2001年后虚拟化技术日渐成熟。**虚拟化技术**可以将一台**物理机**分割成多台**虚拟机**供多名用户使用，充分利用硬件资源。比如阿里云的ECS，我上学的时候就买了一台虚拟机。相对于直接购买一台物理机，虚拟机可以大大降低成本。\n\n### 容器时代\n\n容器技术。目前比较流行的如`Docker`。在服务器上安装容器，将软件服务部署在容器中。这样，在做迁移的时候可以将容器内的软件环境打包成镜像。再拷贝到另一台服务器上部署。大大降低了迁移成本\n\n有了容器，在服务器上部署的就不再是应用而是一个个容器。当容器多了就比较难以管理。`Kubernetes(K8S)`是Google的用来进行容器编排的开源工具。有了K8S就可以实现网站的自动弹性伸缩。但是这一切的配置都需要专业的运维知识。\n\n### Serverless\n\n`Serverless`是指构建和运行不需要服务器管理的一种模式。目前Serverless实现方式主要是基于`FaaS`和`BaaS`\n\n- FaaS(函数即服务)：将应用切割成一个个独立的函数，每个函数有自己独立的业务，这些函数再组成复杂的应用。\n- Baas(后端即服务)：将数据库、文件存储等后端能力封装成服务，并以接口的形式提供。在FaaS中可以调用各种后端服务。\n\n一个Serverless的网站架构大致如下：\n\n![serverless架构](../../images/serverless/serverless网站架构.png)\n\n## XaaS\n\n梳理一些一些名词：IaaS、PaaS、SaaS、FaaS与BaaS\n\n- IaaS（基础设施即服务）：虚拟化技术成熟后，出现众多云厂商和产品。例如AWS 的 EC2、阿里云 ECS。这些都属于IaaS。\n- PaaS（平台即服务）：随着业务形态发展，云厂商发现可以抽象出一些通用的平台，比如中间件、数据库等，于是就把这些功能做成服务，也放在云上去卖，这些属于PaaS。\n- SaaS（软件即服务）：SaaS很常见。比如邮箱服务，软件环境部署在开发者服务器中。用户只需要一个账户，打开浏览器即可使用。\n- FaaS与BaaS上文讨论过。\n\n## Serverless\n\n### 什么是Serverless\n\n**广义的 Serverless** 是指：**构建和运行软件时不需要关心服务器的一种架构思想**\n\n**狭义的 Serverless** 是 **FaaS 和 BaaS 的组合**，这是当前主流的实现\n\nServerless的主要特点\n\n- 服务无关：开发者无需关心服务器资源（配置，磁盘大小等），只需要提供一份代码。\n- 弹性伸缩：资源的分配完全由云服务来计算，会根据请求量自动调整资源占用\n- 按量计费：在 Serverless 架构中，计费方式按实际使用量计费（比如函数调用次数、运行时长）。\n\n###  PaaS、Kubernetes 、云原生等技术是不是 Serverless？\n\n按照`Serverless`的特点来看，它们都不是\n`PaaS`是按照服务收费并非按量收费\n`K8S`是一种容器编排技术，它可以实现弹性伸缩。但是具体的编排规则需要专业运维来设置，不符合服务无关\n云原生是指原生为云设计的一种架构模式。`Serverless`是云原生的一种实现，`K8S`是另一种实现\n\n## Serverless的缺点\n\n1. 依赖第三方：使用`Serverless`就必须使用云厂商提供的`Serverless`的产品。这样就与云厂商绑定。一旦选定一个云厂商，在想做迁移就十分复杂。这是因为当前国内`Serverless`实现没有一个公共的标准。\n2. 底层硬件多样性：同一个云函数可能运行在不同硬件资源下。如果你的服务依赖于具体的硬件资源（比如只有某个CPU/GPU能够使用），这就要云厂商提供相应服务。\n3. 性能瓶颈：`Serverless`的云函数不是一直运行的，只有需要的时候才会执行。每次执行前会初始化函数执行环境，这需要一定时间。而这个时间需要云厂商自己去优化。\n4. 通信效率低：`Serverful`中函数掉函数都是在内存中进行的。而`Serverless`中函数都是独立的，之间调用（HTTP，RPC）肯定效率没有内存高\n5. 开发调试复杂：目前`Serverless`还处于发展阶段，各厂商的标准不一，开发和调试工具不完善。\n\n","tags":["Serverless","云计算"],"categories":["Serverles"]},{"title":"js实现选中与复制粘贴","url":"/posts/82fa4d6c.html","content":"\n## 选中\n\n### 两个对象\n\n1. [selection]( https://developer.mozilla.org/zh-CN/docs/Web/API/Selection )\n2. [range]( https://developer.mozilla.org/zh-CN/docs/Web/API/Range )\n\n> Selection对象所对应的是用户所选择的 [`ranges`](https://developer.mozilla.org/zh-CN/docs/Web/API/Range) （区域），俗称拖蓝 by MDN\n\nFirefox中可以通过按住ctrl同时选中不同区域，每个区域都对应一个range对象（chrome禁用了该功能，即只能选中一个区域）。selection代表文本选区（网页中可选择的区域），所以selection包含若干个range。可以通过`selection.getRangeAt(index)`来获取选区(range)。index是要获取的range的索引（chrome中只能是0）。\n\n### 应用：获取选中文本\n\n```javascript\nconst selection = window.getSelection()\nselection.toString()\n```\n\n### 应用：取消选中\n\n```javascript\nconst selection = window.getSelection()\nselection.removeAllRanges()\n```\n\n### 应用：全选某个节点的内容\n\n```javascript\nconst range = document.createRange() // 创建range对象\nconst node = document.getElementById('dom') // 获取要全选的dom节点\nrange.selectNodeContents(node)\n\nconst selection = window.getSelection()\nselection.removeAllRanges() // 清空其它选中内容\nselection.addRange(range) // 添加选中区域\n```\n\n### 应用：截取位置选中\n\n```javascript\nconst range = document.createRange()\nconst node = document.getElementById('dom') // 获取要截取的dom节点\n\n/* \n * * 如果起始节点类型是 Text， Comment, or CDATASection之一, 那么 startOffset指的是从起始节点算起字符的偏移量。 \n * * 对于其他 Node 类型节点， startOffset 是指从起始结点开始算起子节点的偏移量。\n */\nconst [startOffset, endOffset] = [1, 7]\nrange.setStart(node, startOffset)\nrange.setEnd(node, endOffset)\n\nconst selection = window.getSelection()\nselection.removeAllRanges() // 清空其它选中内容\nselection.addRange(range) // 添加选中区域\n```\n\n## 复制与粘贴\n\n复制与粘贴的实现需要使用[Clipboard](https://developer.mozilla.org/zh-CN/docs/Web/API/Clipboard)，它首先会通知用户是否赋予读写剪贴板权限。\n\n系统剪贴板暴露在全局属性`navigator.clipboard`之下\n\n它有四个API，他们都是返回Promise\n\n- read() 从剪贴板读取数据（比如图片）。\n- readText() 从剪贴板读取文本\n- write() 写数据\n- writeText() 写文本\n\n> 注意：\n> `document.execCommand`已经被废弃了，不建议使用。\n> `clipboard`在**非HTTPS环境**下不可用\n","tags":["javascript"],"categories":["JavaScript"]},{"title":"函数式编程","url":"/posts/1690d21b.html","content":"\n## 函数式编程要素\n\n- 声明式\n- 纯函数\n- 不可变性\n\n### 声明式\n\n**声明式**是将程序的描述与求值分离开来的。它关注于如何用各种表达式来描述程序逻辑。与其相对的是**命令式**。\n\n```javascript\n// demo：求数组的每个元素（数值类型）的平方\nconst arr = [1, 2, 3, 4, 5]\n\n// 命令式\nfor (let i = 0; i < arr.length; i++) {\n  arr[i] = Math.pow(arr[i], 2);\n}\n\n// 声明式\nconst square = num => Math.pow(num, 2)\narr.map(square)\n\n```\n\n### 纯函数\n\n纯函数要求：\n\n- 对于同一组输入必然有相同的输出。\n- 不依赖于外部环境也不改变外部环境。\n\n```javascript\n\n// 具有副作用的函数\nlet count1 = 0;\nfunction increment1() {\n  return ++count1 // 引用了全局变量\n}\n\n// 纯函数\nfunction increment2(count) {\n  return count + 1\n}\n\n```\n\n实际上，纯函数是很难得的。我们要做的就是尽可能地把具有副作用地部分抽离出来，让逻辑结构更加清晰。\n\n### 不可变数据\n\n处理数据时不要修改原数据，尽可能得基于原数据来构造新数据。\n\n```javascript\n\n// demo: 数组排序\n\nconst arr = [4, 6, 2, 3, 8, 5];\n\n// mutable\nfunction sort1() {\n  return arr.sort()\n}\n\n// immutable\nfunction sort1() {\n  return [].concat(arr).sort()\n}\n\n```\n\n> 函数式编程鼓励将复杂的任务分成成一个个纯函数。再将这些函数进行组合。这样使得任务流更加清晰，更易于维护\n\n## 柯里(curry)化\n\n柯里化可以缩减函数参数。\n\n一个向节点插入参数的demo\n\n```javascript\nfunction insertText(dom, text) {\n  document.querySelector(dom).innerText = text\n}\n\ninsertText(\"container\", \"hello world\")\n```\n\n经过柯里化后就变成了\n\n```javascript\nfunction insertText(dom) {\n  return function (text) {\n    document.querySelector(dom).innerText = text\n  }\n}\n\nconst insertToContainer = insertText(\"container\")\ninsertToContainer(\"hello world\")\n```\n\n## 组合\n\n组合是函数式编程的一个重要概念。将一个复杂的逻辑拆分成一个个函数后，需要将这些函数组合起来执行。\n\n### 链式组合\n\n在组合纯函数时，通过链式的方式比较容易被理解，例如:\n\n```javascript\narr.filter(/** .. **/)\n   .map(/** .. **/)\n   .reduce(/** .. **/)\n   //...\n```\n\n真的打算使用链式组合法的话，推荐`lodash.js`这个工具库。\n\n```javascript\nvar users = [\n  { 'user': 'barney',  'age': 36 },\n  { 'user': 'fred',    'age': 40 },\n  { 'user': 'pebbles', 'age': 1 }\n];\n \nvar youngest = _\n  .chain(users)\n  .sortBy('age')\n  .map(function(o) {\n    return o.user + ' is ' + o.age;\n  })\n  .head()\n  .value();\n// => 'pebbles is 1'\n```\n\n### 管道组合\n\n方法链的一个缺点就是：它与方法所属的对象紧紧地耦合在一起，限制链中可以使用的方法数量，也就限制了代码的表现力。\n\n```javascript\n\nfunction first() {}\n\nfunction getName() {}\n\nfunction reverse() {}\n\nfunction sort() {}\n\nconst task = pipe(first, getName, reverse, sort) // pipe 用来组合函数\n\ntask(params)\n\n```\n\n`pipe`将函数组合起来。`task`执行后，将`params`传递给`first`。`first`函数执行完成后再将结果传递给`getName`。由此类推，将所有函数组合起来，形如一条管道。\n\n上例中，`pipe`的参数都是函数声明，如果某个函数需要提前传入一些参数可以使用**柯里化**\n\n这里推荐一下`Ramda.js`这个工具库。它与`lodash`相似但却又不相同，它内置`pipe`方法以及其它组合方法。\n\n## 管道组合处理程序流\n\n上面的例子，都没有涉及到 逻辑分支。在命令式代码中，我们很容易就会写`if/else`，而函数式编程是不建议直接使用`if/else`的。\n\n在`Ramda.js`中`pipe`是用来组合函数的，叫做**组合器**。除了`pipe`还有其它组合器\n\n### R.compose\n\n`compose`与`pipe`功能一样，只是组合的方向相反。\n`R.compose(f1, f2, f3)`, 他会先执行f3，然后执行f2，最后f1\n\n### R.tap\n\n`compose`和`pipe`组合函数时，存在参数传递。每个函数的返回值都给传给管道中的下一个函数。\n如果中间有一个函数没有返回值（比如 日志埋点）就无法构成管道。\n\n`tap`能够将一个无返回值的函数插入管道中，因为tap会将参数原样返回。\n\n```javascript\nconst debug = R.tap(debugLog);\nconst cleanInput = R.compose(normalize, debug, trim);\nconst isValidSsn = R.compose(debug, checkLengthSsn, debug, cleanInput);\n```\n\n### alternation\n\n```javascript\nconst alt = function (...fns) {\n  return function (val) {\n    let result\n    for (let fn of fns) {\n      result = fn(val);\n      if (result) break;\n    }\n    return result\n  }\n}\n```\n\n`alt(fn1, fn2, fn3, ...)`，如果fn1的返回值不是`false`、`null`和`undefined`则返回fn1的返回值。否则执行fn2的，再判断其返回值。\n所以`alt`能够提供简单的逻辑条件判断\n\n### sequence\n\n实现如下\n\n```javascript\nconst seq = function(...funcs) {\n  const funcs = Array.prototype.slice.call(arguments);\n  return function (val) {\n    funcs.forEach(function (fn) {\n      fn(val);\n    });    \n  };\n};\n```\n\n`seq(fn1, fn2, fn3, ...)`, 会顺序执行所有函数，这些函数在管道中时平行的，它们都接受管道中上一个函数的返回值作为参数。通常放在管道的末尾。\n\n### fork-join\n\n```javascript\nfunction fork (join, ...fns) {\n  return function (val) {\n    let result = []\n    fns.forEach(fn => result.push(fn(val)));\n    join(...result)\n  }\n}\n```\n\n`fork`相对于`seq`增加了一步，将所有函数的执行结果传递给`join`，再做一次处理。\n\n未完...\n\n## Functor\n\n**`functor`是实现了`map`函数并遵守一些特定规则的容器类型。**比如下面这个`Just`容器\n\n```typescript\nclass Just<T> {\n  private _value: T;\n  constructor(value: T) {\n    this._value = value\n  }\n  map(fn: (...args: any[]) => any): Wrapper {\n    return Just.of(fn(this._value))\n  }\n\tstatic of<U>(value: U) {\n    return new Monad(value);\n  }\n}\n```\n\n这个**Just容器**就是一个**Functor（函子）**\n\n- 封装了value，容器外无法修改`_value`。从而保护数据\n- 提供map函数，该函数将原始值传给参数函数，并将结果再次封装。map函数将方便链式调用\n- of是一个静态函数。用于封装数据\n\n从本质上讲，Functor 只是一个可以将函数应用到它包裹的值上，并将结果再包裹起来的**数据结构**。\n\n## Maybe\n\n`Maybe`也属于`Functor`，它在`Just`上增加了错误处理\n\n```typescript\nclass Maybe<T> {\n  private _value: T;\n  constructor(value: T) {\n    this._value = value\n  }\n  isNothing(): boolean {\n    return this._value === undefined || this._value === null\n  }\n  map(fn: (...args: any[]) => any) {\n    return this.isNothing() ? Maybe.of(null) : Maybe.of(fn(this._value))\n  }\n\tstatic of<U>(value: U) {\n    return new Monad(value);\n  }\n}\n```\n\n当出现null，undefined时，调用不会抛出异常。\n\n```typescript\nMaybe.of(null).map((a) => a + 3)\n// Maybe { _value: null }\n```\n\n## Monad\n\n使用`functor`可能会造成嵌套封装的情况\n\n```typescript\nconst num = Maybe.of(Maybe.of(3))\nnum.map(v => v + 1) // error\n```\n\n这时，map的参数函数接受的参数`v`实际上还是一个`Functor`，它并不能直接参与运算。\n\n`Monad`可以使`functor`扁平化。\n\n- 提供一个`join`函数，其意是将所有嵌套的`Functor`合并成一个。\n- identity用来获取原始值，之前所有`this._value`替换成`this.identity()`\n\n```typescript\nclass Monad<T> {\n  private _value: T;\n  constructor(value: T) {\n    this._value = value;\n  }\n  isNothing(): boolean {\n    const value = this.identity()\n    return value === undefined || value === null;\n  }\n  join() {\n    if (this._value instanceof Monad) {\n      return this.isNothing() ? Monad.of(null) : this._value.join();\n    } else return this;\n  }\n  map(fn: (...args: any[]) => any) {\n    return this.isNothing() ? Monad.of(null) : Monad.of(fn(this.identity()));\n  }\n  static of<U>(value: U) {\n    return new Monad(value);\n  }\n  identity() {\n    return this.join()._value;\n  }\n}\n\nconst num = Monad.of(Monad.of(3));\nnum.map((v) => v + 1); // Monad {_value: 4}\n\n```\n\n## Applicative\n\n上面的例子都是封装数据。如果函数也是一个`functor`，就需要提供一个`apply`方法。\n\n```typescript\nclass Applicative<T> {\n  // ...\n  apply(container: Applicative<any>) {\n    return container.map(this._value)\n  }\n  // ...\n}\nconst plus3 = v => v + 3;\nApplicative.of(plus3).apply(Applicative.of(2)) // Applicative {_value: 5}\n```\n\n<hr/>\n\n结合上面的所有例子，梳理一下code\n\n```typescript\nclass Monad<T> {\n  private _value: T;\n  constructor(value: T) {\n    this._value = value;\n  }\n  isNothing(): boolean {\n    return this._value === undefined || this._value === null;\n  }\n  join() {\n    if (this._value instanceof Monad) {\n      return this.isNothing() ? Monad.of(null) : this._value.join();\n    } else return this;\n  }\n  map(fn: (...args: any[]) => any) {\n    return this.isNothing() ? Monad.of(null) : Monad.of(fn(this.identity()));\n  }\n  apply(container: Monad<any>) {\n    console.log(this.identity())\n    return container.map(this.identity())\n  }\n  static of<U>(value: U) {\n    return new Monad(value);\n  }\n  private identity() {\n    return this.join()._value;\n  }\n}\n```\n\n","tags":["programing"],"categories":["Programing"]},{"title":"Webpack5","url":"/posts/46109b3a.html","content":"\n`Webpack5`正式版距`V4`发布已经过去2年了。新版做了许多API和底层的改动，这会导致一些现有的`plugin`或者`loader`无法在`V5`版本运行。\n\n先贴一下[官方文档](https://webpack.docschina.org/blog/2020-10-10-webpack-5-release/)\n\n本文梳理一些webpck所做出的比较重要的改动\n\n- 功能清除\n- new URL\n- 长期缓存\n- 持久化缓存\n- tree-shaking\n- 联邦模块\n\n## 功能清除\n\n首先，所有在`V4`标记为废弃的api都被移除。升级前先检查是否使用了被废弃的API（看控制台是否有警告）\n\n`V5`取消默认`nodejs`的`polyfill`\n在`V4`中可以使用一部分`nodejs`的API（例如:`crypto`模块）。在`V5`中不会对这些API进行`polyfill`，所以需要手动`polyfill`\n\n原因：官方认为在绝大数情况下这些`polyfill`都是不必要的，而且它增大了`bundle`的体积\n\n### Crypto\n\n当使用如下代码：\n\n```typescript\nimport CryptoJS from \"crypto-js\";\nconst md5Password = CryptoJS.MD5(\"123123\");\nconsole.log(md5Password);\n```\n\nwepack5会自动报错\n\n![node-polyfill](../../images/framework/node-polyfill.jpg)\n\n根据提示操作即可。\n\n### process\n\nnodejs的`process`模块无法直接使用。\n\n使用`process`是，webpack5会报错，提示引入`process`模块的`polyfill`。\n\n如果使用`process.env.NODE_ENV`则不会报错，因为webpack在解析过程中将其值替换成对应`mode`的值\n可以使用 `DefinePlugin` 或 `EnvironmentPlugin` 在配置中定义这些变量。\n\n### 其它模块\n\npath模块需要手动`polyfill`\nurl模块可以直接使用。\n\n## new URL\n\n### 引入资源方式\n\n`webpack5`对资源模块提供了内置支持\n\n- `V4`中使用`import img from './picture.png`，需要在`module.rules`中做相应的配置\n- `V5`中可以直接使用`new URL('./picture.png', import.meta.url)`\n\n> import.meta.url 是当前文件的 file: url(类似于__filename)\n> 使用URL会向 javascript 注入一个 DataURI\n\n### Worker\n\n由上，可以这么使用worker：`new Worker(new URL(\"./worker.js\", import.meta.url))`\n\n这样就可以更好地在webpack中使用 webWorker\n\n## 长期缓存\n\n长期缓存的目的是当应用重新打包后尽可能保持文件不变，这样浏览器就可以直接使用缓存。\n\n### name id hash\n\nwebpack最终输出的文件称为`bundle`(与`chunk`一一对应)。其文件名取决于webpack的配置，例如`filename: [name].[id].[hash]`\n\n- name 为chunk的名称，name一般取文件名或者或者开发者通过魔法注释指定\n- id 为chunkId，id是webpack自动生成的（`V4`是递增的）\n- hash 有分为三种 `hash` `chunkhash` `contenthash`\n  \n> 有时候name等于id？\n> 当开发者没有指定name时，name默认取id的值\n> 例如：当使用动态import，却没用魔法注释指定chunkName(/\\* webpackChunkName: \"home\" \\*/)\n\n### chunkId 和 moduleId 不稳定\n\n在`V4`中，`chunkId`和`moduleId`默认都是递增的：`1.js -> 2.js -> 3.js -> 4.js`\n但是当删除`2.js`后，原来的`3`就变成`2`，导致无法直接使用缓存内容，这种现象也被称为`chunkId`和`moduleId`不稳定\n\n### 如何稳定\n\n`V4`中使用外部插件解决\n\n- chunkId：可安装NamedChunksPlugin插件来稳定chunkId；或者配置`optimization.chunkIds='named'`。\n- moduleId：可安装HashedModuleIdsPlugin插件覆盖默认的moduleId规则，使用模块路径生成的hash作为moduleId。\n\n`V5`中对`moduleId`和`chunkId`的生成策略进行了优化，从而无需引入任何插件（生产模式下是默认启用的）\n\n- moduleId改为根据上下文模块路径计算\n- chunkId根据chunk内容计算\n\n配置`optimization`\n\n```typescript\nexport default {\n\n  // ...\n\n  optimization: {\n    chunkIds: 'deterministic',\n    moduleIds: 'deterministic'\n  },\n\n  //...\n\n}\n```\n\n## 持久化缓存\n\n持久化缓存是指第一次**全量构建**，利用磁盘缓存\n后续构建会 读取缓存，然后进行校验。\n\n`V4`中也有类似的手段，比如`cache-loader`。`babel-loader`也有`cacheDirectory: true`。\n\n`V5`内置了磁盘持久化缓存功能\n\n```typescript\nexport default {\n  cache: {\n     // 1. 将缓存类型设置为文件系统\n    type: 'filesystem', // 默认是memory\n    // 2. 将缓存文件夹命名为 .temp_cache,\n    // 默认路径是 node_modules/.cache/webpack\n    cacheDirectory: path.resolve(__dirname, '.temp_cache')\n  },\n};\n```\n\n## Tree-Shaking优化\n\n`V5`的tree-shaking支持了更多的场景。\n\n### 嵌套tree-shaking\n\n```javascript\n// inner.js\nexport const a = 1;\nexport const b = 2;\n\n// module.js\nexport * as inner from './inner';\n// 或 import * as inner from './inner'; export { inner };\n\n// user.js\nimport * as module from './module';\nconsole.log(module.inner.a);\n```\n\n`V5` 能将b给tree-shaking掉。\n\n### 内部tree-shaking\n\n```javascript\nimport { something } from './something';\n\nfunction usingSomething() {\n  return something;\n}\n\nexport function test() {\n  return usingSomething();\n}\n```\n\n当设置`\"sideEffects\": false`时并且 `test` 导出未被使用时，不但会删除`test`也会删除`something`。\n\n### Commonjs tree-shaking\n\n`V5`现在支持`CommonJS`模块的tree-shaking\n\n## 联邦模块（Module Federation）\n\n### 概述\n\n联邦模块应该是`V5`中较为亮眼的更新。联邦模块是为了解决应用间模块共享的问题。\n\n换句话说，现在有A、B两个应用。A应用中写了一个工具库，现在B应用也想用。怎么办？\n首先把工具库抽离出来\n\n- 发布到npm。应用install来使用\n- 或者打包成UMD，通过CDN类似方式使用\n\n但是这种方式就会有版本问题，A，B应用使用的版本可能不一致。\n\n联邦模块如何做的呢？\n\n联邦模块可以让B应用直接使用A应用的工具库。\n\n### 使用\n\n场景：两个应用：`app1`和`app2`。后者需要使用前者`utils.ts`\n\napp1配置如下：\n\n```typescript\nimport { ModuleFederationPlugin } from \"webpack\"\n\nexport default {\n  // other webpack configs...\n  plugins: [\n    new ModuleFederationPlugin({\n      // name 当前应用名称，不能与其它应用冲突\n      name: \"app1\",\n      // UMD标准导出，和name保持一致即可\n      library: { type: \"var\", name: \"app_two\" },\n      // 远程应用时被其他应用引入的js文件名称\n      filename: \"remoteEntry.js\",\n      // exposes 表示导出的模块，只有在此申明的模块才可以作为远程依赖被使用\n      exposes: {\n        utils: \"./src/libs/utils.ts\"\n      },\n      // shared可以让远程加载的模块对应依赖改为使用本地项目的 React或ReactDOM。\n      shared: [\"vue\", \"vue-router\", \"vuex\"]\n    }),\n    new HtmlWebpackPlugin({\n      template: \"./public/index.html\",\n      chunks: [\"main\"]\n    })\n  ]\n};\n```\n\napp2配置如下：\n\n```typescript\nimport { ModuleFederationPlugin } from \"webpack\"\n\nexport default {\n  // other webpack configs...\n  plugins: [\n    new ModuleFederationPlugin({\n      name: \"app2\",\n      // remotes 可以将其他项目的 name 映射到当前项目中\n      remotes: {\n        app1: \"app1\",\n      },\n      shared: [\"vue\", \"vue-router\", \"vuex\"]\n    }),\n    new HtmlWebpackPlugin({\n      template: \"./public/index.html\",\n      chunks: [\"main\"]\n    })\n  ]\n};\n```\n\n在app2中引入模块\n\n```html\n<head>\n  <!-- remoteEntry.js 是 filename字段的值 -->\n  <script src=\"http://localhost:3001/remoteEntry.js\"></script>\n</head>\n```\n\n在app2中使用\n\n```typescript\nimport utils from 'app1/utils'\n```\n\n`import` 的内容是**远程应用名/暴露的模块名**，对应webpack配置里面的name和expose\n\n### 玩法\n\n#### 微前端\n\n联邦模块不仅支持导出应用的某个模块，也支持expose整个应用（expose entry）\n\n对于 主从应用（一个主应用 + 多个子/微应用）这种微前端架构\n\n微应用暴露自己，主应用管理路由并使用微应用\n\n公共模块写在主应用中并暴露出来，微应用再使用\n\n#### 公共组件服务\n\n如果团队内部有组件库或工具库。现在不用发布到npm上。可以单独部署一个 **公共组件服务**。\n\n![common_component_structure](../../images/framework/common_component_structure.jpg)","tags":["javascript","webpack","架构"],"categories":["Webpack"]},{"title":"HTTP首部","url":"/posts/8b77beaa.html","content":"\nhttp首部分为四部分——**请求行/状态行**、**请求/响应首部字段**、**通用首部字段**、**实体首部字段**组成。\n\n梳理一下当作字典，以便日后查阅。\n\n## 首部一览\n\nHTTP/1.1 规范定义了如下 47 种首部字段。\n\n| 首部字段名      | 说明                               |\n| --------------- | ---------------------------------- |\n| `Cache-Control` | （强）缓存控制，1.0还有个`Expired` |\n| `Connection`    |                                    |\n\n## 通用首部字段\n\n通用首部字段是指，请求报文和响应报文双方都会使用的首部。\n\n### Cache-Control\n\n场景：浏览器第一次请求服务器时，服务端返回资源并再**response header**加上`Cache-Control: max-age=56700000`。浏览器接受资源并把资源和相关头信息缓存下来。当第二次请求改资源时，先从缓存中找，计算第一次请求的时间和`max-age`来判断是否过期。若没过期则取缓存内容，若过期再向服务器请求。\n\n这个字段既可以出现在请求头中也可以出现在响应头中，但参数不太一样\n\n#### 请求头参数\n\n| 指令              | 参数 | 说明                                                        |\n| ----------------- | ---- | ----------------------------------------------------------- |\n| `no-cache`        | 无   | 不使用强缓存，强制向源服务器再次验证（使用协商缓存）        |\n| `no-store`        | 无   | 不使用缓存                                                  |\n| `max-age=[ 秒]`   | 秒   | 缓存的时间                                                  |\n| `max-stale=[ 秒]` | 秒   | 可省略，可容忍的最大过期时间, 接受age+stale时间内的缓存数据 |\n| `min-fresh=[ 秒]` | 秒   | `min-fresh=60`要求（缓存）服务器返回缓存时间未过60s的资源   |\n| `no-transform`    | 无   | 缓存不能改变实体主体的媒体类型                              |\n| `only-if-cached`  | 无   | 完全使用缓存，若未命中返回`504 Gateway Timeout`             |\n| `cache-extension` | 无   | 新指令标记（token）                                         |\n\n`cache-extension` token可以扩展`Cache-Control`首部字段内的指令\n例如：`Cache-Control: private, community=\"UCI\"`\n其中`community`属于扩展指令\n\n#### 响应头参数\n\n| 指令               | 参数 | 说明                                           |\n| ------------------ | ---- | ---------------------------------------------- |\n| `public`           | 无   | 可以被任意方缓存                               |\n| `private`          | 无   | 仅可被特定用户缓存                             |\n| `no-cache`         | 无   | 可省略，使用缓存前先向服务端验证有效性（协商） |\n| `no-store`         | 无   | 不缓存请求和响应内容                           |\n| `no-transform`     | 无   | 缓存不能改变实体主体的媒体类型                 |\n| `must-revalidate`  | 无   | 可缓存但必须再向源服务器进行确认               |\n| `proxy-revalidate` | 无   | 要求中间缓存服务器对缓存的响应有效性再进行确认 |\n| `max-age=[ 秒]`    | 秒   | 缓存的时间                                     |\n| `s-maxage=[ 秒]`   | 秒   | **公共缓存服务器**响应的最大Age值              |\n| `cache-extension`  | 无   | 新指令标记（token）                            |\n\n### Connection\n\n`Connection`首部字段有两个作用\n\n1. 控制不再转发给代理的首部字段\n2. 管理持久化连接\n\n#### 控制不再转发给代理的首部字段\n\n使用方式：再请求头加上`Connection: 不再转发的首部字段名`\n当请求发送给代理服务器时，代理服务器会剔除指定首部字段，然后再转发给源服务器\n\n#### 持久化连接\n\n`HTTP/1.1`默认全部都是持久化连接，当服务端想断开连接时，在响应头中指定字段`Connection: close`\n\n`HTTP/1.0`默认是非持久化连接。若想建立持久化连接，请求双方都要在头信息中加上`Connection: Keep-Alive`\n\n### Date\n\n`Date`表示创建HTTP报文的日期和时间，格式如：`Date: Tue, 03 Jul 2012 04:40:59 GMT`\n\n### Pragma\n\n`Pragma: no-cache`与`Cache-Control: no-cache`作用相同。是为了兼容`HTTP/1.0`而存在的\n\n### Trailer\n\n响应首部。`Trailer`字段指明在报文主体后记录了哪些首部字段，允许发送方在分块发送的消息后面添加额外的元信息\n使用：`Trailer: Expires`\n\n### Transfer-Encoding\n\n指定报文主体的传输编码，HTTP/1.1 的传输编码方式仅对分块传输编码有效。\n使用：`Transfer-Encoding: chunk`\n\n### Upgrade\n\n用于检测能否升级通信协议，其参数值可以用来指定一个完全不同的通信协议。\n使用：\n\n```text\nUpgrade: TLS/1.0, HTTP/1.1\nConnection: Upgrade\n```\n\n通常配合`Connection`使用，因为`Upgrade`字段不需要转发\n\n### Via\n\n用于追踪客户端和服务端之间的请求和响应报文的传输路径\n\n![via_header](../../images/图解HTTP/via_header.png)\n\n### Warning\n\n返回与缓存相关的警告，\n例如：`Warning: 113 gw.hackr.jp:8080 \"Heuristic expiration\" Tue, 03`\n格式：`Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])`\n\n## 请求首部字段\n\n请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。\n\n### Accept\n\n告知服务器，客户端所期望的媒体类型或媒体类型优先顺序，用q表示权重（取0~1，默认1）\n使用：`Accept: text/html,application/xhtml+xml,application/xml;q=0.9`\n\n常见媒体类型:\n\n1. 文本文件\n   - `text/html`、`text/plain`、`text/css`\n   - `application/xhtml+xml`、`application/xml`\n2. 图片文件\n   - `image/jpeg`、`image/gif`、`image/png`\n3. 视频文件\n   - `video/mpeg`、`video/quicktime`\n4. 应用程序使用的二进制文件\n   - `application/octet-stream`、`application/zip`\n\n### Accept-Charset\n\n告知服务器，客户端所期望的字符集或字符集的优先顺序，也可以用q来表示权重\n使用：`Accept-Charset: iso-8859-5, unicode-1-1;q=0.8`\n\n### Accept-Encoding\n\n告知服务器，客户端所期望的内容编码或内容编码优先级顺序\n使用: `Accept-Encoding: gzip, deflate`\n\n常见编码方式：\n\n- gzip\n由文件压缩程序 gzip（GNU zip）生成的编码格式（RFC1952），采用 Lempel-Ziv 算法（LZ77）及 32 位循环冗余校验（Cyclic Redundancy Check，通称 CRC）。\n- compress\n由 UNIX 文件压缩程序 compress 生成的编码格式，采用 Lempel-Ziv-Welch 算法（LZW）。\n- deflate\n组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法（RFC1951）生成的编码格式。\n- identity\n不执行压缩或不会变化的默认编码格式\n\n采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。另外，也可使用星号（*）作为通配符，指定任意的编码格式。\n\n### Accept-Language\n\n告知服务器客户端所期望的自然语言集（指中文或英文等），以及自然语言集的相对优先级。\n\n使用：`Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3`\n\n### Authorization\n\n告知服务器客户端的认证信息。\n当客户端未携带认证信息，服务端会返回**401 Unauthorized**\n使用：`Authorization: Basic dWVub3NlbjpwYXNzd29yZA==`\n\n### Expect\n\n发送一个POST请求，请求头携带`Expect: 100-continue`，会先去询问Server是否愿意接受数据\n接收到Server返回的`100-continue`应答以后，才能把数据POST给Server\n\n### From\n\n该字段用来记录用户的电子邮件地址，使用：`From: yourname@outlook.com`\n\n### Host（重要概念）\n\n先明确**虚拟主机的概念**——一台服务器对应一个公网IP地址，一个IP又可以对应多个域名，那么如何通过不同域名访问对应服务器上不同的站点呢？答案是，将服务器划分成多个虚拟主机，在请求头上加上`Host`字段指定对应虚拟主机名称，这样就能访问到对应的站点\n\n> `nginx` 划分虚拟主机很简单，直接设置不同的`server_name`即可\n\n### If-Match\n\n形如`If-*`的字段称之为条件请求，只有判断指定条件为真时，才会执行请求。\n\n客户端发送请求，携带`If-Match: \"123456\"`。服务端为实体资源生成实体标记`ETag`，然后判断`If-Match`和`ETag`的值。若相同，则返回实体资源；若不同，则返回**412 Precondition Failed**\n\n> If-match的取值还可以时`*`，表示让服务端忽略`ETag`\n\n### If-Modified-Since\n\n这个请求头与**协商缓存**有关\n\n- 客户端第一次发送请求。服务端收到请求后，返回实体资源并加上响应头`Last-Modified`其值为该资源最后一次修改时间。客户端收到响应后缓存该资源和`Last-Modified`\n- 客户端第二次发送请求，在请求头上携带`If-Modified-Since`，其值为上一次服务端返回的`Last-Modified`值。当服务端收到请求后，检查对应实体资源最新的`Last-Modified`并与`If-Modified-Since`对比判断是否过期。若未过期，则返回**304 Not Modified**表示客户端可以使用缓存；若过期，返回新的实体资源和`Last-Modified`\n\n### If-None-Match\n\n这个字段与`If-Match`作用相反\n\n待续...\n\n## 响应首部字段\n\n响应首部字段是服务器返回给客户端的响应报文中所使用的字段\n\n### Accept-Ranges\n\n用来告知客户端能否处理范围请求\n\n- Accept-Ranges: bytes  支持\n- Accept-Ranges: none   不支持\n\n### Age\n\n告知客户端，源服务器在多久前创建了响应\n\n`Age: 600` 单位：s\n\n### ETag\n\nETag是响应资源的唯一性标识，当资源改变，ETag也会变化\n\n- 强ETag：不论实体发生多么细微的变化都会改变其值 `ETag: \"usagi-1234\"`\n- 弱ETag：只有资源发生了根本改变，产生差异时才会改变 ETag 值 `ETag: W/\"usagi-1234\"`\n\n### Location\n\n`Location: http://www.usagidesign.jp/sample.html`\n\n引导客户端去指定位置请求资源，配合 3XX: Redirection\n\n### Proxy-Authenticate\n\n`Proxy-Authenticate: Basic realm=\"Usagidesign Auth\"`\n\n没搞懂\n\n### Retry-After\n\n`Retry-After: 120`，单位s，也可以是具体时间\n\n告知客户端，在多久后再次发送请求。配合 `503 Service Unavailable`或`3xx Redirect`使用\n\n### Server\n\n告知客户端，服务器上安装的HTTP服务器应用程序的信息。\n\n- `Server: Apache/2.2.17 (Unix)`\n- `Server: Apache/2.2.6 (Unix) PHP/5.2.5`\n\n### Vary\n\n","tags":["NetWork","HTTP Header"],"categories":["NetWork"]},{"title":"HTTP梳理","url":"/posts/3b531846.html","content":"## HTTP工作模型\n\n一次HTTP请求涉及到两个角色——**客户端**和**服务端**。\n\n1. 客户端发送请求（报文）\n2. 服务端收到请求开始处理\n3. 然后把响应（报文）发送回客户端\n\n![http工作模型](../../images/图解HTTP/http工作模型.jpg)\n\n## 持久化连接和管线化\n\n### 持久化连接\n\n传输层的`TCP`协议，规定通信双方必须**先建立连接**再通信。\n\n在`HTTP`的初始版本，每进行一次HTTP通信就要断开一次TCP，多个HTTP请求不能复用一个TCP连接\n\n在`HTTP1.1`中，默认开启持久化连接，是多个HTTP请求可以复用同一个TCP连接。只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。\n\n![持久化连接](../../images/图解HTTP/持久化连接.jpg)\n\n### 管线化\n\n持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。\n\n## 无状态和Cookie\n\n### 无状态协议\n\n`HTTP`协议自身不具备保存之前发送过的请求或响应的功能\n每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。\n\n但是无状态也会导致新的问题——用户登陆状态如何保存？\n\n于是引入了`Cookie`\n\n### Cookie\n\n`Cookie` 是通过在请求和响应报文中写入 `Cookie` 信息来控制客户端的状态。\n\n1. 客户端发送请求报文\n2. 服务端收到请求，处理。在响应报文中添加一个`Set-Cookie`的首部字段\n3. 客户端收到响应，取出`Set-Cookie`的信息\n4. 客户端以后发送的请求，在请求报文首部加上`Cookie`。这样服务端就能识别客户端了。\n\n## HTTP 报文\n\n用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的HTTP 报文叫做**请求报文**，响应端（服务器端）的叫做**响应报文**。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的**字符串文本**。\n\nHTTP报文由**报文首部（header）**和**报文主体（body）**构成，两者以**空行（CR+LF）**分隔\n\n> 报文：是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。\n\n## 提升传输速率\n\n### 压缩\n\n**内容编码**保持实体信息原样压缩，内容编码后的实体由客户端接收并负责解码。\n\n常用的内容编码有以下几种。\n- gzip（GNU zip）\n- compress（UNIX 系统的标准压缩）\n- deflate（zlib）\n- identity（不进行编码）\n\n### 分块\n\n**分块传输编码**会将实体主体分成多个部分（块）。\n使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。\n\n## 多部分对象集合\n\n`HTTP`协议发送的报文主体可以包含多个类型实体。\n多部分对象集合包含的对象如下：\n\n- multipart/form-data: `Content-Type: multipart/form-data; boundary=AaB03x`\n- multipart/byteranges: `Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES`\n\n`Content-Type`定义资源类型\n`boundary`定义不同类型实体之间的分隔符\n\n## 范围请求\n\n指定范围发送的请求叫做**范围请求**\nbyte 范围的指定形式如下。\n- 5001~10 000 字节：`Range: bytes=5001-10000`\n- 从 5001 字节之后全部的: `Range: bytes=5001-`\n- 从一开始到 3000 字节和 5000~7000 字节的多重范围: `Range: bytes=-3000, 5000-7000`\n\n针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。\n\n## 内容协商\n\n内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。\n\n比如说，客户端浏览器是英文的，服务器返回的网页也会是英文的。\n\n相关首部字段如下：\n- `Accept`\n- `Accept-Charset`\n- `Accept-Encoding`\n- `Accept-Language`\n- `Content-Language`\n\n## HTTP状态码\n\n|     | 类别                           | 说明                       |\n| --- | ------------------------------ | -------------------------- |\n| 1XX | Informational(信息性状态码)    | 接收到的请求正在处理       |\n| 2XX | Success(成功状态吗)            | 请求正常处理完毕           |\n| 3XX | Redirection(重定向状态吗)      | 需要进行附加操作已完成请求 |\n| 4XX | Client Error(客户端错误状态码) | 服务器无法处理请求         |\n| 5XX | Server Error(服务器错误状态吗) | 服务器处理请求出错         |\n\n### 2XX\n\n#### 200 OK\n\n表示客户端发来的请求在服务端被正常处理了\n\n#### 204 No Content\n\n请求处理成功，但是没有资源课返回\n\n#### 206 Partial Content\n\n客户端进行了范围请求，服务器成功执行了这部分请求。\n响应报文中包含由 Content-Range 指定范围的实体内容。\n\n### 3XX\n\n#### 301 Moved Permanently\n\n表示所请求的资源已转移到了新的`URI`\n\n#### 302 Found\n\n临时重定向，该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。\n\n和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI 将来还有可能发生改变。\n\n#### 303 See Other\n\n该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。\n\n303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。\n\n#### 304 Not Modified\n\n服务端返回304，表示资源没有改动。浏览器可以从本地缓存中读取资源。\n\n#### 307 Temporary Redirect\n\n临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。\n307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。\n\n### 4XX\n\n#### 400 Bad Request\n\n表示请求报文存在错误\n\n#### 401 Unauthorized\n\n没有通过HTTP认证，当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。\n\n#### 403 Forbidden\n\n该状态码表明对请求资源的访问被服务器拒绝了\n\n#### 404 Not Found\n\n所请求的资源不存在。\n\n### 5XX\n\n#### 500 Internal Server Error\n\n该状态码表明服务器端在执行请求时发生了错误\n\n#### 503 Service Unavailable\n\n该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。\n如果事先得知解除以上状况需要的时间，最好写入RetryAfter 首部字段再返回给客户端。\n","tags":["NetWork","HTTP"],"categories":["NetWork"]},{"title":"Web网络基础","url":"/posts/4e5b3a92.html","content":"\n## TCP/IP\n\n`TCP/IP`是互联网相关的各类协议族的总称\n`TCP/IP`具有分层结构，分为：应用层、传输层、网络层和数据链路层\n\n### 应用层\n\n应用层决定了向用户提供应用服务时通信的活动。\n相关协议：`FTP`、`DNS`以及`HTTP`\n\n### 传输层\n\n传输层提供处于网络连接中的两台计算机之间的数据传输\n相关协议：`TCP`和`UDP`\n\n### 网络层\n\n网络层规定了数据包通过怎样的传输线路到达对方计算机\n相关协议：`IP`\n\n### 数据链路层\n\n数据链路是用来处理连接网络的**硬件部分**\n例如：`NIC(网卡)`、`光纤`等物理可见部分\n\n### 通信传输流\n\n![TCPIP分层](../../images/图解HTTP/TCPIP分层.png)\n\n发送端再每一层都会打上包含该层所属的一个首部。当接收端接收到数据时，会依次拆开首部。\n\n## 与HTTP有关的协议\n\n### IP\n\n**网际协议(Internet Protocol, IP)**位于网络层，其作用是把数据包传送给对方。具体如何规定传送呢？\n\n每个网络节点都有一个**IP地址**，每一台计算机的网卡都有一个固定的**MAC地址**。\nIP地址又可以通过`ARP协议`转换成MAC地址\n\n数据包发送过程如下：\n\n1. 网关（一般为路由器）的 IP 地址被 ARP 协议解析为 MAC 地址。根据该 MAC 地址，源主机将数据包发送到网关。\n2. 网关根据数据包中的网段 ID 寻找目标网络。如果找到，将数据包发送到目标网段；如果没找到，重复步骤（1）将数据包发送到上一级网关。\n3. 数据包经过网关被发送到正确的网段中。目标IP地址被ARP协议解析为 MAC 地址。根据该 MAC 地址，数据包被发送给目标地址的主机。\n\n### TCP\n\n**传输控制协议( Transport Control Protocol, TCP)**位于传输层，提供可靠的**字节流服务**即将大块数据分割成报文段为单位的数据包进行管理。\n\n三次握手\n\n发送端首先发送一个带`SYN`标志的数据包给对方。接收端收到后，会回传一个带有`SYN/ACK`标志的数据包以表示传达确认信息。最后，发送端再发送一个带有`ACK`标志的数据包，代表“握手”结束\n\n### DNS\n\n**域名解析服务(Domain Name System, DNS)**位于应用层，提供通过域名查找IP地址，或者逆向从IP地址查找域名的服务\n\n## HTTP协议与其它协议的关系\n\n![数据请求与协议](../../images/图解HTTP/数据请求与协议.png)\n\n## URL与URI\n\n### 区别\n\n统一资源标识符（Uniform Resource Identifier, URI）\n统一资源定位符（Uniform Resource Locator， URL）\n统一资源名称（Uniform Resource Name， URN）\n\n`URL`和`URN`都是`URI`的子集。比如说人们的身份证号码就是`URN`（能够唯一标识），一个网站`http://zxffan.github.io/`就是`URL`。它们都属于`URI`\n\n### URI格式\n\n![URI格式](../../images/图解HTTP/URI格式.png)\n\n#### 协议方案名\n\n诸如：`HTTP`、`HTTPS`\n\n#### 登录信息\n\n可选项，指定用户名和密码\n\n#### 服务器地址\n\n服务器地址可以是域名，也可以是IP地址\n\n#### 服务器端口号\n\n可选，没有取默认端口号，不同协议有不同的默认端口号。\n`HTTP`是`80`；`HTTPS`是`443`\n\n#### 带层次的文件路径\n\n指定服务器上的**文件路径**来定位特指的资源\n\n#### 查询字符串\n\n可选，使用查询字符串向指定资源传入任意参数\n\n#### 片段标识符\n\n可选，标记已获取资源的子资源","tags":["NetWork","HTTP","TCP/IP"],"categories":["NetWork"]},{"title":"CSS Review","url":"/posts/6e1418c.html","content":"\n## 浏览器渲染\n\n浏览器解析一个页面会按照以下流程：\n\n1. 根据`HTML`构建`DOM Tree`\n2. 根据`CSS`构建`CSSOM Tree`\n3. `DOM Tree`和`CSSOM Tree`合并生成`Render Tree`\n4. 布局：计算元素的大小及位置\n5. 绘制：将`Render Tree`中的每个节点转换成屏幕上的实际像素\n   \n### 如何从`HTML`到`DOM Tree`？\n\n读取HTML文档的字节(Bytes)\n将字节转换成字符(Chars)\n依据字符确定标签(Tokens)\n将标签转换成节点(Nodes)\n以节点为基准构建DOM树。\n\n### 如何从`CSS`到`CSSOM Tree`？\n\n与DOM树的构建过程类似。\n\n### 阻塞渲染\n\n在生成`Dom Tree`的过程中，`script`标签会阻塞渲染线程工作。此时，控制权交给了**JS引擎线程**， JavaScript脚本执行完成之后再交由渲染引擎继续解析。\n\n为什么要阻塞？\n`JS`是能够操作DOM的。`JS`开始工作后并不确定DOM的结构（因为会变），所以暂停渲染线程工作。\n\n### 回流和重绘\n\n#### 回流\n\n回流（重排）是指当DOM节点的**几何属性**（位置、大小等）发生改变后，渲染线程需要重新计算位置和形状的现象。\n换句话说，就是DOM节点的变化导致文档流变化。\n\n#### 重绘\n\n重绘是指当DOM节点的**外观属性**（颜色、透明度、文字等），渲染线程需要重新绘制的现象。\n换句话说，就是DOM节点的变化不会导致文档流变化。\n回流一定导致重绘，重绘不一定导致回流。\n尽可能的避免回流的发生。当需要改变元素位置时，使用`transform`代替`top bottom left right`。前者只会引发图层重绘，还会间接启动GPU加速。\n\n## 习惯：CSS属性排序书写\n\n比较好的书写顺序是按照类型排序。\n\n按照`布局` → `尺寸` → `界面` → `文字` → `交互`的方式顺序书写CSS属性\n\n### 布局属性\n\n-  显示：`display` `visibility`\n-  溢出：`overflow` `overflow-x` `overflow-y`\n-  浮动：`float` `clear`\n-  定位：`position` `left` `right` `top` `bottom` `z-index`\n-  列表：`list-style` `list-style-type` `list-style-position` `list-style-image`\n-  表格：`table-layout` `border-collapse` `border-spacing` `caption-side` `empty-cells`\n-  弹性：`flex-flow` `flex-direction` `flex-wrap` `justify-content` `align-content` `align-items` `align-self` `flex` `flex-grow` `flex-shrink` `flex-basis` `order`\n-  多列：`columns` `column-width` `column-count` `column-gap` `column-rule` `column-rule-width` `column-rule-style` `column-rule-color` `column-span` `column-fill` `column-break-before` `column-break-after` `column-break-inside`\n-  格栅：`grid-columns` `grid-rows`\n\n### 尺寸属性\n\n-  模型：`box-sizing`\n-  边距：`margin` `margin-left` `margin-right` `margin-top` `margin-bottom`\n-  填充：`padding` `padding-left` `padding-right` `padding-top` `padding-bottom`\n-  边框：`border` `border-width` `border-style` `border-color` `border-colors` `border-[direction]-<param>`\n-  圆角：`border-radius` `border-top-left-radius` `border-top-right-radius` `border-bottom-left-radius` `border-bottom-right-radius`\n-  框图：`border-image` `border-image-source` `border-image-slice` `border-image-width` `border-image-outset` `border-image-repeat`\n-  大小：`width` `min-width` `max-width` `height` `min-height` `max-height`\n\n### 界面属性\n\n-  外观：`appearance`\n-  轮廓：`outline` `outline-width` `outline-style` `outline-color` `outline-offset` `outline-radius` `outline-radius-[direction]`\n-  背景：`background` `background-color` `background-image` `background-repeat` `background-repeat-x` `background-repeat-y` `background-position` `background-position-x` `background-position-y` `background-size` `background-origin` `background-clip` `background-attachment` `bakground-composite`\n-  遮罩：`mask` `mask-mode` `mask-image` `mask-repeat` `mask-repeat-x` `mask-repeat-y` `mask-position` `mask-position-x` `mask-position-y` `mask-size` `mask-origin` `mask-clip` `mask-attachment` `mask-composite` `mask-box-image` `mask-box-image-source` `mask-box-image-width` `mask-box-image-outset` `mask-box-image-repeat` `mask-box-image-slice`\n-  滤镜：`box-shadow` `box-reflect` `filter` `mix-blend-mode` `opacity`,\n-  裁剪：`object-fit` `clip`\n-  事件：`resize` `zoom` `cursor` `pointer-events` `touch-callout` `user-modify` `user-focus` `user-input` `user-select` `user-drag`\n\n### 文字属性\n\n-  模式：`line-height` `line-clamp` `vertical-align` `direction` `unicode-bidi` `writing-mode` `ime-mode`\n-  文本：`text-overflow` `text-decoration` `text-decoration-line` `text-decoration-style` `text-decoration-color` `text-decoration-skip` `text-underline-position` `text-align` `text-align-last` `text-justify` `text-indent` `text-stroke` `text-stroke-width` `text-stroke-color` `text-shadow` `text-transform` `text-size-adjust`\n-  字体：`src` `font` `font-family` `font-style` `font-stretch` `font-weight` `font-variant` `font-size` `font-size-adjust` `color`\n-  内容：`overflow-wrap` `word-wrap` `word-break` `word-spacing` `letter-spacing` `white-space` `caret-color` `tab-size` `content` `counter-increment` `counter-reset` `quotes` `page` `page-break-before` `page-break-after` `page-break-inside`\n\n### 交互属性\n\n-  模式：`will-change` `perspective` `perspective-origin` `backface-visibility`\n-  变换：`transform` `transform-origin` `transform-style`\n-  过渡：`transition` `transition-property` `transition-duration` `transition-timing-function` `transition-delay`\n-  动画：`animation` `animation-name` `animation-duration` `animation-timing-function` `animation-delay` `animation-iteration-count` `animation-direction` `animation-play-state` `animation-fill-mode`\n\n## 盒模型\n\n老生常谈——盒模型\n\n### 盒模型\n\n标准盒模型 （`box-sizing`为`content-box`）\n怪异（IE）盒模型（`box-sizing`为`border-box`）\n\n![标准盒模型和怪异盒模型](../../images/标准盒模型和怪异盒模型.png)\n\n### 视觉格式化模型\n\n块级元素：`display`声明为`block`、`list-item`、`table`、`flex`或`grid`时\n行内元素：`display`声明为`inline`、`inline-block`、`inline-table`、`inline-flex`或`inline-grid`时\n\n### 格式化上下文\n\n| 上下文           | 缩写  | 版本 | 说明         |\n| ---------------- | ----- | ---- | ------------ |\n| 块格式化上下文   | `BFC` | 2    | 块级盒子容器 |\n| 行内格式化上下文 | `IFC` | 2    | 行内盒子容器 |\n| 弹性格式化上下文 | `FFC` | 3    | 弹性盒子容器 |\n| 格栅格式化上下文 | `GFC` | 3    | 格栅盒子容器 |\n\n`BFC`——块级格式上下文通常由一个父元素和若干子元素组成。\n同一个BFC的子元素以及相邻的父子元素会发生**margin重叠**现象，不同BFC的元素不会发生重叠。\nBFC可以自动撑开元素（包含浮动元素）\n\n## 属性优先级\n\n!important： `10000`\n内联样式、外联样式：`1000`\nID选择器：`100`\n类选择器、伪类选择器、属性选择器：`10`\n元素选择器、伪元素选择器：`1`\n通配选择器、后代选择器、兄弟选择器：`0`\n\n## 布局\n\n### 普通布局\n\n符合默认布局规则。块级元素占满一行。不够一行自动换行\n\n### 浮动布局\n\n使用`float: left | right`使元素浮动（会脱离正常文档流）。\n\n### 定位布局\n\n使用`position: relative | absolute | fixed`设置相对/绝对定位。\n`top | left | right | bottom`设置位置\n\n### 表格布局（不要使用）\n\n使用`table`特性来布局\n很小的改动就会导致`table`发生回流。\n\n### 弹性布局\n\n使用`display: flex | inline-flex`设置弹性盒子容器\n\n### 多列布局\n\n使用`column-width`和`column-count`来设置列宽和列数（兼容IE10）\n可以使用`columns: column-width column-count`简写形式\n\n`column-rule`属性规定了列与列之间的直线\n`column-rule: column-rule-width column-rule-style column-rule-color`与`border`属性类似\n\n`column-span: none | all`，`all`表示跨越所有列。\n\n### 栅格布局\n\n使用`display: grid | inline-grid`来设置栅格容器\n\n### 响应式布局\n\n使用响应式单位：`vw`、`vh`、`rem`等\n使用媒体查询\n\n```css\n@media screen and (max-width: 300px) {\n    body {\n        background-color: red;\n    }\n}\n```\n\n## 内置函数Function\n\n### 颜色函数\n\n`rgb()`：RGB颜色函数，**红绿蓝**\n`rgba()`：RGBA颜色函数，**A：透明度**\n\n`hsl()`：HSL颜色函数。\nH：色相（0-360deg），`0deg`和`360deg`为红色，`120deg`为绿色，`240deg`为蓝色。\nS：饱和度（0-100%），`0%`为灰色，`100%`为全色。\nL：亮度（0-100%），`0%`为最暗，`100%`为最亮。\n\n`hsla()`：HSLA颜色函数\n\n### 属性函数\n\n`attr`：获取节点属性，目前只能配合伪元素的`content`属性使用\n`var`：获取变量\n\n```css\n--font-color: red;\n\n.warn-tip {\n    font-color: var(--font-color);\n}\n```\n\n### 数学函数\n\n`min()`：最小值\n`max()`：最大值\n\n`clamp()`：计算区间范围\n`clamp(MIN, VAL, MAX)`，最小值、首选值、最大值。相当于`max`(MIN, `min`(VAL, MAX))\n\n`calc()`：计算。`数值`、`长度`、`角度`、`时间`和`百分比`都能作为参数\n\n`counter()/counters()`：计数器，只能用于伪元素的`content`属性。\n需要结合`counter-reset`和`counter-increment`两个属性使用\n\n- `counter-reset`：重置计数器名称与初始值，编写形式为`counter-reset:name val`\n- `counter-increment`：对指定计数器累计其计数值，编写形式为`counter-increment:name`，在使用到的地方声明就会累加\n\n```css\ncounter-reset: times 1; /* 初始化times */\n\ncounter-increment: times 1; /* time 加1 */\n\n.count::after {\n    content: counter(times);\n}\n```\n\n### 背景函数\n\n`url()`：图像路径\n`element()`（only Firfox）：可以将网站中的某部分当作图片渲染，返回一个图像。结合background等属性使用\n` image-set()`：图像集合，根据屏幕分辨率匹配合适图像\n渐变：\n\n- `linear-gradient()`：线性渐变\n- `radial-gradient()`：径向渐变\n- `conic-gradient()`：锥形渐变\n- `repeat-linear-gradient()`\n- `repeat-radial-gradient()`\n- `repeat-conic-gradient()`\n\n### 滤镜函数\n\n结合`filter`属性使用\n\n`blur(100)`：模糊，具体值默认0\n`brightness(%)`：亮度\n`contrast(%)`：对比度\n`drop-shadow(h-shadow v-shadow blur spread color)`：阴影\n`grayscale(%)`：灰度\n`hue-rotate(deg)`：色相旋转\n`invert(%)`：反转\n`opacity(%)`：透明度\n`saturate(%)`：饱和度\n`sepia(%)`：褐色\n\n### 图形函数\n\n结合`clip-path`使用，用来裁剪区域\n\n`circle(30% at 50% 50%)`：圆形裁剪，**半径 at 圆心**\n`ellipse(20px 10px at 50% 50%)`：椭圆形裁剪，**横轴 纵轴 at 圆心**\n`inset(100px 50px)`：矩形，长宽\n`path()`：按照路径裁剪\n`polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)`：按照多边形裁剪（顺时针）\n\n### 变换函数\n\n结合`transform`属性使用\n\n`rotate(deg | turn)`\n`translate(x, y)`\n`scale(x y)`\n`skew(x, y)`\n`perspective()`：设置透视试图\n\n### 缓动函数\n\n`cubic-bezier()`：贝塞尔曲线\n`steps()`：逐帧\n\n## 变量Variable\n\n`CSS`有自己的一套变量系统。兼容性如下：\n\n![css var](../../images/css var.jpg)\n\n### 认识\n\n- 声明：`--变量名`\n- 读取：`var(--变量名, 默认值)`\n- 类型\n  - 普通：只能用作`属性值`不能用作`属性名`\n  - 字符：与字符串拼接 `\"Hello, \"var(--name)`\n  - 数值：使用`calc()`与数值单位连用 `var(--width) * 10px`\n- 作用域\n  - 范围：在`当前节点块作用域`及其`子节点块作用域`下有效\n  - 优先级别：`内联样式 = 外联样式 > ID选择器 > 类选择器 = 伪类选择器 = 属性选择器 > 元素选择器 = 伪元素选择器 > 通配选择器 = 后代选择器 = 兄弟选择器`\n\n### 使用技巧\n\n#### 主题换肤\n\n```vue\n<template>\n\t<div ref=\"container\" style=\"--theme-color: white\"></div>\n\t<button @click=\"switchTheme\">换肤</button>\n</template>\t\n\n<script>\nexport default {\n    methods: {\n        switchTheme() {\n            this.$refs.container.style.setProperty(\"--theme-color\", \"red\")\n        }\n    }\n}\n</script>\n\n<style lang=\"scss\">\n    .container {\n        --bg-color: var(--theme-color);\n        background-color: var(--bg-color);\n    }\n</style>\n```\n\n可见，`css`变量可以与`JS`进行交互。`scss`的变量做不到。\n\n#### 悬浮视差\n\n```vue\n<template>\n  <div ref=\"bg\" class=\"bruce flex-ct-x\" data-title=\"悬浮视差按钮\">\n    <a\n      ref=\"btn\"\n      class=\"parallax-btn\"\n      data-name=\"妙用CSS变量，让你的CSS变得更心动\"\n      @mousemove=\"move\"\n      @mouseup=\"up\"\n      @mousedown=\"down\"\n      @mouseleave=\"leave\"\n    ></a>\n  </div>\n</template>\n\n<script>\nexport default {\n  mounted() {\n    this.bgStyle = this.$refs.bg.style;\n    this.btnRect = this.$refs.btn.getBoundingClientRect();\n  },\n  methods: {\n    down(e) {\n      this.bgStyle.setProperty(\"--tz\", \"-25px\");\n    },\n    leave(e) {\n      this.bgStyle.setProperty(\"--ty\", \"0\");\n      this.bgStyle.setProperty(\"--rx\", \"0\");\n      this.bgStyle.setProperty(\"--ry\", \"0\");\n    },\n    move(e) {\n      const dx = e.offsetX - this.btnRect.width / 2;\n      const dy = e.offsetY - this.btnRect.height / 2;\n      this.bgStyle.setProperty(\"--rx\", `${dy / -1}deg`);\n      this.bgStyle.setProperty(\"--ry\", `${dx / 10}deg`);\n    },\n    up() {\n      this.bgStyle.setProperty(\"--tz\", \"-12px\");\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.bruce {\n  transform: perspective(800px);\n  transform-style: preserve-3d;\n\n  height: 100vh;\n\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.parallax-btn {\n  position: relative;\n  width: 400px;\n  height: 50px;\n  cursor: pointer;\n  user-select: none;\n  line-height: 50px;\n  text-align: center;\n  font-size: 18px;\n  color: #fff;\n  &::before {\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: 0;\n    bottom: 0;\n    border-radius: 4px;\n    background: linear-gradient(135deg, #6e8efb, #a777e3);\n    box-shadow: 0 2px 5px rgba(#000, 0.2);\n    content: \"\";\n    will-change: transform;\n    transform: translateY(var(--ty, 0)) rotateX(var(--rx, 0))\n      rotateY(var(--ry, 0)) translateZ(var(--tz, -12px));\n    transition: box-shadow 500ms ease, transform 200ms ease;\n  }\n  &::after {\n    display: inline-block;\n    position: relative;\n    font-weight: bold;\n    content: attr(data-name);\n    will-change: transform;\n    transform: translateY(var(--ty, 0)) rotateX(var(--rx, 0))\n      rotateY(var(--ry, 0));\n    transition: transform 200ms ease;\n  }\n  &:hover::before {\n    box-shadow: 0 5px 15px rgba(#000, 0.3);\n  }\n}\n</style>\n```\n\n## 选择器Selector\n\n### 基础选择器\n\n| 选择器   | 别名       | 说明             | 版本 |\n| -------- | ---------- | ---------------- | ---- |\n| `tag`    | 标签选择器 | 指定类型的`标签` | 1    |\n| `#id`    | ID选择器   | 指定身份的`标签` | 1    |\n| `.class` | 类选择器   | 指定类名的`标签` | 1    |\n| `*`      | 通配选择器 | 所有类型的`标签` | 2    |\n\n### 层次选择器\n\n| 选择器  | 别名             | 说明                 | 版本 |\n| ------- | ---------------- | -------------------- | ---- |\n| `a b`   | `后代选择器`     | 元素的`后代元素`     | 1    |\n| `a > b` | `子代选择器`     | 元素的`子代元素`     | 2    |\n| `a + b` | `相邻同胞选择器` | 元素相邻的`同胞元素` | 2    |\n| `a ~ b` | `通用同胞选择器` | 元素后面的`同胞元素` | 3    |\n\n### 集合选择器\n\n| 选择器    | 别名         | 说明             | 版本 |\n| --------- | ------------ | ---------------- | ---- |\n| `a, b`    | `并集选择器` | 多个指定的`元素` | 1    |\n| `a.class` | `交集选择器` | 指定类名的`元素` | 1    |\n\n### 条件选择器\n\n| 选择器        | 说明                                     | 版本 |\n| ------------- | ---------------------------------------- | ---- |\n| `:lang`       | 指定标记语言的`元素`，例：`p:lang(en)`   | 2    |\n| `:dir()`      | 指定编写方向的`元素`                     | 4    |\n| `:has`        | 包含指定元素的`元素`                     | 4    |\n| `:is`         | 指定条件的`元素`                         | 4    |\n| `:not`        | 非指定条件的`元素`                       | 4    |\n| `:where`      | 指定条件的`元素`                         | 4    |\n| `:scope`      | 指定`元素`作为参考点                     | 4    |\n| `:any-link`   | 所有包含`href`的`链接元素`               | 4    |\n| `:local-link` | 所有包含`href`且属于绝对地址的`链接元素` | 4    |\n\n> 上面许多选择器，目前主流浏览器都未实现\n\n### 行为选择器\n\n| 选择器        | 说明             | 版本 |\n| ------------- | ---------------- | ---- |\n| `:active`     | 鼠标激活的`元素` | 1    |\n| `:hover`      | 鼠标悬浮的`元素` | 1    |\n| `::selection` | 鼠标选中的`元素` | 3    |\n\n### 状态选择器\n\n| 选择器               | 说明                                                         | 版本 |\n| -------------------- | ------------------------------------------------------------ | ---- |\n| `:target`            | 当前锚点的`元素`                                             | 3    |\n| `:link`              | 未访问的`链接元素`                                           | 1    |\n| `:visited`           | 已访问的`链接元素`                                           | 1    |\n| `:focus`             | 输入聚焦的`表单元素`                                         | 2    |\n| `:required`          | 输入必填的`表单元素`                                         | 3    |\n| `:valid`             | 输入合法的`表单元素`                                         | 3    |\n| `:invalid`           | 输入非法的`表单元素`                                         | 3    |\n| `:in-range`          | 输入范围以内的`表单元素`                                     | 3    |\n| `:out-of-range`      | 输入范围以外的`表单元素`                                     | 3    |\n| `:checked`           | 选项选中的`表单元素`<br />搭配`appearance`，可以自定义默认的单选、复选框 | 3    |\n| `:optional`          | 选项可选的`表单元素`，没有`required`的都是                   | 3    |\n| `:enabled`           | 事件启用的`表单元素`，与`disabled`相对应                     | 3    |\n| `:disabled`          | 事件禁用的`表单元素`                                         | 3    |\n| `:read-only`         | 只读的`表单元素`，与`read-write`相对应                       | 3    |\n| `:read-write`        | 可读可写的`表单元素`                                         | 3    |\n| `:target-within`     | 内部锚点元素处于激活状态的`元素`                             | 4    |\n| `:focus-within`      | 内部表单元素处于聚焦状态的`元素`                             | 4    |\n| `:focus-visible`     | 输入聚焦的`表单元素`                                         | 4    |\n| `:blank`             | 输入为空的`表单元素`                                         | 4    |\n| `:user-invalid`      | 输入合法的`表单元素`                                         | 4    |\n| `:indeterminate`     | 选项未定的`表单元素`                                         | 4    |\n| `:placeholder-shown` | 占位显示placeholder的`表单元素`(input)                       | 4    |\n| `:current()`         | 浏览中的`元素`                                               | 4    |\n| `:past()`            | 已浏览的`元素`                                               | 4    |\n| `:future()`          | 未浏览的`元素`                                               | 4    |\n| `:playing`           | 开始播放的`媒体元素`                                         | 4    |\n| `:paused`            | 暂停播放的`媒体元素`                                         | 4    |\n\n### 结构选择器\n\n| 选择器                 | 说明                                                      | 版本 |\n| ---------------------- | --------------------------------------------------------- | ---- |\n| `:root`                | 文档的`根元素`，即`html`<br />通常在这声明全局变量        | 3    |\n| `:empty`               | 无子元素的`元素`                                          | 3    |\n| `:first-letter`        | 元素的`首字母`                                            | 1    |\n| `:first-line`          | 元素的`首行`                                              | 1    |\n| `:nth-child(n)`        | 指定元素的父元素的第n个**子元素**                         | 3    |\n| `:nth-last-child(n)`   | 指定元素的父元素的倒数第n个子元素                         | 3    |\n| `:first-child`         | 指定元素的父元素的第一个**子元素**                        | 2    |\n| `:last-child`          | 指定元素的父元素的最后一个**子元素**                      | 3    |\n| `:only-child`          | 父元素仅有该元素的`元素`                                  | 3    |\n| `:nth-of-type(n)`      | 指定元素的父元素的第n个与指定元素相同标签的**子元素**     | 3    |\n| `:nth-last-of-type(n)` | 指定元素的父元素的倒数第n个与指定元素相同标签的**子元素** | 3    |\n| `:first-of-type`       | 指定元素的父元素的第一个与指定元素相同标签的**子元素**    | 3    |\n| `:last-of-type`        | 指定元素的父元素的最后一个与指定元素相同标签的**子元素**  | 3    |\n| `:only-of-type`        | 父元素仅有该标签的`标签`                                  | 3    |\n\n### 属性选择器\n\n| 选择器        | 说明                                           | 版本 |\n| ------------- | ---------------------------------------------- | ---- |\n| `[attr]`      | 指定属性的`元素`                               | 2    |\n| `[attr=val]`  | 属性等于指定值的`元素`                         | 2    |\n| `[attr*=val]` | 属性包含指定值的`元素`                         | 3    |\n| `[attr^=val]` | 属性以指定值开头的`元素`                       | 3    |\n| `[attr$=val]` | 属性以指定值结尾的`元素`                       | 3    |\n| `[attr~=val]` | 属性包含指定值(完整单词)的`元素`(不推荐使用)   | 2    |\n| `[attr|=val]` | 属性以指定值(完整单词)开头的`元素`(不推荐使用) | 2    |\n\n### 伪元素\n\n| 选择器     | 说明                             | 版本 |\n| ---------- | -------------------------------- | ---- |\n| `::before` | 在指定元素所有子元素前插入的内容 | 2    |\n| `::after`  | 在指定元素所有子元素后插入的内容 | 2    |\n\n## 背景Background\n\n### 所有属性\n\n`background`子属性众多，其属性取值也很多。\n\nbackground-color：颜色\n\n- `transparent`：透明(`默认`)\n- `Keyword`：颜色关键字\n- `HEX`：十六进制色彩模式\n- `RGB`或`RGBA`：RGB/A色彩模式\n- `HSL`或`HSLA`：HSL/A色彩模式\n- `Color1/Color2`：覆盖颜色，背景颜色可能是`Color1`，若背景图像无效则使用`Color2`代替`Color1`\n\nbackground-image：图像\n\n- `none`：无图像(`默认`)\n- `url()`：图像路径\n\nbackground-repeat：图像平铺方式\n\n- `repeat`：图像在水平方向和垂直方向重复(`默认`)\n- `repeat-x`：图像在水平方向重复\n- `repeat-y`：图像在垂直方向重复\n- `no-repeat`：图像仅重复一次\n- `space`：图像以相同间距平铺且填充整个节点\n- `round`：图像自动缩放直到适应且填充整个节点\n\nbackground-attachment：图像依附方式\n\n- `scroll`：图像随页面滚动而移动(`默认`)\n- `fixed`：图像不会随页面滚动而移动\n\nbackground-position：图像起始位置\n\n- `Position`：位置，可用任何长度单位，第二个位置(Y轴)不声明默认是`50%`(默认`0% 0%`)\n- `Keyword`：位置关键字`left、right、top、bottom、center`，可单双使用，第二个关键字不声明默认是`center`\n\nbackground-size：图像尺寸模式\n\n- `auto`：自动设置尺寸(`默认`)\n- `cover`：图像扩展至足够大，使其完全覆盖整个区域，图像某些部分也许无法显示在区域中\n- `contain`：图像扩展至最大尺寸，使其宽度和高度完全适应整个区域\n- `Size`：尺寸，可用任何长度单位，第二个尺寸(高)不声明默认是`auto`\n\nbackground-origin：定位区域(与background-position结合使用)\n\n- `padding-box`：图像相对填充定位(`默认`)\n- `border-box`：图像相对边框定位\n- `content-box`：图像相对内容定位\n\nbackground-clip：绘制区域\n\n- `border-box`：图像被裁剪到边框与边距的交界处(`默认`)\n- `padding-box`：图像被裁剪到填充与边框的的交界处\n- `content-box`：图像被裁剪到内容与填充的交界处\n\nbackground-blend-mode：混合模式\n\n- `normal`：正常(`默认`)\n- `color-burn`：颜色加深\n- `color-dodge`：颜色减淡\n- `color`：颜色\n- `darken`：变暗\n- `difference`：差值\n- `exclusion`：排除\n- `hard-light`：强光\n- `hue`：色相\n- `lighten`：变亮\n- `luminosity`：亮度\n- `multiply`：正片叠底\n- `overlay`：叠加\n- `saturation`：饱和度\n- `screen`：滤色\n- `soft-light`：柔光\n\n>`background`属性可以连写。\n>\n>- `background: color image repeat attachment position/size`\n>- 支持多重背景：`background-image: url($bg-4), url($bg-3);`\n\n### 背景渐变\n\n`CSS`渐变分为3种：\n\n-  **线性渐变**：沿着指定方向从起点到终点逐渐改变颜色，渐变形状是一条`直线`\n-  **径向渐变**：沿着任意方向从圆心往外面逐渐改变颜色，渐变形状是一个`圆形`或`椭圆形`\n-  **锥形渐变**：沿着顺时针方向从圆心往外面逐渐改变颜色，渐变形状是一个`圆锥体`\n\n相关属性有**6个**\n\n-  **linear-gradient()**：线性渐变\n-  **radial-gradient()**：径向渐变\n-  **conic-gradient()**：锥形渐变\n-  **repeating-linear-gradient()**：重复线性渐变\n-  **repeating-radial-gradient()**：重复径向渐变\n-  **repeating-conic-gradient()**：重复锥形渐变\n\n#### 线性渐变\n\n`background-image: linear-gradient(direction, color-stop)`\n\n- `direction`：方向\n  - `Keyword`：方向关键字`to left/right/top/bottom/top left/top right/bottom left/bottom right`(默认`to bottom`)\n  - `Angle`：角度，以顺时针方向的垂直线和渐变线的夹角计算，超出N圈则计算剩余角度\n- `color-stop`：色标\n  - `Color`：颜色，可参考`background-color`取值，在指定位置产生渐变效果所使用的颜色\n  - `Position`：位置，可参考`background-position`的`Position`取值，在指定位置产生渐变效果\n\n```css\n.elem {\n    width: 400px;\n    height: 200px;\n    background-image: linear-gradient(to bottom, #f66, #66f);\n    /* 等价于 */\n    background-image: linear-gradient(to bottom, #f66 0, #66f 100%);\n    \n    /* color start end  */\n    /* background-image: linear-gradient(to bottom, #f66 0 50%, #66f 100%); */\n}\n```\n\n`css`的角度跟直角坐标系不同，正上方为0度，类似表盘\n\n![css degree](../../images/css degree.jpg)\n\n#### 径向渐变\n\n`background-image: radial-gradient(shape size at position, color-stop)`\n\n径向渐变可以用来话饼图。\n\n- Shape：形状\n  - `ellipse`：椭圆形(`默认`)\n  - `circle`：圆形\n- Size：尺寸\n  - `farthest-corner`：从圆心到离圆心最远的角为半径(`默认`)\n  - `farthest-side`：从圆心到离圆心最远的边为半径\n  - `closest-corner`：从圆心到离圆心最近的角为半径\n  - `closest-side`：从圆心到离圆心最近的边为半径\n  - `Size`：尺寸，可用任何长度单位，宽和高必须同时声明\n- Position：位置\n  - `Keyword`：位置关键字`left、right、top、bottom、center`(默认`center`)\n  - `Position`：位置，可用任何长度单位\n- color-stop：色标\n  - `Color`：颜色，可参考`background-color`取值，在指定位置产生渐变效果所使用的颜色\n  - `Position`：位置，可参考`background-position`的`Position`取值，在指定位置产生渐变效果\n\n```css\n.elem {\n    width: 400px;\n    height: 200px;\n    background-image: radial-gradient(100px 100px, #f66, #66f);\n    /* 等价于 */\n    background-image: radial-gradient(ellipse 100px 100px at center, #f66, #66f);\n}\n```\n\n#### 锥形渐变\n\n`background-image: conic-gradient(color-stop)`\n\n**color-stop**：色标\n\n- `Color`：颜色，可参考`background-color`取值，在指定位置产生渐变效果所使用的颜色\n- `Position`：位置，可参考`background-position`的`Position`取值，在指定位置产生渐变效果\n\n```css\n.elem {\n    width: 400px;\n    height: 200px;\n    background-image: conic-gradient(#f66, #66f);\n    /* 等价于 */\n    background-image: conic-gradient(#f66 0, #66f 100%);\n}\n```\n#### 实现网格图层\n```vue\n<template>\n\t<div class=\"grid-box\"></div>\n</template>\n\n<style>\n    background-image: linear-gradient(\n        to top right,\n        #eee 25%,\n        transparent 25%,\n        transparent 75%,\n        #eee 75%,\n        #eee 100%\n    ),\n      linear-gradient(\n        to top right,\n        #eee 25%,\n        transparent 25%,\n        transparent 75%,\n        #eee 75%,\n        #eee 100%\n    );\n    background-position: 0 0, 10px 10px;\n    background-size: 20px 20px;\n</style> \n```\n\n### 遮罩\n\n遮罩或者说蒙版，就是在背景上再加一层。它可以实现诸如裁剪背景的效果。\n\n`mask`子属性比`background`子属性差不多。\n\nmask-mode：模式\n\n- `match-source`：根据图像类型采用合适的遮罩模式(`默认`)\n- `alpha`：根据图像透明度采用合适的遮罩模式\n- `luminance`：根据图像亮度采用合适的遮罩模式\n\nmask-image：图像\n\n- `none`：无图像(`默认`)\n- `url()`：图像路径\n\nmask-repeat：图像平铺方式\n\n- `repeat`：图像在水平方向和垂直方向重复(`默认`)\n- `repeat-x`：图像在水平方向重复\n- `repeat-y`：图像在垂直方向重复\n- `no-repeat`：图像仅重复一次\n- `space`：图像以相同间距平铺且填充整个节点\n- `round`：图像自动缩放直到适应且填充整个节点\n\nmask-position：图像起始位置\n\n- `Position`：位置，可用任何长度单位，第二个位置(Y轴)不声明默认是`50%`(默认`0% 0%`)\n- `Keyword`：位置关键字`left、right、top、bottom、center`，可单双使用，第二个关键字不声明默认是`center`\n\nmask-size：图像尺寸模式\n\n- `auto`：自动设置尺寸(`默认`)\n- `cover`：图像扩展至足够大，使其完全覆盖整个区域，图像某些部分也许无法显示在区域中\n- `contain`：图像扩展至最大尺寸，使其宽度和高度完全适应整个区域\n- `Size`：尺寸，可用任何长度单位，第二个尺寸(高)不声明默认是`auto`\n\nmask-origin：定位区域(与mask-position结合使用)\n\n- `padding-box`：图像相对填充定位(`默认`)\n- `border-box`：图像相对边框定位\n- `content-box`：图像相对内容定位\n\nmask-clip：绘制区域\n\n- `border-box`：图像被裁剪到边框与边距的交界处(`默认`)\n- `padding-box`：图像被裁剪到填充与边框的的交界处\n- `content-box`：图像被裁剪到内容与填充的交界处\n\nmask-composite：混合模式\n\n- `source-over`：叠加，显示遮罩图像合并处\n- `subtract`：相减，不显示遮罩图像重合处\n- `intersect`：相交，显示遮罩图像重合处\n- `exclude`：排除，显示遮罩图像合并处但不显示重合处\n\n## 阴影Shadow\n\n阴影三剑客——`box-shadow`、`text-shadow`、`drop-shadow()`\n\n- 想要盒子轮廓产生阴影效果，使用`box-shadow`\n- 想要文本轮廓产生阴影效果，使用`text-shadow`\n- 想要透明图像的非透明部分轮廓产生阴影效果，使用`fliter:drop-shadow()`\n\n三个方法参数类似：\n\n```css\nbox-shadow: offset-x offset-y blur spread color position\ntext-shadow: offset-x offset-y blur color\nfilter: drop-shadow(offset-x, offset-y, blur, color)\n```\n\n- OffsetX：水平偏移，阴影的水平位置(必选)\n  - `Offset`：偏移，可用任何长度单位，允许负值，正值向右负值向左(默认`0`)\n- OffsetY：垂直偏移，阴影的垂直位置(必选)\n  - `Offset`：偏移，可用任何长度单位，允许负值，正值向下负值向上(默认`0`)\n- Blur：模糊半径，阴影的清晰程度(虚色)\n  - `Length`：长度，可用任何长度单位，值越大边缘越模糊(默认`0`)\n- Spread：扩展距离，阴影的实体尺寸(实色)\n  - `Length`：长度，可用任何长度单位，允许负值，正值扩大负值缩小(默认`0`)\n- Color：投影颜色\n  - `transparent`：透明(`默认`)\n  - `Keyword`：颜色关键字\n  - `HEX`：十六进制色彩模式\n  - `RGB`或`RGBA`：RGB/A色彩模式\n  - `HSL`或`HSLA`：HSL/A色彩模式\n- Position：投影位置\n  - `outset`：阴影显示在外部(`默认`)\n  - `inset`：阴影显示在内部\n\n## 滤镜Filter\n\n`css`的`filter`属性提供了众多的图片处理效果。\n\nblur()：模糊\n\n- `Length`：长度，可用任何长度单位，值为`0`显示原图，值越大越模糊\n\nbrightness()：亮度\n\n- `Percentage`：百分比，可用`0~1`代替，值为`0`显示全黑，值为`100%`显示原图 \n\ncontrast()：对比度\n\n- `Percentage`：百分比，可用`0~1`代替，值为`0`显示全黑，值为`100%`显示原图 \n\ndrop-shadow()：阴影\n\n- 参考上述阴影\n\ngrayscale()：灰度\n\n- `Percentage`：百分比，可用`0~1`代替，值为`0`显示原图，值为`100%`显示全灰 \n\nhue-rotate()：色相旋转\n\n- `Angle`：角度，值为`0`显示原图，值为`0~360deg`减弱原图色彩，值超过`360deg`则相当绕N圈再计算剩余的值\n\ninvert()：反相\n\n- `Percentage`：百分比，可用`0~1`代替，值为`0`显示原图，值为`100%`完全反转原图色彩 \n\nopacity()：透明度\n\n- `Percentage`：百分比，可用`0~1`代替，值为`0`显示透明，值为`100%`显示原图 \n\nsaturate()：饱和度\n\n- `Percentage`：百分比，可用`0~1`代替，值为`0`完全不饱和原图，值为`100%`显示原图\n\nsepia()：褐色\n\n- `Percentage`：百分比，可用`0~1`代替，值为`0`显示原图，值为`100%`显示褐色\n\n> 当节点声明不为`none`的`filter`时，若其子节点有`position: absolute/fixed`的元素。它会相对于`filter`节点进行定位\n\n## 变换Transform\n\n变换分为2D和3D变换，通过`transform-style`属性来声明\n\n- **flat**：所有变换效果在平面上呈现(`默认`)\n- **preserve-3d**：所有变换效果在空间上呈现\n\n变换效果通过`transform`属性来声明：\n\ntranslate()：位移\n- **translate(x,y)**：2D位移\n- **translate3d(x,y,z)**：3D位移\n- **translateX(x)**：X轴位移，等同于`translate(x,0)`或`translate3d(x,0,0)`\n- **translateY(y)**：Y轴位移，等同于`translate(0,y)`或`translate3d(0,y,0)`\n- **translateZ(z)**：Z轴位移，等同于`translate3d(0,0,z)`\n- 描述\n  - 单位：`Length`长度，可用任何长度单位，允许负值\n  - 默认：XYZ轴不声明默认是`0`\n  - 正值：沿X轴向右位移/沿Y轴向上位移/沿Z轴向外位移\n  - 负值：沿X轴向左位移/沿Y轴向下位移/沿Z轴向内位移\n\nscale()：缩放\n- **scale(x,y)**：2D缩放\n- **scale3d(x,y,z)**：3D缩放\n- **scaleX(x)**：X轴缩放，等同于`scale(x,1)`或`scale3d(x,1,1)`\n- **scaleY(y)**：Y轴缩放，等同于`scale(1,y)`或`scale3d(1,y,1)`\n- **scaleZ(z)**：Z轴缩放，等同于`scale3d(1,1,z)`\n- 描述\n  - 单位：`Number`数值或`Percentage`百分比，允许负值\n  - 默认：XYZ轴不声明默认是`1`或`100%`\n  - 正值：`0<(x,y,z)<1`沿X轴缩小/沿Y轴缩小/沿Z轴变厚，`(x,y,z)>1`沿X轴放大/沿Y轴放大/沿Z轴变薄\n  - 负值：`-1<(x,y,z)<0`翻转沿X轴缩小/沿Y轴缩小/沿Z轴变厚，`(x,y,z)<-1`翻转沿X轴放大/沿Y轴放大/沿Z轴变薄\n\nskew()：扭曲\n- **skew(x,y)**：2D扭曲\n- **skewX(x)**：X轴扭曲，等同于`skew(x,0)`\n- **skewY(y)**：Y轴扭曲，等同于`skew(0,y)`\n- 描述\n  - 单位：`Angle`角度或`Turn`周\n  - 默认：XY轴不声明默认是`0`\n  - 正值：沿X轴向左扭曲/沿Y轴向下扭曲\n  - 负值：沿X轴向右扭曲/沿Y轴向上扭曲\n\nrotate()：旋转\n-  **rotate()**：2D旋转\n-  **rotate3d(x,y,z,a)**：3D旋转，`[x,y,z]`是一个向量，数值都是`0~1`\n-  **rotateX(a)**：X轴旋转，等同于`rotate(1,0,0,a)`，正值时沿X轴向上逆时针旋转，负值时沿X轴向下顺时针旋转\n-  **rotateY(a)**：3D Y轴旋转，等同于`rotate(0,1,0,a)`，正值时沿Y轴向右逆时针旋转，负值时沿Y轴向左顺时针旋转\n-  **rotateZ(a)**：3D Z轴旋转，等同于`rotate(0,0,1,a)`，正值时沿Z轴顺时针旋转，负值时沿Z轴逆时针旋转\n- 描述\n  - 单位：`Angle`角度或`Turn`周\n  - 正值：2D旋转时顺时针旋转\n  - 负值：2D旋转时逆时针旋转\n\nmatrix()：矩阵(太过复杂，可放弃)\n-  **matrix(a,b,c,d,e,f)**：2D矩阵(位移、缩放、扭曲、旋转的综合函数)\n-  **matrix(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)**：3D矩阵(位移、缩放、扭曲、旋转的综合函数)\n\nperspective()：视距\n- `Length`：长度，可用任何长度单位\n  - 值越小，用户与空间Z轴距离越近，视觉效果越强\n  - 值越大，用户与空间Z轴距离越远，视觉效果越弱\n\n使用Transform默认会使浏览器开启GPU加速，因此性能更好\n\n## 过渡Transition\n\n### 属性\n\ntransition-property：属性\n\n- `all`：全部属性过渡(`默认`)\n- `none`：无属性过渡\n- `String`：某个属性过渡\n\ntransition-duration：时间\n- `Time`：秒或毫秒(默认`0`)\n\ntransition-timing-function：缓动函数\n- `ease`：逐渐变慢，等同于`cubic-bezier(.25,.1,.25,1)`(`默认`)\n- `linear`：匀速，等同于`cubic-bezier(0,0,1,1)`\n- `ease-in`：加速，等同于`cubic-bezier(.42,0,1,1)`\n- `ease-out`：减速，等同于`cubic-bezier(0,0,.58,1)`\n- `ease-in-out`：先加速后减速，等同于`cubic-bezier(.42,0,.58,1)`\n- `cubic-bezier`：贝塞尔曲线，`(x1,y1,x2,y2)`四个值特定于曲线上的点`P1`和`P2`，所有值需在`[0,1]`区域内\n\ntransition-delay：时延\n\n- `Time`：秒或毫秒(默认`0`)\n\n由于`duration`和`delay`的取值都是时间，所以可能会发生混淆。\n\n- `duration`和`delay`作用于所有节点，包括自身的`::before`和`::after`\n- `transition`中出现两个时间值时，第一个解析为`duration`，第二个解析为`delay`\n- `transition`中出现一个时间值时，解析为`duration`\n\n### 贝塞尔曲线\n\n通过`cubic-bezier()`来设置一个贝塞尔曲线值。`transform-timing-function`的值都是预设好的贝塞尔曲线值。\n\n[CubicBezier](https://cubic-bezier.com/)上可以查看具体效果\n\n![transform-timing-function](../../images/transform-timing-function.jpg)\n\n## 动画Animation\n\n### 属性\n\n`animation`可声明的两种动画：\n\n-  **关键帧动画**：\n  - 在时间轴的关键帧上绘制关键状态并使之有效过渡组成动画\n  - 通过`@keyframe`声明\n-  **逐帧动画**：\n  - 在时间轴的每一帧上绘制不同内容并使之连续播放组成动画\n  - 准备一张`逐帧长图`，在`steps()`里声明逐帧长图及其展示方式\n\nanimation-name：名称\n\n- `none`：无动画(`默认`)\n- `String`：动画名称\n\nanimation-duration：时间\n\n- `Time`：秒或毫秒(默认`0`)\n\nanimation-timing-function：缓动函数\n\n- `ease`：逐渐变慢，等同于`cubic-bezier(.25,.1,.25,1)`(`默认`)\n- `linear`：匀速，等同于`cubic-bezier(0,0,1,1)`\n- `ease-in`：加速，等同于`cubic-bezier(.42,0,1,1)`\n- `ease-out`：减速，等同于`cubic-bezier(0,0,.58,1)`\n- `ease-in-out`：先加速后减速，等同于`cubic-bezier(.42,0,.58,1)`\n- `cubic-bezier`：贝塞尔曲线，`(x1,y1,x2,y2)`四个值特定于曲线上的点`P1`和`P2`，所有值需在`[0,1]`区域内\n- `steps([,[start|end]]?)`：把动画平均划分成`n等分`，直到平均走完该动画\n- `step-start`：等同于`steps(1,start)`，把动画分成一步，动画执行时以左侧端点`0%`为开始\n- `step-end`：等同于`steps(1,end)`，把动画分成一步，动画执行时以右侧端点`100%`为开始\n\nanimation-delay：时延\n\n- `Time`：秒或毫秒(默认`0`)\n\nanimation-iteration-count：播放次数\n\n- `Number`：数值(默认`1`)\n- `infinite`：无限次\n\nanimation-direction：轮流反向播放(播放次数为一次则该属性无效果)\n\n- `normal`：正常播放(`默认`)\n- `alternate`：轮流反向播放，奇数次数正常播放，偶数次数反向播放\n\nanimation-play-state：播放状态\n\n- `running`：正在播放(`默认`)\n- `paused`：暂停播放\n\nanimation-fill-mode：播放前后其效果是否可见\n\n- `none`：不改变默认行为(`默认`)\n- `backwards`：在时延所指定时间内或在动画开始前应用开始属性(`在第一个关键帧中定义`)\n- `forwards`：在动画结束后保持最后一个属性(`在最后一个关键帧中定义`)\n- `both`：向前和向后填充模式都被应用\n\n### 案例\n\n#### 打字机\n\n```vue\n<template>\n\t<div class=\"auto-typing\">Do You Want To Know More About CSS Development Skill</div>\n</template>\n\n<script>\nexport default {}\n</script>\n\n<style>\n@mixin typing($count: 0, $duration: 0, $delay: 0) {\n    overflow: hidden;\n    border-right: 1px solid transparent;\n    width: #{$count + 1}ch;\n    font-family: Consolas, Monaco, monospace;\n    white-space: nowrap;\n    animation: typing #{$duration}s steps($count + 1) #{$delay}s infinite backwards,\n        caret 500ms steps(1) #{$delay}s infinite forwards;\n}\n.auto-typing {\n    font-weight: bold;\n    font-size: 30px;\n    color: #09f;\n    @include typing(52, 5);\n}\n@keyframes caret {\n    50% {\n        border-right-color: currentColor;\n    }\n}\n@keyframes typing {\n    from {\n        width: 0;\n    }\n}\n</style>\n```\n","tags":["css"],"categories":["CSS"]},{"title":"认识RPC","url":"/posts/91c0fa71.html","content":"\n## RPC初识\n\n`RPC（Remote Procedure Call）`即**远程过程调用**。与`Ajax`类似。主要用于不同端之间的通信。\n\n和`Ajax`的异同之处：\n\n1. 都是计算机之间网络通信的方式\n   1. `Ajax`是浏览器与服务端之间的通信方式\n   2. `RPC`是服务端之间的通信方式\n2. 都需要双方约定一个数据格式\n   1. `Ajax`约定格式为`json`\n   2. `RPC`通常使用**二进制**\n3. 寻址方式\n   1. `Ajax`使用`DNS`进行寻址\n   2. `RPC`也需要寻址，可能根据ID或者一个`VIP(虚拟IP)`。使用`DNS`成本太高。\n4. 应用层协议\n   1. `Ajax`使用`HTTP`作为应用层协议\n   2. `RPC`通常使用二进制协议（基于TCP或UDP），传输二进制数据，这样体积小，编解码速度快（计算机本身就只能识别二进制）。\n\n## 二进制编解码\n\n`RPC`通信传输的数据是**二进制数据**，而不是`JSON`数据。\n\n在`Nodejs`中，内置了`Buffer`模块，它可以用来操作二进制数据\n\n### Buffer\n\n#### 创建Buffer\n\n```javascript\n// 1. 使用Buffer.from\n// 创建一个8字节 buffer二进制数据\n// 每个字符占 1个字节\nconst buffer1 = Buffer.from('helloRPC'); \n\n// 2. Buffer.from 的参数可以为数组\n// 每个数组元素 占1个字节\nconst buffer2 = Buffer.from([1,2,3,4]);\n\n// 3. 使用Buffer.alloc\n// 创建一个20 字节的Buffer\nconst buffer3 = Buffer.alloc(20);\n```\n\n#### 读写Buffer\n\n`Buffer`内提供了众多读写`Buffer`方法，详情见[nodejs文档-Buffer](https://nodejs.org/api/buffer.html)\n\n```javascript\n// 1. 读\n\n// 从offset开始，读一个带符号8位的整型\nbuffer.readInt8(0) // 参数为offset，默认为0\n\n// 从offset开始，读一个32位的float\n// BE代表大端模式，LE代表小端模式\nbuffer.readFloatBE(0)\n\n// 2. 写\n// 第一个参数是需要写入的值\n// 第二个参数是 offset\nbuffer2.writeInt8(12, 1)\nbuffer3.writeInt16BE(255, 2)\n```\n\n> 大端模式（big-endian, BE）和小端模式（little-endian, LE）\n>\n> 两者主要指存放字节的顺序不同，BE将高位放在低地址，LE将高位放在高地址\n>\n> 16位二进制: 0000 0010 1110 1100\n>\n> 使用 writeInt16BE(128, 0), 在偏移量位0的位置写入128(2进制是 1000 0000)。写入后\n>\n> 16位二进制：**1000 0000** 1110 1100（加黑为写入的）\n>\n> 如果使用writeInt16LE(128, 0)，在偏移量0的位置写入128(2进制是 1000 0000)。写入后\n>\n> 16位二进制：**0000 1000** 1110 1100（加黑为写入的）\n>\n> 可见两者写入顺序不同\n\n#### 小结\n\n在进行`RPC`通信时，需要创建Buffer对象，然后读写数据。\n\n可是这种方式太复杂，远没有`json`方便。后者只需要通过`JSON.stringify`和`JSON.parse`进行序列化和反序列化即可。\n\n`Google`提供了一个[protocol buffers](https://github.com/protocolbuffers/protobuf)二进制编解码库，可以和使用`json`一样方便\n\n### Protocol Buffers\n\n[Protocol Buffers](https://github.com/protocolbuffers/protobuf)是一个二进制编码库。本身提供了众多语言的实现，官方文档也介绍其是一个语言无关的库\n\n所以可以在nodjs上使用它编码数据，在其它环境下（比如JAVA、Python）来使用它解码数据。\n\n先安装`npm install protocol-buffers`\n\n第一步需要编写`proto`文件，例如`test.proto`来约束二进制文件的格式。\n\n```proto\nmessage Column {\n\trequired int32 id = 1;\n\trequired string name = 2;\n\trequired float price = 3\n}\n```\n\n然后就可以导入使用\n\n```javascript\nconst protobuf =  require('protocol-buffers');\nconst fs = require('fs')\n\n// 创建schema\nconst schema = protobuf(fs.redFileSync(__dirname + '/test.proto', 'utf-8'));\n\n// 编码\nconst buf = schema.Column.encode({id:1, name: 'ff', price: 99.9});\n\n// 解码\nconst data = schema.Column.decode(buf)\n```\n\n## 搭建多路复用的RPC通道\n\n### 实现半双工通信\n\n#### 原理\n\n通过使用`ndoejs`内置的`net`模块来搭建通信的双端。\n\n`nodejs`内置的`http`模块也是基于`net`模块的。只是`http`模块用的是`http`协议。`rpc`并不用`http`协议。\n\n半双工通信即同一时间只能有一个方向的数据传输。\n\n![单双工](../../images/单双工.png)\n\n#### 编码\n\n数据mock\n\n```javascript\n// mock.js\nconst data = {\n  121391: \"第一课：北京故事\",\n  121392: \"第二课：背影-朱自清\",\n  121393: \"第三课：最后一课\",\n  121394: \"第四课：春\",\n  121395: \"第五课：济南的冬天\",\n};\n\nexports.getDataById = function (id) {\n  return data[id];\n};\n\nexports.mockId = function () {\n  const index = Math.ceil(Math.random() * 4);\n  return Object.keys(data)[index];\n};\n\n```\n\n服务端\n\n监听数据，收到数据后，延时1s将结果返回。\n\n```javascript\n// server\nconst net = require(\"net\");\nconst { getDataById } = require(\"./mock.js\");\n\nconst server = net.createServer((socket) => {\n  socket.on(\"data\", (buffer) => {\n    // 解析buffer，获取id\n    const id = buffer.readInt32BE();\n\n    // 1秒后 返回数据\n    setTimeout(() => {\n      const data = getDataById(id);\n      socket.write(Buffer.from(data));\n    }, 1000);\n  });\n});\n\nserver.listen(4000);\n\n```\n\n客户端\n\n先发送数据，当收到服务端处理结果后，输出结果并再次发送数据。\n\n```javascript\n// client\nconst net = require(\"net\");\nconst { mockId } = require(\"./mock.js\");\n\nconst socket = new net.Socket({});\n\nsocket.connect({\n  host: \"127.0.0.1\",\n  port: 4000,\n});\n\nfunction sendData() {\n  const id = mockId();\n  const buffer = Buffer.alloc(4);\n  buffer.writeInt32BE(id);\n  socket.write(buffer);\n}\n\nsocket.on(\"data\", (buffer) => {\n  console.log(buffer.toString());\n  sendData();\n});\n\nsendData();\n\n```\n\n### 实现全双工通信\n\n#### 原理\n\n全双工通信即同一时刻，通信链路上可以有多个方向的数据传输。相比单双工通信会带来两个问题。\n\n![全双工](../../images/全双工.png)\n\n问题一：客户端同一时间发送两个数据包。服务端接收到的顺序与发送顺序不一致。因此服务端不知道数据包对应是哪次发送的。\n\n解决：数据包增加一个**首部**，首部存放一个**标识ID**。从而识别数据包。\n\n\n\n问题二：当客户端连续发送n的数据包，TCP底层会进行优化，将这些（二进制）数据包合并成一个，导致服务端以为只收到一个数据包。\n\n解决：在数据包首部，再增加一个**body长度标识**，指明这个二进制数据的长度。收到数据后进行按照**长度标识**拆包。\n\n由此，新的数据包结构如下：\n\n![全双工数据报文](../../images/全双工数据报文.png)\n\n#### 编码\n\n`mock.js`内容不变\n\n增加`handler.js`用于处理接受的数据和发送数据\n\n```javascript\nmodule.exports = function (socket) {\n  let oldBuffer = null;\n  let sequence = 0;\n\n  function handleBuffer(buffer) {\n    const dataArray = [];\n    if (oldBuffer) buffer = Buffer.concat([oldBuffer, buffer]);\n\n    let completeLength = 0;\n    while ((completeLength = checkComplete(buffer))) {\n      // package为一个数据包\n      const package = buffer.slice(0, completeLength);\n      // 处理剩余的数据包\n      buffer = buffer.slice(completeLength);\n\n      const header = package.slice(0, 6);\n      const body = package.slice(6);\n      const parsedData = {\n        sequence: header.readInt16BE(),\n        data: body.toString(),\n      };\n      dataArray.push(parsedData);\n    }\n\n    oldBuffer = buffer;\n\n    return dataArray;\n\n    // 检查buffer完整性\n    // 根据首部的范围标识来判断\n    function checkComplete(buffer) {\n      if (buffer.length < 6) {\n        return 0;\n      }\n      const bodyLength = buffer.readInt32BE(2);\n      const packageLength = 6 + bodyLength;\n      return buffer.length < packageLength ? 0 : packageLength;\n    }\n  }\n\n  function sendBuffer(data, seq) {\n    // 写入body\n    const body = Buffer.from(data);\n\n    // 写入首部\n    const header = Buffer.alloc(6);\n    header.writeInt16BE(seq || sequence++);\n    header.writeInt32BE(body.length, 2);\n\n    // 拼接header和body\n    const buffer = Buffer.concat([header, body]);\n\n    socket.write(buffer);\n  }\n\n  return {\n    handleBuffer,\n    sendBuffer,\n  };\n};\n\n```\n\n服务端`server.js`\n\n```javascript\n// server\nconst net = require(\"net\");\nconst { getDataById } = require(\"./mock.js\");\nconst createHandler = require(\"./handler.js\");\n\nconst server = net.createServer((socket) => {\n  const handler = createHandler(socket);\n  socket.on(\"data\", (buffer) => {\n    // 解析buffer，获取id\n    const dataArray = handler.handleBuffer(buffer);\n    dataArray.forEach((data) => {\n      console.log(\n        `服务端收到数据：\\n\\tsequence:${data.sequence}\\n\\tdata:${data.data}`\n      );\n      // 1秒后 返回数据\n      setTimeout(() => {\n        const responseData = getDataById(data.data);\n        handler.sendBuffer(responseData);\n      }, 1000);\n    });\n  });\n});\n\nserver.listen(4000);\n\n```\n\n客户端`client.js`\n\n```javascript\n// client\nconst net = require(\"net\");\nconst { mockId } = require(\"./mock.js\");\nconst createHandler = require(\"./handler.js\");\n\nconst socket = new net.Socket({});\n\nsocket.connect({\n  host: \"127.0.0.1\",\n  port: 4000,\n});\n\nconst handler = createHandler(socket);\n\nsocket.on(\"data\", (buffer) => {\n  const dataArray = handler.handleBuffer(buffer);\n\n  dataArray.forEach((data) => {\n    console.log(\n      `客户端收到数据：\\n\\tsequence:${data.sequence}\\n\\tdata:${data.data}`\n    );\n  });\n});\n\n// 连续发送10个数据包\nfor (let i = 0; i < 10; i++) {\n  const id = mockId();\n  handler.sendBuffer(id);\n}\n\n```\n\n> 例子过于简单，所以直接使用`Buffer`\n>\n> 实际使用推荐通过`protocol buffers`处理二进制数据","tags":["网络","Nodejs"],"categories":["Nodejs"]},{"title":"算法——数组去重","url":"/posts/d5def5e2.html","content":"\n数组去重涉及到的场景还是比较多的，面试中也有很大频率被问到。\n\n从数据结果角度来说：数组属于线性表。适合做查询，不适合增删。\n\n去重的实现方案有很多，总的来说可分为**原地去重**和**非原地去重**两种\n\n> *原地算法*中的*原地*是指*算法*所需的辅助空间是常量，及空间复杂度O(1)\n\n## 非原地算法\n\n非原地算法可能比较符合**不可变数据`Immutable Data`**数据的思想。也是比较推荐的风格。\n\n### 用Set\n\n数据量不大的，用set即可。\n\n```typescript\nfunction unique(nums: number[]): number[] {\n  return Array.from(new Set(nums));\n}\n```\n\n### 循环\n\n循环也是比较简单的\n\n```typescript\nfunction unique(nums: number[]): number[] {\n  let result: number[] = [];\n    \n  // 循环\n  nums.forEach((item) => {\n    // 没有就加入\n    if (result.indexOf(item) === -1) {\n      result.push(item);\n    }\n  });\n  return result;\n}\n```\n\n### 使用高阶函数\n\n数组提供了一些高阶函数，`filter`、`reduce`等，可以用来实现去重。\n\n使用`reduce`：原理和循环一样，就是用到了`reduce`这个api\n\n```typescript\nfunction unique(nums: number[]): number[] {\n  return nums.reduce<number[]>((total, current) => {\n    if (total.indexOf(current) === -1) total.push(current);\n    return total;\n  }, []);\n}\n```\n\n使用`filter`：\n\n```typescript\nfunction unique(nums: number[]): number[] {\n  return nums.filter((item, index) => nums.indexOf(item) === index);\n}\n```\n\n### 其他情况：数组元素是个对象\n\n这样的话，待比较的值就不是数组元素，而是数组元素（对象）的某个key：\n\n题目：**按照对象的id去重**。\n\n1. 基于循环的例子：\n\n```typescript\ninterface IElement {\n  id: number;\n  name: string;\n}\n\nfunction unique(nums: IElement[]): IElement[] {\n  let result: IElement[] = [];\n\n  // 循环\n  nums.forEach((item) => {\n    // 没有就加入\n    if (result.every((r) => r.id !== item.id)) { // ********这里不一样********\n      result.push(item);\n    }\n  });\n  return result;\n}\n\nconst arr = [\n  { id: 1, name: \"aa\" },\n  { id: 1, name: \"bb\" },\n  { id: 2, name: \"cc\" },\n  { id: 3, name: \"dd\" },\n];\n\nconsole.log(unique(arr))\n// [ { id: 1, name: 'aa' }, { id: 2, name: 'cc' }, { id: 3, name: 'dd' } ]\n```\n\n只是判断的方式变了，这里使用到了数组的`every`方法。\n\n高阶函数`reduce`也同理，就是判断是否相同的方式变了。\n\n`filter`的话也一样，这里使用到了`findIndex`方法\n\n```typescript\nfunction unique(nums: IElement[]): IElement[] {\n  return nums.filter((item, index) => {\n      \n    // *******这里判断变了********\n    const firstIndex = nums.findIndex((n) => n.id === item.id);\n    return firstIndex === index;\n  });\n}\n```\n\n以上方法本质上都一样，都是创建一个新的数组，并未对原数组做任何修改。\n\n## 原地算法\n\n原地算法不需要额外的存储空间，直接修改原数组即可。\n\n按两种情况分析：**有序数组**和**无序数组**\n\n### 有序数组\n\n把原数组分成两个部分，一部分是结果数组（无重复的），另一部分是待遍历数组\n\n初始状态下：\n\n![数组去重-双指针](../../images/algorithm/数组去重-双指针.jpg)\n\n数组是有序的，每次遍历都判断一下`j`和`i`对应的值是否相等，如果不相等就将`j`对应的值插入结果数组中，反之则不做操作继续遍历。\n\n最后再修改一下数组的长度。这种方法也叫做**双指针法**\n\n```typescript\nfunction unique(nums: number[]): void {\n  let i = 0;\n\n  // 遍历数组\n  for (let j = 1; j < nums.length; j++) {\n    // 有序\n    if (nums[i] !== nums[j]) {\n      nums[++i] = nums[j];\n    }\n  }\n    \n  // 修改数组长度\n  nums.length = i + 1;\n}\n\nconst arr = [1, 2, 2, 3, 4, 4, 5, 6, 6, 7];\n\nunique(arr);\nconsole.log(arr);\n```\n\n### 无序数组\n\n无序数组去重，\n\n1. 第一种思想：先排序，再用上面的方法（不可取）\n2. 遍历+删除\n\n```typescript\nfunction unique(nums: number[]): void {\n  for (let i = 0; i < nums.length; i++) {\n    const target = nums[i];\n    \n    if (nums.indexOf(target) !== i) {\n      // 说明原数组 有不止一个当前元素\n      // 那就 删除当前元素（多余的）\n      nums.splice(i, 1);\n      i--; // 调整索引\n    }\n  }\n}\n```\n\n上面用到了`splice`这个方法，它也是基于**原地算法**。所以整个`unique`函数也是*原地*的。\n\n### 其它情况：数组元素是个对象\n\n改一下比较对象就可以了。\n\n基于无序数组的例子：\n\n```typescript\ninterface IElement {\n  id: number;\n  name: string;\n}\n\nfunction unique(nums: IElement[]): void {\n  for (let i = 0; i < nums.length; i++) {\n    const target = nums[i];\n    \n    // ***********改一下判断规则***********\n    const firstIndex = nums.findIndex((n) => n.id === target.id);\n    if (firstIndex !== i) {\n      nums.splice(i, 1);\n      i--;\n    }\n  }\n}\n\nconst arr = [\n  { id: 1, name: \"aa\" },\n  { id: 1, name: \"bb\" },\n  { id: 2, name: \"cc\" },\n  { id: 3, name: \"dd\" },\n];\n\nunique(arr);\nconsole.log(arr);\n```\n\n","tags":["JavaScript","TypeScript","Algorithm"],"categories":["Algorithm"]},{"title":"Rust学习笔记-Ownership","url":"/posts/2c967516.html","content":"\n本系列文章是笔者学习`Rust`时所做的笔记，供日后翻阅复习。\n\n## Ownership?\n\n`ownership`（所有权）是一套用来高效管理内存的方案。\n\n内存管理主要分为两种：\n\n1. `GC(garbage collection)`：如`java`、`javascript`，它们都有垃圾回收机制，会不停地检查是否存在不会被使用到的内存，然后释放它\n2. 手动方式：如`C语言`，需要开发者手动分配和释放内存。\n\n`Rust`则是在编译时就能知道何时需要释放内存，而无需等到运行时，所以不会影响到程序的运行速度。\n\n### 栈内存和堆内存\n\n栈内存：\n\n1. 按照获取值的顺序存储数据，按照相反的顺序删除值\n2. 栈内存存储的数据都是定长的\n\n堆内存：\n\n1. 无组织的\n2. 存储数据时，内存分配器会找到一块足够存放的内存来存放，并将其标记为已使用，然后返回一个指针。指针是定长的并且存放在栈内存中\n3. 访问堆内存比访问栈内存更耗时。栈内存是相邻的，而访问堆内存需要在内存中跳跃\n\n### Ownership规则\n\n1. `Rust`中的每一个值都有且仅有一个`owner`变量\n2. `owner`离开其作用域时，该值会被删除\n\n```rust\nfn main() {\n  // 此处：s无法访问\n  let s = \"hello\";\n  // 此处：s可以访问\n} // 此处：离开作用域，s无法访问\n```\n\n`s`是字符串字面量的`owner`，离开其作用域就无法访问\n\n### 字符串与`Ownership`\n\n以字符串类型来说明`Ownership`。其它（存储在堆内存的）类型同理\n\n声明一个字符串类型，可以使用字面量或者`String`\n\n```rust\nfn main() {\n  let mut s = String::from(\"hello\")\n  \n  s.push_str(\", rust!\");\n  \n  println!(\"{}\", s);\n}\n```\n\n区别：字符串字面量不可修改，`String`是可以被修改的\n\n#### 内存和分配\n\n对于字符串字面量，在编译时就已知其长度（并且不能改变）\n\n而`String`类型，为了保持其可变性，需要满足两点：\n\n1. 在运行时请求内存分配：使用`String::from`就会在运行时来请求内存分配\n2. 当String使用完后，需要将内存返还给内存分配器（内存回收）：`Rust`是当变量离开其作用域时就会自动调用`drop`函数，来回收其内存。\n\n#### Move\n\n```rust\nfn main() {\n  let s1 = String::from(\"hello\");\n  let s2 = s1;\n  // 此处：s2有效，s1无效\n}\n```\n\n说明：\n\n1. `String`是存储在堆内存中的，`s2 = s1`只会复制栈内存的数据（含指针）而不会再拷贝一份堆内存数据\n2. `s2 = s1`叫做`s1`的`ownership`移动(move)到了`s2`，则`s1`会无效即无法再访问。这么做的原因是防止变量离开作用域后对同一块堆内存回收两次。\n\n#### Clone\n\n如果需要对堆内存进行深拷贝，就需要调用公共方法`clone`\n\n```rust\nfn main() {\n  let s1 = String::from(\"hello\");\n  let s2 = s1.clone();\n  // s1 s2都有效\n}\n```\n\n#### Copy\n\n前面所说的规则适用于堆内存的数据，而对于栈内存数据则不一样\n\n```rust\nfn main() {\n  let x = 5;\n  let y = x;\n  // x y 都有效\n}\n```\n\n这是因为`i32`类型具有`copy`特性\n\n具有`copy`特性的有：\n\n1. 所有整型\n2. 布尔类型\n3. 浮点类型\n4. 字符类型`char`\n5. 元组类型，前提：元组的成员都是具有`copy`特性的\n\n### 函数与`Ownership`\n\n#### 传参\n\n函数传参的场景涉及到了`ownership`的`move`\n\n```rust\nfn main() {\n  let s = String::from(\"hello\");\n  takes_ownership(s);\n  // s 无效，String发生move\n  \n  let x = 10;\n  makes_copy(x);\n  // x 依旧有效，x具有copy特性\n} // x离开作用域 出栈；s离开作用域，由于已经无效了不会进行回收\n\nfn takes_ownership(some_string: String) {\n  println!(\"{}\", some_string);\n} // some_string离开作用域，进行回收\n\nfn makes_copy(some_integer: i32) {\n  println!(\"{}\", some_integer);\n} // some_integer离开作用域 出栈\n```\n\n> 内存回收(drop)针对堆内存，栈内存是出栈(pop off)\n\n#### 返回值和作用域\n\n函数的返回值也会转移`ownership`\n\n```rust\nfn main() {\n  let s1 = gives_ownership();         // gives_ownership将返回值move给s1\n\n  let s2 = String::from(\"hello\");\n\n  let s3 = takes_and_gives_back(s2);  // s2 发生move\n                                        // takes_and_gives_back将返回值move给s3\n} \n// s3离开作用域，发生drop\n// s2离开作用域，但已经move了\n// s1离开作用域，发生drop\n\nfn gives_ownership() -> String {            \n  let some_string = String::from(\"hello\"); \n\n  some_string // some_string move给调用函数\n} // some_string，已经move了\n\nfn takes_and_gives_back(a_string: String) -> String { \n\n    a_string  // a_string move给调用函数\n} // a_string 离开作用域，发生drop\n```\n\n由于`ownership`存在`move`，所以只有当函数将数据返回，我们才能再次使用。`Rust`支持多返回值，所以不会干扰其它返回值数据。\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let (s2, len) = calculate_length(s1);\n\n    println!(\"The length of '{}' is {}.\", s2, len);\n}\n\nfn calculate_length(s: String) -> (String, usize) { // 返回类型是一个元组\n    let length = s.len();\n\n    (s, length) // 多返回值\n}\n```\n\n## References\n\n### Immutable References\n\n在函数传参的场景下，由于`ownership`的存在，一旦`ownership`发生`move`。就无法在函数体之后的部分访问到该变量。\n\n这是`Rust`故意设计的，但`Rust`又提供了另一种函数传参方式而不会发生`move`——`引用(References)`\n\n```rust\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1); // 加个 &号表示 创建一个Reference 指向s1\n\t\t\n  \t// s1 依旧有效\n}\n// len 离开作用域，出栈\n// s1 离开作用域 drop\n\nfn calculate_length(s: &String) -> usize { // 接受参数也是一个 Reference\n    s.len()\n}\n// s离开作用域，它是Reference 不会drop\n```\n\n`Reference`不会获得原数据的`ownership`\n\n上例中，我们称`calculate_length`函数`租借(borrowing)`s1\n\n但是，`calculate_length`内部不能修改 s1，否则编译器会报错\n\n### Mutable References\n\n如果需要修改`Reference`，就可以使用`&mut s`的形式声明一个`Mutable References`。\n\n```rust\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(\", world\");\n}\n```\n\n但也是又限制的\n\n1. 同一作用域下，同一数据块只能有一个`Mutable References`，这是为了防止`Data races`\n2. 在使用`Immutable Reference`的同时，不能使用`Mutable References`\n\n### Dangling References\n\n悬挂引用（空指针），看个例子\n\n```rust\nfn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -> &String {\n    let s = String::from(\"hello\");\n\n    &s\n} // s离开作用域 drop\n// 函数返回 s的Reference，但s已经被drop。这个reference就是Dangling References\n```\n\nRust是不允许这种情况发生的，所以这样写会报错。\n\n## Slice\n\n### 字符串切片\n\n切片(`slice`)同样也不会发生`ownership`转移\n\n```rust\nfn main() {\n  let s = String::from(\"hello world!\");\n  \n  let s1 = &s[0..3];\n  let s2 = &s[3..12];\n  \n  println!(\"{}-{}\", s1, s2); // hel-lo world!\n}\n```\n\n`&s[0..3]`会创建s中索引[0, 2]的`Reference`。\n\n有几种可以省略值的写法：\n\n1. `[0..2]`和`[..2]`是等价的\n\n2. `[2..len]`和`[2..]`等价，`len`为总长度\n3. `[0..len]`和`[..]`等价\n\n从数据结构角度看，`String Slice`会存储起始位置和长度：\n\n![rust-string-slice-structure](../../images/rust-string-slice-structure.png)\n\n写一个查找字符串首个单词\n\n```rust\nfn main() {\n  let s = String::from(\"hello world!\");\n  \n  let word = first_word(&s); // &s[..]也可以\n  println!(\"{}\", word); // hello\n}\n\nfn first_word(s: &str) -> &str {\n  let bytes = s.as_bytes();\n  \n  for (i, &item) in bytes.iter().enumerate() {\n    if item == b' ' {\n      return &s[..i];\n    }\n  }\n  \n  &s[..]\n}\n```\n\n字符串切片的类型是`&str`，`&str`类型能够兼容`&String`和`&str`\n\n### 字符串字面量\n\n字符串字面量本身就是`slice`\n\n```rust\nlet s = \"Hello, World!\"\n```\n\n`s`的类型就是`&str`即一个字符串切片。`&str`是一个`Immutable Reference`，所以字符串字面量不可变","tags":["Rust","语言学习"],"categories":["Rust"]},{"title":"学习路径","url":"/posts/2b6933ae.html","content":"\n## 知识概览\n\n### 从基本功角度看\n\n基本功扎实了，后面的知识技术才好推进。\n\n#### 工具\n\n1. terminal：命令行肯定要会用\n2. Git版本控制：原理、概念以及常见的场景，必须学会git的命令行使用方法。不能过分依赖GUI工具\n3. 编辑器：`VSCode`，这玩意还用学？错，你看过`vscode`的更新日志吗？你会用`vscode`来debug吗？你会写`vscode`插件吗？\n\n#### 开源常识\n\n作为程序员，技术上紧跟开源社区准没错。\n\n1. 语义版本号\n2. `GitHub`、`Gitee`、`Gitlab`\n3. 开源许可\n\n#### 支撑知识\n\n1. 数据结构\n2. 设计模式\n3. 网络：了解`HTTP`吗？`HTTP`0.9 - 3.0有什么区别？HTTP的头信息有哪些？干什么用的？DNS？\n4. 浏览器工作模型\n\n### 从语言角度看\n\n前端开发四大语言：`HTML` `CSS` `JavaScript` `WebAssembly`\n\n每一门语言都涉及到知识的延申\n\n`html5`提供了繁多复杂的`API`\n\n`CSS` 的预处理器有`less`、`scss`、`stylus`\n\n`JavaScript` 的超集：`TypeScript`\n\n`WebAssembly`需要学习一门系统级的语言——`c++`或者`rust`\n\n### 从平台角度看\n\nweb技术的跨平台性实属最强。web技术几乎啥都能做。\n\n网页端：没啥可说的，web最初就是用来干这个的\n\n移动端：小程序、`react native`、`flutter`（也算上吧），还有一堆混合开发工具，PWA\n\n客户端：`electron`\n\n服务端：`express`、`koa`、`nest.js`\n\n### 从视图层角度看\n\n视图层有三大框架：`Vue`、`React`、`Angular`\n\n`Vue`和`React`都是用组件化开发的思想来构建web应用。但其底层实现方式完全不一样。学习它们时一定要深入底层，比如搞清楚`Vue响应式`究竟是如何实现的。\n\n无论`Vue`还是`React`都是所谓的**单页面应用(Single Page Application, SPA)**。不利于`SEO`，首屏加载慢，进而又出现了**服务端渲染(Server Side Render, SSR)**。\n\n### 从工程化角度\n\n前端工程化是基于`nodejs`的。\n\n前端项目的构建工具有很多，常用的有`Webpack`、`Rollup`、`Gulp/Grunt`等，今年有`Vue`团队又出了个`Vite`。他们又有什么区别？\n\n服务端渲染\n\n微前端\n\n**工程化又要考虑哪些细节问题？**（太多了）\n\n`node`的包管理有`npm`和`yarn`两种，他们又有什么区别？\n\n### 从服务端角度看\n\n`JavaScript`可以通过`nodejs`来写服务端程序。不过又冒出了个`deno`，引入了十分有趣的概念，他们有什么区别呢？\n\n至少掌握一个服务端的框架吧：轻量级的有`Express`、`Koa`。重量级的比较推荐`Nest.js`\n\n有了服务端，是不是可以引入`BFF`层了\n\n有了服务端，是不是可以做服务端渲染了\n\n有了服务端，是不是可以用`GraphQL`了\n\n有了服务端，是不是搭建Mock服务，性能监控、错误监控了\n\n有了服务端，是不是还可以学习下数据库\n\n## 阶段零：习惯养成\n\n阶段零是贯穿整个学习计划的，旨在养成自律的学习习惯。\n\n- [ ] 每天至少一道算法题，`LeetCode`刷起来。（每道题都要写答题笔记哦）\n\n## 阶段一：夯实基础\n\n会从前端四大语言入手，`HTML` `CSS` `JavaScript` 三者结合起来学习。`WebAssembly`也会深入了解\n\n- [ ] [JavaScript现代教程](https://zh.javascript.info/)结合红宝书，搞懂`JavaScript`的方方面面。\n- [ ] 梳理`H5`新增特性，比如canvas、音视频方面（这需要结合`JS`学习）\n- [ ] 学习`CSS`基本概念，掌握页面布局以及众多的`CSS3`属性用法\n- [ ] [TypeScript学习](https://jkchao.github.io/typescript-book-chinese/)\n- [ ] `WebAssembly`的实现原理，手摸手写一下`wasm`\n\n> 这个过程中也会穿插学习一些其它内容，比如浏览器工作模型等。\n\n## 阶段二：视图层库\n\n这个阶段会对`React`和`Vue`生态进行学习。没错。两个都要学！\n\n- [ ] 学习两者开发思路。掌握其提供每一个`API`\n- [ ] 尝试写个组件库\n- [ ] **深入源码**，搞懂其设计思想\n\n> 阅读源码过程中，会穿插一下**设计模式**以及**数据结构**的学习\n\n## 阶段三：工程化\n\n从工程化角度思考前端建设。\n\n- [ ] 构建工具学习\n  - [ ] 学会`webpack`构建项目\n  - [ ] 深入了解`webpack`原理\n  - [ ] 了解其它构建工具`rollup`和`gulp`\n- [ ] 前端工程化的应用场景\n- [ ] 引入中间层`BFF`，研究一下前端体系建设。\n- [ ] 微前端的应用\n\n## 阶段四：多端开发\n\n这个阶段就涉及到其它场景了。比如说移动端、客户端甚至服务端。\n\n- [ ] 移动端\n  - [ ] 熟练编写移动端页面，（移动端对交互有一定的要求）\n  - [ ] 掌握 `React native`开发移动端应用\n- [ ] 客户端：Electron技术\n- [ ] 服务端：`nodejs`服务端通常用来搭建BFF层的。\n  - [ ] 掌握`Koa`原理，学会开发中间件。拆一下`Vite`源码瞅一下\n  - [ ] `nest.js`：如果真的要用node编写服务端，它是目前最好的选择\n","tags":["Plan"],"categories":["Plan"]},{"title":"搞懂EventLoop","url":"/posts/d0699962.html","content":"\n## JavaScript&单线程\n\n### 进程与线程\n\n进程是cpu分配资源的最小单位；线程是cpu调度的最小单位。一个进程可以包含多个线程。\n\ncpu给进程分配资源，进程再创建线程去工作。实际干活的是线程。同一进程下的线程共享该进程的资源。\n\n通常，进程之间是**并行执行**；线程之间是**并发执行**\n\n### 浏览器的多进程模型\n\n以开源的`Chromium`浏览器为例，当打开浏览器就会创建一个主进程，每打开一个`tab`就会再创建一个子进程。这个子进程管理每个页面。而在这个子进程中又有若干线程，例如：UI线程、JS引擎线程、浏览器事件线程 、http请求线程、EventLoop轮询处理线程等。\n\n### JavaScript单线程\n\n上面提到的`JS引擎线程`就是运行`JavaScript`代码的那个线程。所以说JavaScript是单线程的，其实更加准确地说，应该是`JavaScript`的`runtime`是单线程的。\n\nWhy?\n\n这是由`JavaScript`的用途决定的。`JS`最初是被设计成浏览器脚本语言\n\n如果设计成多线程的话，多个线程同时访问或修改dom的话，就乱套了，这时必须引入**锁**了，这对脚本语言来说没有必要。\n\n### Web Worker\n\n`H5`的`Web Worker`标准可以让主线程创建子线程，但它并未违背`JavaScript`设计初衷，应为它对子线程有很多限制：\n\n1. 子线程完全由主线程控制\n2. 子线程不能操作DOM\n\n更多`Web Worker`信息，请查看[阮一峰网络日志](http://www.ruanyifeng.com/blog/2018/07/web-worker.html)\n\n## 同步任务和异步任务\n\n### 单线程的问题\n\n已经明确了`javascript`是一门单线程的语言。\n\n但是单线程会面临一个问题：\n\n我们的代码时一行一行地执行，当前面的没有执行完，后面地就需要等待。\n\n如果程序中间有个请求接口代码块，那么当接口没有返回内容，后面地代码就需要一直等待。这时整个线程是卡死的。\n\n这显然不行，`JavaScript`引入了**同步任务**和**异步任务**的概念来解决这个问题。\n\n### EventLoop\n\n![同步任务和异步任务](../../images/JavaScript/同步任务和异步任务.webp)\n\n同步任务就是需要立即执行的任务，它没执行完后面的需要等待\n\n异步任务就是不需要立即执行的任务，比如ajax接口请求、`setTimeout`等。如果是异步任务就会在`Event Table`中注册，当指定的事件完成之后（例如接口返回响应了），就将其回调函数放到`Event Queue`中\n\n当主线程内的同步任务全部执行完毕后，会去读`Event Queue`中的函数，放入主线程执行。\n\n上述过程会一直重复执行，而这个过程被称为`Event Loop`。\n\n## 宏任务和微任务\n\n同步任务和异步任务是广义上的划分。而宏任务(`macro task`)和微任务(`micro task`)是更为精细的划分\n\n### 划分\n\n宏任务：\n\n| #                       | 浏览器 | Node |\n| :---------------------- | :----: | :--: |\n| `main script`           |   ✅    |  ✅   |\n| `I/O`                   |   ✅    |  ✅   |\n| `setTimeout`            |   ✅    |  ✅   |\n| `setInterval`           |   ✅    |  ✅   |\n| `setImmediate`          |   ❌    |  ✅   |\n| `requestAnimationFrame` |   ✅    |  ❌   |\n\n微任务：\n\n| #                            | 浏览器 | Node |\n| :--------------------------- | :----: | :--: |\n| `process.nextTick`           |   ❌    |  ✅   |\n| `MutationObserver`           |   ✅    |  ❌   |\n| `Promise.then catch finally` |   ✅    |  ✅   |\n\n微任务是属于宏任务的，换句话说，一个宏任务可以包含多个微任务\n\n### 执行流程\n\n以浏览器为例，由两个任务队列，**宏任务队列**存放宏任务；**微任务队列**存放微任务\n\n`main script`也就是`script`标签里的代码是第一个宏任务。存放至宏任务队列\n\n当第一次Event Loop时，检查两个队列，首先检查微任务队列（微任务的优先级比宏任务高）发现没有任务；再去检查宏任务队列，发现有任务`main script`取出执行。\n\n`main script`里有可能又有宏任务和微任务，再分别放入相应队列。\n\n### 几个API\n\n#### setImmediate\n\n这个API是`nodejs`独有的，表示在一次`Event Loop`执行完毕后调用\n\n#### process.nextTick\n\n这个API也是`nodejs`独有的，他会将注册的回调函数插入当前微任务队列的队首。\n\n```javascript\nprocess.nextTick(() => console.log(1));\nPromise.resolve().then(() => console.log(2));\nprocess.nextTick(() => console.log(3));\nPromise.resolve().then(() => console.log(4));\nconsole.log(5);\n\n// output: 5 1 3 2 4\n```\n\n#### Promise\n\n`promise`是`es2015`新增的API。提供了强大的异步特性。\n\n`promise`的`executor`是一个同步函数会立即执行，`then`中的回调会被注册为微任务\n\n```javascript\nnew Promise((resolve, reject) => {\n    console.log(1);\n    resolve();\n}).then(() => {\n    console.log(3)\n})\nconsole.log(2)\n\n// output: 1 2 3\n```\n\n#### async/await\n\n`async/await`仅仅影响的是函数内的执行，而不会影响到函数体外的执行顺序。\n\n```javascript\nasync function async1() {\n    console.log(\"async1 start\");\n    await  async2();\n    console.log(\"async1 end\");\n}\n\nasync  function async2() {\n    console.log('async2');\n}\n\nconsole.log(\"script start\");\n\nsetTimeout(function () {\n    console.log(\"settimeout\");\n},0);\n\nasync1();\n\n// output: \n// script start\n// async1 start\n// async2\n// async1 end\n// settimeout\n```\n\n`await async2()`相当于执行一个`Promise`，`console.log('async2');`属于`executor`；`awaait`后面的内容相当于`then`，会被放入微任务队列。\n\n## 综合试题\n\n在网上找到这么一道综合题：\n\n```javascript\nasync function async1() {\n    console.log(\"async1 start\");\n    await  async2();\n    console.log(\"async1 end\"); // async1 end\n}\nasync  function async2() {\n    console.log('async2');\n}\nconsole.log(\"script start\");\n\nsetTimeout(function () { // setTimeout1\n    console.log(\"settimeout\");\n});\nasync1()\nnew Promise(function (resolve) {\n    console.log(\"promise1\");\n    resolve();\n}).then(function () {  // promise then\n    console.log(\"promise2\");\n});\nsetImmediate(()=>{ // setImmediate\n    console.log(\"setImmediate\")\n})\nprocess.nextTick(()=>{ // nextTick\n    console.log(\"process\")\n})\nconsole.log('script end'); \n```\n\n分析：\n\n1. 输出`script start`，setTimeout1放入宏任务队列\n   1. 宏任务队列：[setTimeout1]\n   2. 微任务队列：[]\n2. 执行async1，输出`async1 start`，执行async2，输出`async2`;将`async1 end`放入微任务队列\n   1. 宏任务队列：[setTimeout1]\n   2. 微任务队列：[async1 end]\n3. 执行Promise的`executor`，输出`promise1`；将`promise then`放入微任务队列\n   1. 宏任务队列：[setTimeout1]\n   2. 微任务队列：[async1 end, promise then]\n4. 遇到setImmediate，将`setImmediate`放入宏任务队列\n   1. 宏任务队列：[setTimeout1， setImmediate]\n   2. 微任务队列：[async1 end, promise then]\n5. 遇到process.nextTick，将`nextTick`放入微任务队列队首\n   1. 宏任务队列：[setImmediate, setTimeout1]\n   2. 微任务队列：[nextTick ,async1 end, promise then]\n6. 输出`script end`\n7. 先依次取出微任务队列的任务执行，输出：`process`、`async1 end`、`promise2`\n8. 然后依次取出所有宏任务执行，输出：`settimeout`、`setImmediate`\n\n## 异步是怎么实现的\n\n根据上文可以了解到。在浏览器中，通过线程切换来实现异步。\n\n`nodejs`也是类似。它依赖于`libuv`模块。`libuv`通过线程池来实现异步操作\n\n","tags":["javascript","nodejs","browser"],"categories":["JavaScript"]},{"title":"Webpack-问题梳理","url":"/posts/378e5729.html","content":"\n## Webpack与其它构建工具有何不同？\n\n### 与Gulp和Grunt\n\n1. `Gulp`和`Grunt`打包的思路是： **遍历源文件**→**匹配规则**→**打包** （打包的文件指定的），`webpack`是按照模块的**依赖关系**进行打包\n2. webpack解决了模块化的问题，而`Gulp`和`Grunt`没有  \n\n### 与rollup\n\n1. rollup最先提出`tree shaking`，webpack也已经支持\n2. rollup不支持`code split`和`dynamic import`\n3. 经验法则：库使用`rollup`构建，应用使用`webpack`构建\n\n## Webpack 的有几种使用方法？\n\n### 通过`webpack-cli`和`npm script`，\n\n```json\n{\n    \"script\": {\n        \"dev\": \"webpack --mode development ./src/es/index.js --module-bind js=babel-loader\",\n        \"build\": \"webpack --mode production ./src/es/index.js --module-bind js=babel-loader\" \n    }\n}\n```\n\n### 编程式调用\n\n```javascript\nconst { webpack } = require('webpack')\n\nconst config = getWebpackConfig() // 生成配置文件\nconst compiler = webpack(config)\ncompiler.run()\n```\n\n## Webpack配置文件有几种写法\n\nwebpack不仅支持`javascript`还支持`Typescript`、`CoffeeScript`\n\n### 函数\n\n```javascript\nmodule.exports = (env, argv) => {\n    return { // 必须返回一个对象\n        entry: {\n            main: './src/index.js'\n        },\n        mode: env.production ? 'production' : 'development',\n        plugins: []\n    }\n}\n```\n\n`env`和`argv`两个参数对应这`webpack-cli`选项\n\n> 适用场景： 需要通过一个配置文件来区分生产环境（production）和开发环境（development），\n\n### Promise\n\n```javascript\nmodule.exports = () => {\n    return new Primise((resolve, reject) => {\n        // 处理操作\n        setTimeout(() => {\n            resolve({\n                entry: './src/index.js',\n            })\n        })\n    })\n}\n```\n\n> 适用场景：需要异步加载一些 Webpack 配置需要做的变量\n\n### 数组\n\n```javascript\nmodule.exports = [{\n\toutput: {\n      filename: './dist-amd.js',\n      libraryTarget: 'amd'\n    },\n    entry: './app.js',\n    mode: 'production',\n  }, {\n    output: {\n      filename: './dist-commonjs.js',\n      libraryTarget: 'commonjs'\n    },\n    entry: './app.js',\n    mode: 'production',\n  }]\n```\n\n数组中的每个元素为一个配置对象，所有的配置对象都会构建。\n\n> 适用场景：打包库，既想打包成`AMD` 又想 打包成 `CommonJS`\n\n### 单个配置对象\n\n最常用\n\n## 如何指定库打包出来的规范？\n\n`output.library`可以指定库打包出来的名称，支持占位符如`[name]`\n\n`output.libraryTarget`可以指定库打包出来的规范，取值范围为：`var`、`assign`、`this`、`window`、`global`、`commonjs`、`commonjs2`、`commonjs-module`、`amd`、`umd`、`umd2`、`jsonp`，默认是`var`\n\n### Webpack能够构建出哪些程序？\n\n`target`：可以指定构建目标，取值有以下几种：\n\n1. `web`： 默认，编译为类浏览器环境里可用；\n2. `node`：编译为类 Node.js 环境可用（使用 Node.js require 加载 chunk）；\n3. ` async-node`：编译为类 Node.js 环境可用（使用 fs 和 vm 异步加载分块）； \n4. `electron-main`：编译为 Electron 主进程； \n5. `electron-renderer`：编译为 Electron 渲染进程； \n6. `node-webkit`：编译为 `Webkit `可用，并且使用 jsonp 去加载分块。支持 Node.js 内置模块和 nw.gui 导入（实验\n   特性）；\n7.  `webworker`：编译成一个 `WebWorker`。\n\n##  Webpack有几种hash？有什么区别？\n\n1. `[hash]`：是整个项目 整个项目的 hash 值，其根据每次编译内容计算得到，每次编译之后都会生成新的 hash，即修改任 何文件都会导致所有文件的 hash 发生改变；在一个项目中虽然入口不同，但是 hash 是相同的；hash 无法实现 前端静态资源在浏览器上长缓存，这时候应该使用 `chunkhash`；\n2. ` [chunkhash]`：根据不同的入口文件（entry）进行依赖文件解析，构建对应的 chunk，生成相应的 hash；只要组成 entry 的模块文件没有变化，则对应的 hash 也是不变的，所以一般项目优化时，会将公共库代码拆分到一 起，因为公共库代码变动较少的，使用 chunkhash 可以发挥最长缓存的作用； \n3. `[contenthash]`：使用 `chunkhash `存在一个问题，当在一个 JS 文件中引入了 CSS 文件，编译后它们的 hash 是 相同的。而且，只要 JS 文件内容发生改变，与其关联的 CSS 文件 hash 也会改变，针对这种情况，可以把 CSS 从 JS 中使用`mini-css-extract-plugin` 或 `extract-text-webpack-plugin`抽离出来并使用 `contenthash`。\n\n## Webpack支持几种SourceMap？\n\n`devtool`：用来配置`sourceMap`，取值如下\n\n| devtool                        | 构建速度 | 重新构建速度 | 生产环境 | 品质(quality)          |\n| :----------------------------- | :------- | :----------- | :------- | :--------------------- |\n| 留空，none                     | +++      | +++          | yes      | 打包后的代码           |\n| eval                           | +++      | +++          | no       | 生成后的代码           |\n| cheap-eval-source-map          | +        | ++           | no       | 转换过的代码（仅限行） |\n| cheap-module-eval-source-map   | o        | ++           | no       | 原始源代码（仅限行）   |\n| eval-source-map                | –        | +            | no       | 原始源代码             |\n| cheap-source-map               | +        | o            | no       | 转换过的代码（仅限行） |\n| cheap-module-source-map        | o        | -            | no       | 原始源代码（仅限行）   |\n| inline-cheap-source-map        | +        | o            | no       | 转换过的代码（仅限行） |\n| inline-cheap-module-source-map | o        | -            | no       | 原始源代码（仅限行）   |\n| source-map                     | –        | –            | yes      | 原始源代码             |\n| inline-source-map              | –        | –            | no       | 原始源代码             |\n| hidden-source-map              | –        | –            | yes      | 原始源代码             |\n| nosources-source-map           | –        | –            | yes      | 无源代码内容           |\n\n> 一般在实际项目中，推荐生产环境不使用或者使用`source-map` （如果有 Sentry 这类错误跟踪系这类错误跟踪系统），开发环境使用 `cheap-module-eval-source-map`\n\n## 解释一下`bundle`、`chunk`和`module`\n\n`module`: 开发中每一个文件都可以看做 module，模块不局限于 js，也包含 css、图片等 \n\n`chunk`: 代码块，一个 chunk 可以由多个模块组成\n\n`bundle`: 最终打包完成的文件，一般就是和 chunk 一一对应的关系，bundle 就是对 chunk 进行压缩打包等处理后的产出 \n\n##  Webpack中loader如何使用？以及loader的执行顺序\n\n### 如何使用\n\n1. 在配置文件中配置\n2. 内联配置方式`const html = require('html-loader!./loader.html');` 或者`import html from 'html-loader!./loader.html';`\n\n### 执行顺序\n\n从右到左，从下到上\n\n## Webpack如何实现按需加载？什么是魔法注释？\n\nwebpack中通过`import`函数实现按需加载，也被称为动态导入(`dynamic import`)，\n\n1. 该函数返回`Promise`\n2. 导入的文件被打包到单独的文件中，具体得看`splitChunk`配置\n\n魔法注释：\n\n`webpackInclude`：如果是 import 的一个目录，则可以指定需要引入的文件特性，例如只加载 json 文件：`/\\.json$/`\n\n`webpackExclude`：如果是 import 的一个目录，则可以指定需要过滤的文件，例如 `/\\.noimport\\.json$/`； \n\n`webpackChunkName`：这是 chunk 文件的名称，例如 lazy-name； \n\n`webpackPrefetch`: 是否预取模块，及其优先级，可选值true、或者整数优先级别，0 相当于 true，webpack 4.6+支持；\n\n` webpackPreload` 是否预加载模块，及其优先级，可选值true、或者整数优先级别，0 相当于 true，webpack 4.6+支持； \n\n`webpackMode`: 可选值lazy/lazy-once/eager/weak。\n\n```javascript\nimport(/* webpackChunkName: \"image\", webpackInclude: /\\.(png|jpg|gif)/ */ './assets/img'); \n```\n\n## Babel的最佳实践\n\n`@babel/preset-env`搭配`useBuiltIns: \"usage\"`实现真正的按需加载。需要转换的地方会自动转换\n\n```javascript\n// babel.config.js\nmodule.exports = function(api) {\n  api.cache(true)\n\n  const presets = [\n    [\n      '@babel/preset-env',\n      {\n        modules: false,\n        corejs: 3, // 指定corejs 的版本\n        useBuiltIns: 'usage',\n      },\n    ],\n  ]\n  const plugins = []\n\n  return {\n    presets,\n    plugins,\n  }\n}\n```\n\n> `moudles`指定将`ES module `转换成其它模块规范，可能取值有 `\"amd\" | \"umd\" | \"systemjs\" | \"commonjs\" | \"cjs\" | \"auto\" | false`；false表示不去转换\n>\n> 强烈建议`false`，否则会影响`Webpack`进行优化（`Tree Shaking`必须基于`ES moudle`）\n\n## Babel原理\n\nBabel的语法转换过程主要经历三个步骤：\n\n1. 解析（Parse）：对JavaScrpt代码解析**词法语法分析**，最终生成一个`AST`。用的是`@babel/parser`\n2. 转换（Transform）：对`AST`进行遍历，在这过程中可以进行添加、删除和修改等操作。用的是`@babel/traverse`\n3. 生成（Generate）：转换后得到一棵新树，然后将树转换成代码，用的是`@babel/generator`\n\n![Babel处理过程](../../images/Babel处理过程.png)\n\n## 如何编写一个Babel插件\n\nBabel在转换阶段会遍历`AST`，那么Babel插件就是在这个过程中编写`visitor`\n\n```javascript\n// babel plugin demo\nexport default function({ types: t }) {\n    return {\n      visitor: {\n          Identifier(path, state) {},\n          FunctionDeclaration(path, state) {},\n          BinaryExpression(path, state) {},\n      }\n    };\n};\n```\n\n `type` 字段表示遍历时每个节点的类型（如： `\"FunctionDeclaration\"`，`\"Identifier\"`，或 `\"BinaryExpression\"`）\n\n遍历过程中每当在树中遇见一个 `Identifier` 的时候会调用 `Identifier()` 方法。\n\n`Identifier(path, state) {}`代表进入节点时触发\n\n```javascript\nexport default function({ types: t }) {\n\treturn {\n      visitor: {\n          Identifier: {\n              enter(path, state) {},\n              exit(path, state) {}, // 退出时触发\n          },\n      }\n    };\n};\n```\n\n> 关于Babel插件详细写法，请查阅[文档](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md)\n>\n> 编写Babel插件需要熟悉`AST`结构，可以借助[AST Exploer](https://astexplorer.net/)来学习AST\n\n## Babel如何针对不同浏览器做适配\n\n`Browserslist`用来指定适配的浏览器的工具，`Babel`和`Postcss`等工具都会使用`Browserlist`。\n\n在项目根目录创建`.browserslistrc`文件，写入以下内容\n\n```text\nlast 2 version\n> 1%\nnot ie <= 11\nnot dead\n```\n\n可以在[browserl.ist](https://browserl.ist/)上检查所支持的浏览器列表\n\n![Browserslist](../../images/Browserslist.png)\n\n## Webpack中如何增强CSS功能\n\n### CSS Module\n\n`css`都是全局的，也就是说一个文件的样式可能被另一个文件的`css`样式污染。以前常用解决方法就是采用`BEM`规范，但是规范总会有人不遵守。`css module`能很好解决这个问题。\n\n`css module`顾名思义，就是给让`css`模块化。主要解决问题有：\n\n1. 解决 CSS 类都是全局的，容易造成全局污染（样式冲突）\n2. JS 和 CSS 共享类名，即JS 可以直接使用 CSS 的类名作为对象值\n3. 可以方便的编写出更加健壮和扩展方便的 CSS。\n\n```jsx\n// react\nimport style from './style.css'\n\nexport function Home() {\n    return <div style={style.box}>Hello</div>\n}\n```\n\n```vue\n<!-- vue -->\n<template>\n  <p :class=\"$style.red\">\n    This should be red\n  </p>\n</template>\n\n<style module>\n.red {\n  color: red;\n}\n.bold {\n  font-weight: bold;\n}\n</style>\n```\n\n开启方法：`css-loader` 增加 `modules: true` 的选项\n\n```javascript\nmodule.exports = {\n    //...\n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: [\n                    {\n                        loader: 'css-loader',\n                        options: {\n                            modules: true\n                        }\n                    }\n                ]\n            }\n        ]\n    }\n}\n```\n\n### CSS预处理器\n\n`css预处理器`就是在css本身的基础上，增强了语法。增加了循环、条件判断、运算、函数以及作用域等\n\n常见的`css预处理器`有：`sass(scss)`、`less`、`stylus`\n\n### PostCSS\n\n`Postcss`是一个类似`Babel`的工具，只不过`Postcss`处理的是css文件。\n\n`Postcss` 核心是将 CSS 解析成 AST，然 后通过各种插件做各种转换，最终生成处理后的新 CSS，跟 Babel 在功能和实现上都类似。\n\n在`Webpack`中使用需要安装`postcss-loader`\n\n配置方法：在项目根目录新建一个`postcss.config.js`文件，写入配置内容，如下\n\n```javascript\nconst postcssPresetEnv = require('postcss-preset-env')\nconst postcssImport = require('postcss-import')\n\nmodule.exports = {\n  plugins: [\n      postcssPresetEnv({ autoprefixer: { grid: true }}),\n      postcssImport()\n  ],\n}\n\n```\n\n`postcss`和`babel`一样都有自己的插件系统。\n\n1. `postcss-preset-env`是`postcss`常用的插件集合，具体特性请查阅[文档](https://preset-env.cssdb.org/)\n2. `postcss-import`是让`postcss`规则作用的`@import`的CSS文件。\n\n2. 常用的还有一个[postcss-px-to-viewport](https://github.com/evrone/postcss-px-to-viewport)插件，用来将`px`转成`vw`，在移动端上比较常用。\n\n## Webpack如何打包多页面？\n\n`Wepack`实现多页面打包需要通过`html-webpack-plugin`来实现\n\n```javascript\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\n\nmodule.exports = {\n    entry: {\n        index: './src/main.js',\n        post: './src/post.js'\n    },\n    plugins: [\n        new HtmlWebpackPlugin({\n            template: './public/index.html',\n            filename: 'index.html',\n            chunks: ['index']\n        }),\n        new HtmlWebpackPlugin({\n            template: './public/post.html',\n                filename: 'post.html',\n            chunks: ['post']\n        }),\n    ]\n}\n```\n\n注意:\n\n1. 需要打包几个页面就增加几个`HtmlWebpackPlugin实例`\n2. `chunks`指定当前页面包含那些chunk\n3. 还可以使用`excludeChunks`来排除不需要的`chunk`\n4. 使用`webpack-dev-server`时，通过http://ip:port/index访问`index`页面；通过http://ip:port/index/post访问`post`页面\n\n## 解释一下`webpack-dev-server`的原理\n\n- `webpack-dev-server`是一个基于`express`的本地服务器。\n\n- 它通过`webpack-dev-middleware`中间件来为`webpack`打包生成的资源文件提供web服务。\n\n- 同时还将开启一个`websocket`连接来实现热更新。\n\n## `webpack-dev-server`的最佳实践\n\n### 热更新\n\n1. 配置`devServer.hot`为`true`；配置`devServer.inline`为true（默认）。这会在`entry`中添加相应代码\n2. 增加`webpack.HotModuleReplacementPlugin`这个`plugin`\n\n> 如果使用`webpack-cli`，直接加上`--hot`就自动实现上面两步\n\n### proxy\n\n`devServer.proxy`可以实现本地跨域问题\n\n```javascript\nmodule.exports = {\n    devServer: {\n        proxy: {\n            '/api': {\n                target: 'http://ip:port', // 所有请求路径包含/api的请求，都会被转发到这个地址\n                pathRewrite: {'^/api', ''}\n            }\n        }\n    }\n}\n```\n\n### 自定义中间件\n\n在 `webpack-dev-server` 中有两个时机可以插入自己实现的中间件，分别是 `devServer.before` 和 `devServer.after `，即` webpack-dev-server `加载所有内部中间件之前和之后两个时机。通常用来实现`mockServer`\n\n```javascript\nmodule.exports = {\n    devServer: {\n        before(app, server) {\n            app.get('/api/get-use-info', (req, res) => {\n                res.json({name: 'zxffan', gender: 'male'})\n            })\n        }\n    }\n}\n```\n\n### Gzip\n\n将`devServer.compress`设置成`true`\n\n### 常用API\n\n- `devServer.historyApiFallback`：配置如果找不到页面就默认显示的页面；\n- `devServer.compress`：启用 gzip 压缩；\n- `devServer.hotOnly`：启用热更新，并且构建失败的时候不会刷新网页；\n- `devServer.inline`：模式切换，默认为内联模式，使用`false`切换到 iframe 模式；\n- `devServer.open`：启动后，是否自动使用浏览器打开首页；\n- `devServer.openPage`：启动后，自动使用浏览器打开指定的页面；\n- `devServer.overlay`：是否允许使用全屏覆盖的方式显示编译错误，默认不允许；\n- `devServer.port`：监听端口号，默认 8080；\n- `devServer.host`：指定 host，使用`0.0.0.0`可以让局域网内可访问；\n- `devServer.contentBase`：告诉服务器从哪里提供内容，只有在你想要提供静态文件时才需要；\n- `devServer.publicPath`：设置内存中的打包文件的虚拟路径映射，区别于`output.publicPath`；\n- `devServer.staticOptions`：为 `Expressjs` 的 `express.static`配置参数，[参考文档]( http://expressjs.com/en/4x/api.html#express.static)\n- `devServer.clientLogLevel`：在 inline 模式下用于控制在浏览器中打印的 log 级别，如`error`, `warning`, `info` or `none`；\n- `devServer.quiet`：静默模式，设置为`true`则不在控制台输出 log；\n- `devServer.noInfo`：不输出启动 log；\n- `devServer.lazy`: 不监听文件变化，而是当请求来的时候再重新编译；\n- `devServer.watchOptions`：watch 相关配置，可以用于控制间隔多少秒检测文件的变化；\n- `devServer.headers`：自定义请求头，例如自定义 userAgent 等；\n- `devServer.https`：https 需要的证书签名等配置。\n\n## Webpack优化——如何减小打包后的文件体积\n\n打包后的文件主要分为三类——`js`、`css`和`其它静态资源文件（图片等）`\n\n### 如何减小JS文件体积\n\n1. 压缩代码：使用[terser-webpack-plugin](https://www.npmjs.com/package/terser-webpack-plugin)对`es moudule`的代码进行压缩\n2. `tree shaking`，代码需要遵循`es module`\n3. 合理设置`splitChunk`拆分逻辑\n4. 第三方库按需引入\n5. 使用`scope hoisting`\n\n> webpack的`mode`设置为`production`时，webpack就会自动做一些通用的优化配置\n\n配置如下\n\n```javascript\nconst TerserWebpackPluin = require('terser-webpack-plugin')\n\nmodule.exports = {\n    // ...\n    \n    mode: 'production',\n    \n    optimization: {\n        concatenateModules: true, // 开启 scope hoisting(mode为production会自动开启)\n        minimize: true,\n        minimizer: [\n            new TerserWebpackPluin({\n                test: /\\.js(\\?.*)?$/i,\n                include: /src/,\n                //exclude\n                cache: true, // 开启缓存\n                parallel: true, // 默认true 开启多线程\n                terserOptions: {\n                    compress: {\n                        unused: true, // 删除无用的代码 \n                        drop_debugger: true, // 删掉 debugger \n                        drop_console: true, // 移除 console \n                        dead_code: true, // 移除无用的代码\n                    }\n                }\n            })\n        ]\n    }\n}\n```\n\n### 如何减小CSS文件体积\n\n1. 压缩代码：使用`cssnao`(`postcss` 插件)来进行代码压缩，其实`css-loader`已经集成了`cssnano`\n2. 抽离CSS：通过`mini-css-extract-plugin`将CSS内容抽离到CSS文件中\n\n配置内容如下\n\n```javascript\nconst MiniCssExtractPlugin = require('mini-css-extract-plugin')\n\nmodule.exports = {\n    // ...\n    \n    module: {\n        rules: [\n            {\n                test: /\\.css$/,\n                use: [\n                    'style-loader',\n                    MiniCssExtractPlugin.loader,\n                    {\n                        loader: 'css-loader',\n                        options: {\n                           \tminimize: {/* CSSNano Options */}\n                        }\n                    }\n                ]\n            }\n        ]\n    },\n    plugins: [\n        new MiniCssExtractPlugin({\n            filename: '[name].css',\n        })\n    ]\n}\n```\n\n### 如何处理图片等静态资源\n\n1. `url-loader`可以将小图片转成`Data URL`内联到JS中，从而减少请求数量\n2. 对于`svg`，使用`svg-url-loader`\n\n```javascript\nmodule.exports = {\n    module: {\n        rules: [\n            {\n                test: /\\.(png|jpg|jpeg)$/,\n                use: [\n                    {\n                        loader: 'url-loader',\n                        options: {\n                            limit: 100, //单位kb，小于这个大小的会被转成Data URL\n                        }\n                    }\n                ]\n            }\n        ]\n    }\n}\n```\n\n\n\n## Webpack优化——如何利用缓存\n\n主要思路就是，将项目中不太容易变化的代码（比如第三方库vue、react）单独抽离出来，利用`CDN`或配置浏览器缓存以减少对其的请求。\n\n### 如何拆分出来（`Code Splitting`）\n\n1. 配置多个entry\n2. 使用`dynamic import`和`split chunk`来拆分代码\n3. 使用`external`不打包这些一些第三方库，然后通过`cdn`引入\n\n特别说一下`split chunk`，以下时默认配置\n\n```javascript\nmodule.exports = {\n    // ...\n    optimization: {\n        splitChunks: {\n            chunks: 'async', // 三选一： \"initial\" | \"all\" | \"async\" (默认)\n            minSize: 30000, // 最小尺寸，30K，development 下是10k，越大那么单个文件越大，chunk 数就会变少（针对于提取公共 chunk 的时候，不管再大也不会把动态加载的模块合并到初始化模块中）当这个值很大的时候就不会做公共部分的抽取了\n            maxSize: 0, // 文件的最大尺寸，0为不限制，优先级：maxInitialRequest/maxAsyncRequests < maxSize < minSize\n            minChunks: 1, // 默认1，被提取的一个模块至少需要在几个 chunk 中被引用，这个值越大，抽取出来的文件就越小\n            maxAsyncRequests: 5, // 在做一次按需加载的时候最多有多少个异步请求，为 1 的时候就不会抽取公共 chunk 了\n            maxInitialRequests: 3, // 针对一个 entry 做初始化模块分隔的时候的最大文件数，优先级高于 cacheGroup，所以为 1 的时候就不会抽取 initial common 了\n            automaticNameDelimiter: '~', // 打包文件名分隔符\n            name: true, // 拆分出来文件的名字，默认为 true，表示自动生成文件名，如果设置为固定的字符串那么所有的 chunk 都会被合并成一个\n            cacheGroups: {\n                vendors: {\n                    test: /[\\\\/]node_modules[\\\\/]/, // 正则规则，如果符合就提取 chunk，\n                    test(module, chunks) { // 还可以是函数\n                        return module.type === 'javascrtipt/auto'\n                    },\n                    priority: -10 // 缓存组优先级，当一个模块可能属于多个 chunkGroup，这里是优先级\n                },\n                default: {\n                    minChunks: 2,\n                    priority: -20, // 权重，如果有一个模块满足了多个缓存组的条件就会去按照权重划分，谁的权重高就 优先按照谁的规则处理。\n                    reuseExistingChunk: true // 如果该chunk包含的modules都已经另一个被分割的chunk中存在，那么直接引用已存在的chunk，不会再重新产生一个\n                }\n            }\n        }\n    }\n};\n```\n\n`chunks`有三个值`initial`、`all`和`async`(默认)\n\n1. `chunks`为`async`：只有`dynamic import`才会被拆分出去\n2. `chunks`为`initial`：`dynamic import`肯定会被拆分出去，符合`cacheGroup`规则并且体积大于`minSize`也会被拆分出去（无论是否`dynamic import`）;但是非动态导入和动态导入的公共部分没有拆分在一起，而在单独拆分成不同的chunk\n3. `chunks`为`all`（推荐）：非动态导入和动态导入的公共部分会拆分在一起（符合cacheGroup规则）\n\n`cacheGroup`(缓存组)配置了拆分逻辑。\n\n### 如何设置缓存\n\n`CDN`没什么好说的，直接再HTML中引入即可。\n\n对于浏览器缓存，当浏览器请求这些资源时，服务端设置`Cache-Control`响应头，比如`Cache-Control: max-age=31536000`，表示当前资源缓存一年（31536000=360024365）。只要一年内该资源不发生变化就会一直从缓存中读取。\n\n## Webpack优化——如何加快打包速度\n\n1. 配置路径别名——`resolve.alias`，以减少目录查找次数\n2. 增加默认文件后缀名——`resolve.extensions`\n3. 排除不需要解析的模块\n   1. `module.noParse`，例如`noParse: /node_modules\\/jquery.js/`。忽略对部分没采用模块化的文件递归解析处理，例如：jQuery、 ChartJS，它们体积庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义\n   2. `module.rules`中配置合适的`include`和`exclude`。\n4. 利用多线程：`thread-loader`和`happypack`(已经不维护了)\n5. `webpack`的`DllPlugin`和`DllReferencePlugin`，将一些不会变化的内容抽离出来，并且避免二次打包。\n6. 缓存`Cache`：很多`loader`都提供了缓存机制\n   1. `babel-loader`：设置`cacheDirectory:true`将会开启缓存\n7. 换用高性能的loader或插件\n   1. sass：使用`fast-sass-loader`代替`sass-loader`\n\n重点说一下`DllPlugin`和`DllReferencePlugin`：\n\n`DllPlugin`可以将第三方库单独打包到一个`bundle`中，还会生成一个`manifest.json`文件\n\n`DllReferencPlugin`读取这个`manifest.json`文件，在打包过程中就不会将之前抽离内容打包进来\n\n\n\n```javascript\n// webpack.config.dll.js\nconst { DllPlugin } = require('webpack')\n\nmodule.exports = {\n    // ...\n    mode: 'production',\n    entry: {\n        vendor: ['vue', 'vue-router', 'vuex'] // 将这些第三方库抽离出来\n    },\n    \n    output: {\n        filename: 'dll/[name][chunkhash].js',\n        library: '[name][chunkhash]',\n        path: './dist'\n    },\n    \n    plugins: [\n        new DllPlugin({\n            path: 'dll/manifest.json', // 设置manifest.json的路径\n            name: '[name]_[chunkhash]',\n            context: __dirname\n        })\n    ]\n}\n```\n\n使用`webpack.config.dll.js`打包一次，将`vue`、`vuex`和`vue-router`打包出来。生成`vender[hash].js`和`manifest.json`\n\n然后配置`webpack.config.js`\n\n```javascript\nconst { DllReferencePlugin } = require('webpack')\nconst manifest = require('./dll/manifest.json')\n\nmodule.exports = {\n    entry: {\n        main: './src/index.js'\n    },\n    output: {\n        filename: '[name][chunkhash].js'\n    },\n    plugin: [\n        new DllReferencePlugin({\n            context: __dirname\n            manifest // 配置manifest\n        })\n    ]\n}\n```\n\n打包最后生成的`main.js`中不会包含`vendor`里的内容。\n\n> webpack5提出了`federal module`（联邦模块）；也可以提取公共模块\n\n## 解释一下Webpack中`Tree-shaking`原理？\n\n基于`ES module`做静态分析，在编译阶段就能分析出其模块依赖关系（无需等到运行时）。然后利用`uglifyjs`或`terser-webpack-plugin`来删除多余内容\n\n`tree shaking`的注意点：\n\n1. 必须使用`es module`规范\n2. 不支持对`class`的`tree shaking`\n3. 减少副作用，具有副作用的代码不会被消除\n\n> 纯函数：对于相同的输入就有相同的输出，不依赖外部环境，也不改变外部环境。\n>\n> 非纯函数被称为具有副作用的函数\n>\n> 1. 确保代码中没有副作用\n> 2. 在`package.json`中配置`sideEffects: [\"./src/side_effect.js\"]`(指定具有副作用的内容)或者`sideEffects:false`（完全没有副作用），这样webpack就会跳过副作用的代码\n\n## Checklist\n\n### 配置文件管理\n\n`npm script`配置脚本命令，例如`node ./scripts/dev.js`\n\n使用编程式API，而不采用`webpack-cli`（个人习惯）\n\n拆分配置文件：开发环境，生产环境等\n\n`scripts`目录下有一个`config`目录用来存放各个环境的配置文件\n\n### 合理的拆分\n\n合理设置`splitchunks`、`DDLPlugin`或`Federal Module`，太细不利于缓存，太粗又会影响加载速度。，\n\n拆分原则：\n\n1. 变更频率小的部分拆分出来（例如第三方库）\n2. 公共部分拆分出来\n3. 按照路由拆分\n\n### Hash\n\n1. JavaScript 文件使用：`[chunkhash]`；\n2. CSS 文件使用：`[contenthash]`；\n3. 其他静态资源用：`[hash]`，例如图片、字体等，在`url-loader`中配置`[hash]`\n\n### code规范\n\n1. 必须使用`ES Module`，方面`Tree-Shaking`，注意副作用代码\n2. 合理使用`webpack magic comments`\n3. 选择符合`es module`规范的第三方库，例如`lodash-es`\n\n## 如何调试Webpack\n\n在`vscode`中打下断点，然后按`F5`，选择`nodejs`（`webpack`是基于node的库）。就可以进行调试\n\n如果需要自定义`debug`，创建`launch.json`文件进一步自定义。","tags":["javascript","webpack","架构"],"categories":["Webpack"]},{"title":"Rust学习笔记-变量&类型&functions&注释&控制流","url":"/posts/452059e7.html","content":"\n本系列文章是笔者学习`Rust`时所做的笔记，供日后翻阅复习。\n\n## 变量和可变性\n\n在`Rust`中定义一个变量很简单：`let x = 100`，但这个`x`时`immutable`（不可变的）\n\n```rust\nfn main() {\n\tlet x = 100;\n\tx = 200; // error\n}\n```\n\n在`Rust`中定义一个可变变量也很简单：`let mut x = 100`，其中的`mut`代表`mutable`\n\n### 常量\n\n在`Rust`中使用`const`来定义一个常量：`const MAX_POINT: u32 = 150_000`\n\n常量即**不变化的量的**，那么**常量**和**`immutable`变量**有什么区别呢？\n\n1. 常量必须显示注明类型。\n2. 常量可以在任何作用域下（包括全局作用域）声明，`let`以及其它代码内容必须在`fucntion`下声明\n3. 常量的值必须是一个常量表达式，不能是函数或其它必须再运行时才能计算出结果的值。\n4. 常量通常定义在全局作用域下，用来避免硬编码问题。\n\n> `Rust`中常量的命名规范：全部大写，用下划线连接\n>\n> `Rust`中的数值：`100_000`代表`100,000`即`100000`\n\n### Shadowing\n\n在`Rust`中允许在同一个作用域下，一个变量被声明两次\n\n```rust\nfn main() {\n    let sentence = \"I heart you!\";\n    let sentence = sentence.len();\n    println!(sentence); // sentence is 12\n}\n```\n\n`sentence`第一次声明为一个`string`；第二次声明变成`number`。可以理解为第一个`sentence`被第二个`sentence`给`shadowed`(隐藏)了。后面访问到的都是第二个。\n\n`Shadowing`最大的好处就是：**第二次声明时可以修改变量类型，可以用于类型转换的场景**\n\n## 数据类型\n\n`Rust`是一门静态类型语言。在编译时`Rust`就必须知道所有数据的类型。\n\n`Rust`中的数据类型分类两种：**标量类型(Scalar Types)**和**复合类型(Compound Types)**\n\n### 标量类型\n\n标量类型有：整型、浮点型、布尔型、字符型\n\n#### 整型\n\n`let x: u32 = 100`，就是定义一个无符号的32位整型\n\n`let x: i32 = 100`，是定义一个带符号的32位整型\n\n| 大小    | 带符号（Signed） | 无符号（Unsigned） |\n| ------- | ---------------- | ------------------ |\n| 8-bit   | `i8`             | `u8`               |\n| 16-bit  | `i16`            | `u16`              |\n| 32-bit  | `i32`            | `u32`              |\n| 64-bit  | `i64`            | `u64`              |\n| 128-bit | `i128`           | `u128`             |\n| arch    | `isize`          | `usize`            |\n\n表示范围：以`16-bit`为例\n\n1. `i16`：带符号，最高位符号位，还剩15位，所以能表示 \n\n$$\n[-2^{15}, 2^{15}-1]\n$$\n\n2. `u16`：不带符号即为非负数，所以能表示\n\n$$\n[0, 2^{16}-1]\n$$\n\n`isize`和`usize`取决于操作系统，如果是64位系统就取64；如果是32位系统就取32。\n\n在`Rust`中可以以多种形式书写整型字面量：\n\n| Number literals  | Example       |\n| ---------------- | ------------- |\n| Decimal          | `98_222`      |\n| Hex              | `0xff`        |\n| Octal            | `0o77`        |\n| Binary           | `0b1111_0000` |\n| Byte (`u8` only) | `b'A'`        |\n\n除了Byte字面量都可以使用**类型后缀（type suffix）**：`let num = 120u32`和`let num:u32 = 120`是一样的\n\n除了Byte字面量都可以使用**`_`视觉分隔符**：`100_000`代表`100,000`即`100000`\n\n> 如果不指定数值类型，Rust默认`i32`\n\n整型溢出：`u8`只能表示`[0,255]`范围的值，当取`256`就会发生溢出\n\n1. `debug`模式下，`Rust`会进行溢出检测，当溢出发生，程序发生`panic`\n2. `release`模式下，`Rust`不会进行检测，`256`会变成`0`;`257`变成`1`。\n\n#### 浮点类型\n\n浮点类型只有两种：`f32`和`f64`(默认)，前者表示**单精度浮点类型**，后者表示**双精度浮点类型**。例如\n\n```rust\nfn main() {\n    let x = 2.1; // f64\n    let x: f32 = 3.1; // f32\n}\n```\n\n与绝大数语言一样，`Rust`的浮点类型也遵循`IEEE-754`标准，所以也存在`0.1 + 0.2`的问题。\n\n#### 布尔类型\n\n布尔类型有两种：`true`和`false`\n\n布尔类型占1个字节\n\n使用`bool`来声明布尔类型，例如\n\n```rust\nfn main() {\n    let isCheck = true;\n    \n    let hasExist: bool = false;\n}\n```\n\n#### 字符类型\n\n`Rust`的字符类型占4个字节，所以能表示很多字符，比如单个中文、日文甚至`emoji`字符\n\n使用**单引号**定义**字符字面量**；使用**双引号**定义字**符串字面量**，例如\n\n```rust\nfn main() {\n    let word = '♥';\n    \n    let sentence = \"I ♥ you!\";\n}\n```\n\n### 复合类型\n\n复合类型有两种：元组和数组\n\n#### 元组\n\n```rust\nfn main() {\n    // 定义元组\n    let tup: (i32, f64, u8) = (500, 6.4, 1);\n    \n    // 也可以省略类型\n    let tup = (500, 6.4, 1);\n\t\n    // 元组可以解构\n    let (x, y, z) = tup;\n    \n    // 使用 元组.index 的方式访问\n    let first = tup.0;\n    let second = tup.1;\n}\n```\n\n#### 数组\n\n```rust\nfn main() {\n    // 定义数组\n    let arr: [i32, i32, i32] = [1, 2, 3];\n    let arr: [i32, 3] = [1, 2, 3];\n    \n    // 数组元素都一样\n    let arr = [1, 1, 1, 1, 1];\n    let arr = [1; 5];\n    \n    // 通过index访问元素\n    let x = arr[0]；\n}\n```\n\n元组与数组的异同点：\n\n相同点：\n\n1. 都是定长的，长度不能变化。如果需要不定长，使用`vector`\n2. 都是数据集合\n\n不同点\n\n1. 数组中每个元素的类型必须相同，而元组可以不一样\n2. 使用方式不一样\n\n## Functions\n\n函数是`Rust`中最为普遍的存在。每个程序都有一个`main`函数作为程序的入口函数。可以通过`fn`关键字来定义函数。\n\n```rust\nfn main() {\n    print_hello(); // 调用函数\n    \n    let result = plus_two(2);\n    println!(\"The result is {}\", result);\n}\n\nfn print_hello() {\n    println!(\"hello\");\n}\n\nfn plus_two(a: i32) -> i32 { // -> 注明函数返回值类型\n    a + 2 // 不加分号表示是表达式，函数体的最后一行如果是表达式默认为函数返回值\n}\n\n```\n\n注意：\n\n1. 函数参数必须注明类型\n2. 有返回值必须注明返回值类型，没有返回值默认返回空元组即`()`\n\n### 语句与表达式(Statements and Expression)\n\n语句(Statements)：执行某种行为，不会有返回值\n\n表达式(Expression)：进行计算并将结果返回\n\n```rust\nfn main() {\n    let x = 123; // 语句，不会返回123\n    \n    let y = { // {} 代表表达式\n        let x = 124; // 语句\n        x + 1 // 表达式\n    }; // y = 125\n}\n```\n\n### 函数返回值\n\n使用`->`来注明函数返回值类型；\n\n返回可以使用`return`关键字；通常，函数会隐含地将最后一个表达式作为函数的返回值。\n\n## 注释\n\n单行注释：`//`\n\n文档注释： `///`：文档注释支持`markdown`语法，用来注释某个函数。当使用`cargo doc`命令时会自动生成`HTMl文件`\n\n## 控制流\n\n与绝大数语言一样，`Rust`也提供了条件判断（if）和循环（loop）来实现程序流的控制。\n\n### if表达式\n\n```rust\nfn main() {\n    let number = 3;\n    if number < 2 {\n        println!(\"less than 2\");\n    } else if number == 2 {\n        println!(\"equal to 2\");\n    } else {\n        println!(\"greater than 2\");\n    }\n}\n```\n\n注意：if 后必须借一个 返回`bool`类型的表达式，不想`JavaScript`会自动做类型转换。\n\n### let语句和if\n\n```rust\nfn main() {\n    let condition = 3 > 2;\n    let number = if condition { 10 } else { 20 }; // 10\n}\n```\n\n花括号`{}`中是一个表达式，最终就返回这个表达式的值\n\n条件分支表达式的值的类型必须一致，上例都是默认的`i32`\n\n### 循环Loops\n\n`Rust`中提供了多种循环方式，有`loop`、`while`以及`for`\n\n#### loop\n\n```rust\nfn main() {\n    let mut times = 1;\n    loop {\n        println!(\"loop times: {}\", times);\n        times += 1;\n        if times > 10 {\n            break;\n        }\n    }\n}\n```\n\n`loop`只有遇到`break`语句才会推出循环\n\n#### loop返回值\n\n在`break`后添加一个表达式，会将表达式的值返回\n\n```rust\nfn main() {\n    let mut counter = 0;\n\t\n    // result 接受值\n    let result = loop {\n        counter += 1;\n\n        if counter == 10 {\n            break counter * 2; // 返回值\n        }\n    };\n\n    println!(\"The result is {}\", result); // 20\n}\n```\n\n#### While\n\n当循环取决于一个条件表达式时可以使用`while`\n\n```rust\nfn main() {\n    let mut num = 0;\n    while num < 5 {\n        println!(\"num is {}\", num);\n        \n        num += 1;\n    }\n}\n```\n\n#### for\n\n当遍历某个集合时可以使用`for`\n\n```rust\nfn main() {\n    let arr = [1, 2, 3, 4];\n    for ele in arr.iter() {\n        println!(\"current is {}\", ele);\n    }\n}\n```\n\n当已知范围时可以使用`for`\n\n```rust\nfn main() {\n    for num in (1..10).rev() {\n        println!(\"{}!\", num);\n    }\n}\n```\n\n`(1..10)`表示一个范围`[1, 9]`\n\n`rev()`表示`reverse`\n\n## 练习\n\n### 转换摄氏度和华氏度\n\n```rust\nfn main() {\n    let temp_f = to_fahrenheit(37.0);\n    let temp_c = to_celsius(98.6);\n\n    println!(\"{}c equal to {}f\", temp_c, temp_f);\n}\n\n// 转换成华氏度\nfn to_fahrenheit(temp: f32) -> f32 {\n    32.0 + temp * 1.8\n}\n\n// 转换成摄氏度\nfn to_celsius(temp: f32) -> f32 {\n    (temp - 32.0) / 1.8\n}\n```\n\n### 生成第n个斐波那契数\n\n```rust\nfn main() {\n    let tenth = get_nth_fibonacci(10);\n    println!(\"The tenth is {}\", tenth);\n}\n\nfn get_nth_fibonacci(n: u32) -> u32 {\n    let result = if n == 1 {\n        0\n    } else if n == 2 {\n        1\n    } else {\n        get_nth_fibonacci(n - 1) + get_nth_fibonacci(n - 2)\n    };\n    result\n}\n```\n\n","tags":["Rust","语言学习"],"categories":["Rust"]},{"title":"Rust学习笔记-环境搭建","url":"/posts/85fd164e.html","content":"\n本系列文章是笔者学习`Rust`时所做的笔记，供日后翻阅复习。\n\n## 安装\n\n`rustup`以用来进行`Rust`版本管理的命令行工具。\n\n### MacOS && Linux\n\n```shell\n$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n```\n\n该命令是用来下载一个脚本然后开始安装`rustup`工具\n\n### Windows\n\n前往[Rust官网](https://www.rust-lang.org/tools/install)下载`exe`安装包\n\n安装过程会提示需要`C++ build tools`。比较简单的办法是安装[`virtual studio`](https://visualstudio.microsoft.com/zh-hans/downloads/)。工作负载中选择`C++桌面开发`。\n\n### rustup常用命令\n\n| 命令        | 命令                                                  | 备注                                           |\n| ----------- | ----------------------------------------------------- | ---------------------------------------------- |\n| `show`      | `rustup show`                                         | 显示已安装的工具                               |\n| `update`    | `rustup update`<br />`rustup  self  update`           | 更新`rust`工具以及`rustup`<br />只更新`rustup` |\n| `check`     | `rustup check`                                        | 检查`rust`工具是否有新版本                     |\n| `default`   | `rustup default stable`<br />`rustup default nightly` | 切换版本                                       |\n| `install`   | `rustup install nightly`                              | 安装`rust`工具                                 |\n| `uninstall` | `rustup uninstall`<br />`rustup self uninstall`       | 删除`rust`工具<br />删除`rust`工具和`rustup`   |\n| `doc`       | `rustup doc`                                          | 查看文档（可以离线使用）                       |\n\n## Hello World\n\n创建`main.rs`，编写代码\n\n```rust\nfn main() {\n    println!(\"Hello, World\")\n}\n```\n\n执行代码：\n\n1. 编译：执行`rustc main.rs`，会生成可执行文件\n2. 执行：`./main` or `./main.exe`(win)\n3. 结果：命令行显示`Hello,World`\n\n## Cargo\n\n`cargo`是`Rust`的项目管理器，提供了一键创建、运行以及build`Rust`项目的命令：\n\n1. `cargo new my_project`: 创建项目\n\n2. `cargo build`: build操作，在`/target/debug/`目录下创建可执行文件\n\n3. `cargo run`: build然后run\n\n4. `cargo check`：检查code是否能够通过编译，不会创建创建可执行文件\n\n5. `cargo build --release`: build操作，会额外做优化以加快程序运行速度，在发布release版本时使用\n\n","tags":["Rust","语言学习"],"categories":["Rust"]},{"title":"Web Animation API","url":"/posts/af0be6b0.html","content":"\n## Web Animation API\n\n以前，在web页面增加动画效果都是通过css来完成的。比如`transition`或者`animation`。有了Web Animation API就可以通过`javascript`来设置以及控制动画。\n\n### CSS实现动画\n\n通过css实现一个简单的动画，让box旋转移动，代码如下：\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n    <style>\n      .box {\n        width: 100px;\n        height: 100px;\n        background-color: red;\n        animation: move 2s ease-in-out;\n        position: fixed;\n      }\n      @keyframes move {\n        from {\n          transform: rotate(0);\n          left: 0;\n          top: 0;\n        }\n        to {\n          transform: rotate(1turn);\n          left: 80%;\n          top: 80%;\n        }\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"box\"></div>\n  </body>\n</html>\n\n```\n\n### Javascript实现动画\n\n将上面例子改成JavaScript，代码如下\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n    <style>\n      .box {\n        width: 100px;\n        height: 100px;\n        background-color: red;\n        position: fixed;\n      }\n    </style>\n  </head>\n  <body>\n    <div class=\"box\"></div>\n\n    <script>\n      // 获取dom\n      const ele = document.querySelector(\".box\");\n\t  \n      // 设置keyframes\n      const keyframes = [\n        {\n          transform: \"rotate(0)\",\n          left: 0,\n          top: 0,\n        },\n        {\n          transform: \"rotate(1turn)\",\n          left: \"80%\",\n          top: \"80%\",\n        },\n      ];\n      \n      // 设置动画，animate函数返回一个Animation对象\n      const animation = ele.animate(keyframes, {\n        easing: \"ease-in-out\",\n        duration: 2000, // millisecond\n      });\n      \n      // 可以监听时间\n      animation.addEventListener(\"cancel\", () => {\n        console.log(\"cancel\");\n      });\n      animation.addEventListener(\"finish\", () => {\n        console.log(\"finish\");\n      });\n      animation.addEventListener(\"remove\", () => {\n        console.log(\"remove\");\n      });\n      \n      // 取消\n      // animation.cancel()\n        \n      // 播放\n      // animation.play()\n    </script>\n  </body>\n</html>\n\n```\n\n使用方法很简单。直接调用`animate`方法即可。\n\n### 对比\n\nweb animation api比传统的css animation方案优秀不少，能够提供更好的用户体验。\n\n1. 前者更加灵活，javascript灵活度大于css\n2. 前者能够控制动画，诸如：暂停、播放等\n3. 前者能够监听动画的生命周期事件，例如：finish、cancel\n4. 前者兼容性不足，ie以及一些移动端不支持。但是有[polyfill](https://github.com/web-animations/web-animations-js)啊！\n\n## Animation API介绍\n\n调用`animate`方法后会返回一个`Animation`对象。通过这个对象能够实现控制动画以及监听动画的生命周期事件。\n\n### 事件\n\n| event    | type     | comment                                        |\n| -------- | -------- | ---------------------------------------------- |\n| oncancel | function | animation.cancel()调用后触发                   |\n| onfinish | function | 动画播放结束后或者animation.finish()调用后触发 |\n\n### 属性\n\n| name        | type                                                      | comment                                                      |\n| ----------- | --------------------------------------------------------- | ------------------------------------------------------------ |\n| currentTime | number                                                    | 动画执行的当前时间（ms）                                     |\n| playState   | 'idle' \\| 'pending' \\| 'runing' \\| 'paused' \\| 'finished' | 一个用来标识播放状态的枚举值<br />idle:　动画当前的时间是无法解析的，并且队列里没有处于等待执行的任务。<br />pending:　动画将一直等到某些等待中的任务完成方会执行。<br />running：动画处于正在运行状态。<br />paused：动画中止，并且[`Animation.currentTime`](https://developer.mozilla.org/zh-CN/docs/Web/API/Animation/currentTime)该项属性不会更新。<br />finished:动画已经达到某一临界点，并且[`Animation.currentTime`](https://developer.mozilla.org/zh-CN/docs/Web/API/Animation/currentTime)该项属性不会更新。 |\n\n### 方法\n\n| name    | type       | comment                                                      |\n| ------- | ---------- | ------------------------------------------------------------ |\n| cancel  | () => void | 清除此动画的所有[`keyframeEffects`](https://developer.mozilla.org/zh-CN/docs/Web/API/KeyframeEffect)，并中止播放。 |\n| finish  | () => void | 立即完成，效果同中止播放（触发事件不一样）。                 |\n| pause   | () => void | 暂停播放动画                                                 |\n| play    | () => void | 开始或恢复播放动画，或者如果之前完成，则重新开始动画。       |\n| reverse | () => void | 反转播放动画，直到播放到动画开始时停止。 如果动画完成或未播放，它将从头到尾播放。 |\n\n更详细的API介绍请参考[MDN](https://developer.mozilla.org/en-US/docs/Web/API/Animation)\n\n","tags":["javascript","animation"],"categories":["JavaScript"]},{"title":"Electron-安全","url":"/posts/b81ed83c.html","content":"\n## XSS进化到RCE\n\nWeb的XSS攻击能做到脚本注入，而Electron具有原生能力可以调用nodejs的模块。这就导致进化成了RCE攻击(Remote code excute)\n\n```html\n<img onerror=\"require('fs');fs.readFile('./data.json')\"/>\n```\n\n解决：\n\n1. 基本的XSS防范措施\n2. 管理node权限\n   1. 主进程任何时候都允许\n   2. 渲染进程加载本地资源是允许\n   3. 渲染进程加载远程资源时不允许，但可以在preload中使用\n3. 限制链接跳转\n   1. https可信域允许\n   2. 应用本地协议允许\n   3. file协议不允许\n\n## cookie克隆攻击\n\n将cookie文件拷贝到其它机器，可以直接使用\n\n原因：Electron cookie没有想Chrome那样加密\n\n解决：\n\n生成设备指纹，将cookie与设备指纹绑定\n\n## 源码安全\n\nElectron打包可以设置asar，但是asar是可以解密的。\n\n`npm i asar -g`、`asar e app.asar unpack`、`cd unpack`\n\n解决：\n\n1. UI与逻辑分离：UI层使用Electron，逻辑层使用C++或Rust。通过`N-API`、`Neon`连接nodejs\n2. WebAssembly\n3. 代码混淆，使用构建工具进行代码混淆\n4. asar：防止小白\n5. [asar Hack](https://www.v2ex.com/t/493344)\n\n## 安全事项\n\napp层\n\n- 做好Web安全\n- [官方 安全Checklist](https://www.electronjs.org/docs/tutorial/security)，[文档]( https://www.electronjs.org/docs/tutorial/security#checklist-securityrecommendations)\n- 代码混淆\n\nnpm\n\n- nsp/snyk，检测npm包的安全性\n- 关注npm官博[安全文章](https://blog.npmjs.org/tagged/security)\n- nodejs安全小组 [Node.js Security WG](https://github.com/nodejs/security-wg)\n\nelectron\n\n- 升级Electron至最新\n- 有问题反馈security@electronjs.org\n- 尝试研究electron构建，具备项目应急能力\n\n","tags":["javascript","Electron","桌面端软件"],"categories":["Electron"]},{"title":"Electron-测试","url":"/posts/bc68d7e0.html","content":"\n## 测试金字塔\n\n![测试金字塔](../../images/测试金字塔.png)\n\n前端软件测试可以分为三步\n\n### 单元测试（`Unit Test`）\n\n单元测试是用来对一个模块、一个函数、一个组件或者一个类来进行正确性检验的测试工作。\n\n单元测试应该是最多的，而且快。\n\n单元测试颗粒更细，更加具体。测试失败要返回错误原因\n\n### 快照测试（`snapshot Test`）\n\n快照测试就是运行测试的时候，把结果保存一份，之后再来对比，比对不上测试就不通过。\n\n### 端到端测试（`E2E Test`）\n\n端到端测试时模拟用户的整个交互过程。比如：点击按钮 => 显示表单 => 填写数据 => 点击提交按钮 => 验证数据发送。 \n\n## Electron 测试\n\n### 处理Electron驱动\n\n可以使用官方提供的`spectron`；也可以[自定义驱动](https://www.electronjs.org/docs/tutorial/automated-testing-with-a-custom-driver)\n\n### 选择测试框架+工具\n\n1. ava\n2. mocha+chai\n3. jest\n4. ...\n\n### 管理测试用例\n\n通常在项目建立一个`test`目录，专门存放测试用例。\n\n按模块、功能分好类\n\n### 创建测试脚本\n\n在`package.json`加入`test`命令，编写自定义脚本，test命令去执行这个脚本。\n\n脚本主要用来执行测试用例\n\n## 自动化测试流程\n\n### 测试准备\n\n数据mock、准备上下文。\n\n### 测试用例描述\n\n用来说明这个测试用例是用来做什么的\n\n### 行为\n\n要做什么事\n\n### 断言\n\n得到什么结果\n\n### 测试后处理\n\n清理mock的数据，清理上下文\n\n## Electron测试编码\n\n```javascript\nconst Application = require('spectron').Application\nconst electronPath = require('electron')\nconst path = require('path')\n\n// jest 测试工具\ndescribe('Application lanuch', () => {\n    let app\n\tbeforeEach(() => {\n        app = new Application({\n            path: electronPath\n            args: [path.join(__dirname, '../')]\n        })\n    \treturn app.start()\n\t});\n    afterEach(() => {\n        if(app && app.isRunning()) return app.stop()\n    });\n\n\ttest('Check if the window is visible', () => {\n        expect(app.browserWindow.isVisible()).toBeTruthy()\n    });\n\n\ttest('Get the window\\'s title', () => {\n        expect(app.client.getTitle()).toBe('My App')\n    })\n})\n\n```\n\n","tags":["javascript","Electron","桌面端软件"],"categories":["Electron"]},{"title":"Electron-集成原生能力","url":"/posts/72ce1ec4.html","content":"\n## NAPI\n\nN-API是nodejs的一部分，独立于v8 runtime，用来在nodejs中集成C++：同一ABI（Application Binary Interface）、无需重新编译\n\n- 本身是基于C的API\n- C++封装 node-addon-api\n\n### 环境配置\n\n`yarn global add windows-build-tools` : 管理员身份安装\n\n`yarn global add node-gyp`:  gyp即generate your project\n\n### 初始化项目\n\n1. 初始化：\n   1. `npm init -y`\n   2. `yarn add bindings node-addon-api -D`\n   3. `package.json`增加`\"gyp\":true`\n2. 目录结构\n```\n|- project\n|\t|- lib # c++文件\n|   |- fingerprint.cc\n|   |- binding.gyp\n|   |- index.js\n|   |- package.json\n```\n\n### binding.gyp\n\n`bindings`用来加载原生模块(.node文件)。不同平台不同版本rebuild出来的目录结构可能不一样。通过`bindings`来抹平差异。\n\n编写`binding.gyp`\n\n```json\n{\n\t\"targets\": [\n      {\n        \"target_name\": \"fingerprint\",  // 应用名称\n        \"cflags!\": [\"-fno-exceptions\"],\n        \"cflags_cc!\": [\"-fno-exceptions\"],\n        \"sources\": [\"fingerprint.cc\"],  // 需要编译的文件\n        \"include_dirs\": [ // 编译时需要引入的头文件\n          \"<!@(node -p \\\"require('node-addon-api').include\\\")\"\n        ],\n        \"defines\": [\"NAPI_DISABLE_CPP_EXCEPTIONS\"]\n    }\n  ]\n}\n```\n\n### C++实现\n\n```c++\n// fingerprint.cc\n#include <napi.h>\n#include <iostream>\n#include <string>\n#include <stdlib.h>\n\nstd::string getFingerprint()\n{\n    srand(100);\n    std::string result = std::to_string(rand());\n    return result;\n}\n\n// 定义一个method，该方法返回一个设备指纹（随机数mock）\nNapi::String Method(const Napi::CallbackInfo &info)\n{\n    Napi::Env env = info.Env();\n    std::string fingerprint = getFingerprint();\n    return Napi::String::New(env, fingerprint);\n}\n\n// 初始化\n// 相当于 module.exports = Method\nNapi::Object Init(Napi::Env env, Napi::Object exports)\n{\n    exports.Set(Napi::String::New(env, \"getFingerprint\"),\n                Napi::Function::New(env, Method));\n    return exports;\n}\n\n// 暴露模块\n// 模块名 fingerprint，Init进行初始化\nNODE_API_MODULE(fingerprint, Init)\n```\n\n### 构建\n\n使用`node-gyp rebuild`进行构建，在根目录中会生成`build`目录。\n\n然后编写index.js，来导出模块\n\n```javascript\nconst fingerprint = require(\"bindings\")(\"fingerprint\");\n\nmodule.exports = fingerprint;\n```\n\n### 使用\n\n通常做法是，将写好的node addon发布到npm上。在其它项目中就可以通过`npm`或者`yarn`安装，然后就`require`使用\n\n```javascript\nconst fp = require(\"fingerprint\"); // fingerprint是npm包名\n\nconsole.log(fp.getFingerprint());\n```\n\n## 集成DLL（动态链接库） \n\n`node-ffi-napi`，黑盒调用\n\n```javascript\nconst FFI = require('ffi-napi')\n\nconst user32 = new FFI.libraray('user32', {\n    'finDWindowA': ['int32', ['string', 'string']],\n    'ShowWindow': ['int32', ['int32', 'int32']],\n})\n\nfunction showWechat() {\n    let res = user32.FindWindowA('weChatMainWinForPC', null)\n    let show = user32.showWindow(res, 5)\n}\n\nmodule.exports = showWechat\n```\n\n常见错误：\n\nDynamic Linking Error: Win32 error 126\n\n- dll 路径没写对、arch 没选对、dll 引用有问题\n\nDynamic Linking Error: Win32 error 127\n\n- 传参有问题、dll 没有这个函数\n\n## AppleScript\n\nmac上，还可以通过`AppleScript`使用获得原生能力\n\n[AppleScript语法文档](https://developer.apple.com/library/archive/documentation/AppleScript/Conceptual/AppleScriptLangGuide/introduction/ASLR_intro.html)\n\n[node-applescript](https://github.com/TooTallNate/node-applescript)\n\n```javascript\nconst applescript = require('applescript')\nconst script = 'tell application \"WeChat\" to activate end'\napplescript.execString(script, (err, res) => {\n    if(err) {\n        console.log(err)\n        return\n    }\n    console.log(res)\n})\n```\n\n## 集成RUST\n\n通过[Neon](https://neon-bindings.com/docs/intro)来将RUST程序集成到`nodejs`中。","tags":["javascript","Electron","桌面端软件","C++","Rust"],"categories":["Electron"]},{"title":"Electron-体验优化","url":"/posts/60bc3abb.html","content":"\nElectron内置了`Chromium`浏览器。在原生体验上，一直被诟病。在开发Electron程序时，要格外关注体验优化。\n\n## 性能优化\n\n### 核心模块优先加载\n\n不再在入口文件把所有内容都加载进来，只需要加载程序的核心功能，其它部分按需加载\n\n```javascript\nfunction compute(a, b) {\n    const calculator = require('./calculator')\n    return calculator.complex(a, b)\n}\n\n// 执行核心内容\n// ...\n\n// 执行非核心内容\ncompute(0x12f2, 0xff21)\n```\n\n在`Typescript`通过`dynamic import`实现\n\n```typescript\nasync function compute(a, b) {\n    const calculator = await import('./calculator')\n    return calculator.complex(a, b)\n}\n\n// 执行核心内容\n// ...\n\n// 执行非核心内容\ncompute(0x12f2, 0xff21)\n```\n\n### Web性能优化\n\n毕竟本质上还是Web，所以Web性能的优化技巧都可以应用得到`Electron`。如果使用`SPA`，要格外注意打包优化。\n\n### 窗口预热 与 窗口池、窗口常驻\n\n- 窗口预热：提前创建窗口，加载必要的资源（不显示），等需要时直接显示即可。这样的做法是以空间换时间。\n- 窗口池：不要频繁创建和销毁窗口，当需要加载新页面时从当前的窗口池中选择窗口\n- 窗口常驻：对于业务无关的、通用的窗口，也可以采用**常驻模式**，例如通知，图片查看器。这些窗口一旦创建就不会释放，打开效果会更好。\n\n### 网络资源缓存\n\nPWA\n\n### 主进程保持轻量\n\n`Electron`程序中，主进程和渲染进程有着`Sync IPC`（同步IPC）操作。如果主进程中有密集计算，会导致渲染进程UI阻塞。\n\n可以使用多进程，参考node的[cluster模块](http://nodejs.cn/api/cluster.html)\n\n或者通过`web worker`来实现多线程，但是`web worker`只能在渲染进程中使用，所以**对于密集计算，可以单独开个渲染进程(开启一个不显示的窗口)来处理**。\n\n还有：**不要使用remote模块！不要使用remote模块！不要使用remote模块！**，`remote模块`本质上也是使用同步IPC，所以也会很容易造成阻塞\n\n### 预加载\n\n#### Electron\n\nelectron中，在创建`BrowserWindow`时可以指定`preload`字段来预加载一段脚本\n\n#### Browser\n\n使用`requestIdleCallback`，让浏览器空闲时执行一些优先级较低的任务。\n\n当浏览器空闲时，会调用`requestIdleCallback`注册的回调函数，但是有可能浏览器一直很繁忙没有空闲，这是需要指定`timeout`，超过这个时间强制执行\n\n```javascript\nvar handle = window.requestIdleCallback(callback[, options])\n```\n\n**callback**：回调，即空闲时需要执行的任务，该回调函数接收一个`IdleDeadline`对象作为入参。其中`IdleDeadline`对象包含：\n\n- `didTimeout`，布尔值，表示任务是否超时，结合 `timeRemaining` 使用。\n- `timeRemaining()`，表示当前帧剩余的时间，也可理解为留给任务的时间还有多少。\n\n**options**：目前 options 只有一个参数\n\n- `timeout`。表示超过这个时间后，如果任务还没执行，则强制执行，不必等待空闲。\n\n### 原生模块\n\n`ndoejs`可以集成`C++`、`RUST`等，用来优化性能，详情见[Electron-集成原生能力](https://zxffan.github.io/posts/72ce1ec4.html)\n\n## 启动优化\n\n#### V8 snapshot\n\n[`atom`通过`v8 snapshot`优化启动时间](https://blog.atom.io/2017/04/18/improving-startup-time.html)\n\n`v8 snapshot`会将`javascript`输出成二进制文件，文件的内容是`javascript`代码在内存中的表现形式即数据堆\n\n这个二进制文件的执行速度时快于`javascript`代码的。\n\n在Electron中将一些启动时的核心代码进行`v8快照`，这样可以起到优化启动速度的目的\n\n> 说明：\n>\n> 1. `v8 snapshot`中的代码是处于一个裸露的v8上下文中，也就是说只能使用`plain javascript`而无法调用`Electron`和`nodejs`的API，Atom团队的[electron-link](https://github.com/atom/electron-link)可以在一定程度上**规避**这个问题\n> 2. 生成`v8 snapshot`可以通过[electron-mksnapshot](https://github.com/electron/mksnapshot)来实现\n\n#### V8 code cache\n\n`nodjes v12`对内部模块做了`code cache`，对启动速度提升很明显。\n\n## 白屏问题\n\n### 为什么会有白屏\n\n![Electron生命周期](../..//images/Electron生命周期.png)\n\n在`show`（窗口显示）到`ready-to-show`（页面加载完毕）之间还需要经历以下过程\n\n1. preload解析，创建`BrowserWindow`设置的\n2. 解析HTML结构\n3. 加载外部脚本（`script`）以及样式表文件（`link`）\n4. 解析并执行脚本\n5. `Dom Tree`构建完毕\n6. 资源文件（图片、音视频）加载\n7. 页面加载完成\n\n只有完成这些过程，窗口才能显示内容。所以这段时间窗口会一直白屏。如果使用`vue`或`react`这种`SPA`框架，也会出现首屏加载过慢的情况。\n\n### 解决方法一——不显示窗口\n\n创建`BrowserWindow`时，设置`show:false`即不显示窗口\n\n等到`ready-to-show`事件触发时才显示\n\n```javascript\nconst win = new BrowserWindow({\n    widht: 600,\n    height: 300,\n    show: false\n})\n\nwin.on('ready-to-show', () => {\n    win.show()\n})\n```\n\n### 解决方法二——骨架屏\n\n最简单的方法就是直接给窗口显示个底色\n\n```javascript\nconst win = new BrowserWindow({\n    widht: 600,\n    height: 300,\n    show: false,\n    background: '#2e2c29'\n})\n```\n\n比较好的方法就是专门设计一套骨架屏。利用`BroswerView`来显示骨架屏。\n\n当窗口创建时，创建`BrowserView`来加载骨架屏页面，将`BrowserView`设置到`BrowserWindow`上并遮罩住，当骨架屏页准备好后时显示骨架屏。当渲染进程发送来一个`stop-loading`消息时，移除`BrowserView`\n\n```javascript\nconst mainWindow = new BrowserWindow({\n    width: 800,\n    height: 600,\n    webPreferences: {\n      preload: path.join(__dirname, \"preload.js\"),\n    },\n    show: false, // 默认不显示窗口\n});\n\nlet view = new BrowserView();\nmainWindow.setBrowserView(view);\nview.setBounds({ x: 0, y: 0, width: 800, height: 600 }); // 遮挡住窗口\nview.webContents.loadFile(\"loading.html\"); // 加载骨架屏页面\n\n// 当骨架屏加载完成后显示窗口\nview.webContents.on(\"dom-ready\", () => {\n    console.log(\"show\");\n    mainWindow.show();\n});\n\n// 当渲染进程发来stop-loading消息时，移除骨架屏，显示真正页面\nipcMain.on(\"stop-loading\", () => {\n    console.log(\"stop\");\n    mainWindow.removeBrowserView(view);\n});\n```\n\n## 性能检测\n\nChrome DevTools Performance\n\n## 支持快捷键\n\n[系统快捷键](http://www.electronjs.org/docs/api/global-shortcut)\n\n```javascript\nconst { app, globalShortcut } = require('electron')\n\napp.on('ready', () => {\n  // 注册一个 'CommandOrControl+X' 的全局快捷键\n  const ret = globalShortcut.register('CommandOrControl+X', () => {\n    console.log('CommandOrControl+X is pressed')\n  })\n\n  if (!ret) {\n    console.log('registration failed')\n  }\n\n  // 检查快捷键是否注册成功\n  console.log(globalShortcut.isRegistered('CommandOrControl+X'))\n})\n\napp.on('will-quit', () => {\n  // 注销快捷键\n  globalShortcut.unregister('CommandOrControl+X')\n\n  // 注销所有快捷键\n  globalShortcut.unregisterAll()\n})\n```\n\n## 本地化（i18n）\n\nElectron程序在`ready`事件后，可以通过`app.getLocale()`来获得`local值`(如`zh-CN`)，[详细列表](http://www.electronjs.org/docs/api/locales)\n\n通过[i18nnext](https://github.com/i18next/i18next)来实现国际化\n\n[Electron使用i18nnext](https://phrase.com/blog/posts/building-an-electron-app-with-internationalization-i18n/#Switching_Locale_from_the_Menu)\n\n## 开机自启\n\n通过`app.setLoginItemSettings`来设置开机自启\n\n```javascript\napp.setLoginItemSettings({\n  openAtLogin: true, // Boolean 在登录时启动应用 默认false\n  openAsHidden: true, // Boolean (可选) mac 表示以隐藏的方式启动应用。~~~~\n  // path: '', String (可选) Windows - 在登录时启动的可执行文件。默认为 process.execPath.\n  // args: [] String Windows - 要传递给可执行文件的命令行参数。默认为空数组。注意用引号将路径换行。\n})\n```\n\n","tags":["javascript","Electron","桌面端软件"],"categories":["Electron"]},{"title":"Electron-项目打包","url":"/posts/acb10ea6.html","content":"\n## 打包分为几步？\n\n1. 下载二进制文件 ：\n\n2. 添加业务代码：构建好的前端资源添加到resources app，electron壳子与业务代码结合\n\n3. 修改文件信息：修改 应用名称，设置图标等\n\n4. 制作镜像：压缩文件，制作镜像（dmg-builder、nsis）\n\n## 打包工具\n\n|              | electron-builder                             | electron-forge                               |\n| ------------ | -------------------------------------------- | -------------------------------------------- |\n| 签名         | ***                                          | ***                                          |\n| 安装包类型   | ***                                          | ***                                          |\n| 原生模块编译 | ***                                          | ***                                          |\n| 定制化       | ***                                          | *                                            |\n| 上手成本     | **                                           | *                                            |\n| boilerplate  | x                                            | ***                                          |\n| 跨平台构建   | Linux、windows                               | x                                            |\n| 社区活跃度   | ***                                          | **                                           |\n| 场景         | 打包和发布的完成解决方案，基本适用于所有场景 | 创建到发布的一体化解决方案，适合从0到1的项目 |\n\n推荐使用`electron-builder`\n\n## 打包准备\n\n1. 证书\n   1. mac: 开发者证书\n   2. window：赛门铁克(Symantec)、WoSign\n2. 对于系统的机器（mac打macos的包，windows打win的包，linux打linux的包）\n3. 软件所需图片\n   1. mac： \n      1. 软件图标、icns格式，通过 [image2icon](http://www.img2icnsapp.com/) 或者 [iconutil](https://www.npmjs.com/package/iconutil) 生成\n      2. dmg 背景图\n      3. 安装包图标\n   2. Windows\n      1. ico\n      2. installerIcon-安装图标\n      3. unInstallerIcon-卸载图标\n\n## 使用electron-builder来打包\n\n### 安装相关依赖\n\n- `npm i -g --production window-build-tool`（用管理员权限安装，window必备）\n- 项目目录下执行`npm i electron-builder -S`\n- 在`package.json`中，添加`\"postinstall\": \"electron-builder install-app-deps\"`。每当使用`npm install`或者`yarn add`时，会自动安装匹配当前electron版本的依赖。\n\n### 配置方式\n\n在`package.json`中加入build属性\n\n使用`electron-builder.yml`\n\n通过编程时API\n\n### 配置项\n\n在`package.json`文件中添加如下\n\n```json\n\"build\"： {\n    \"appId\": \"com.xxx.xxx\",\n    \"productName\": \"应用名称\",\n    \"directories\": {  // 目录配置\n        \"app\": \"dist\", // 打包的代码目录\n        \"buildResources\": \"resource\", // 构建包的资源目录\n        \"output\": \"release\" // 存放产包的目录\n    },\n    \"asar\": true, // asar加密，保护源代码\n    \"copyright\": \"Copyright xxxx\",\n    \n    \"mac\": {\n       \"target\": [\"dmg\", \"zip\"],  // 包格式，zip用于自动更新\n\t\t\"icon\": \"resources/icon.icns\" // logo地址\n    },\n    \"dmg\": {\n        \"background\": \"resources/background.png\", // 背景图\n        \"window\": { \"width\": 540,  \"height\": 380}, // 安装窗口大小\n        \"contents\": [ // dmg内容坐标\n          {\"x\": 410, \"y\": 190,  \"type\": \"link\", \"path\": \"/Applications\"},\n          {\"x\": 130,\"y\": 190,\"type\": \"ﬁle\"}\n        ],\n        \"iconSize\": 128, // logo大小\n   },\n   \"win\": {\n       \"icon\": \"resources/icon.ico\", // logo地址\n       \"target\": [ \"nsis\", \"squirrel\"] // nsis包，squirrel是一件安装包\n   },\n   \"nsis\": {\n       \"oneClick\": false,  // 一键安装\n       \"language\": \"2052\", // 2052代表中文\n       \"perMachine\": true, // 是否为机器上所有用户安装\n       \"allowToChangeInstallationDirectory\": true // 允许改变安装目录\n   },\n   \"squirrelWindows\": {\n       \"loadingGif\": \"resources/loading.gif\", // 安装动态图\n       \"iconUrl\": \"https://xxxxx.com/icon.ico\" // 必须是远程的\n   }\n}\n```\n\n> nsis时windows下的包安装器，可以做到很细致的定制。\n>\n> 如果使用squirrel来打包，需要安装`electron-builder-squirrel-windows`\n\n在`scripts`中加上`\"pack\": \"electron-builder\"`\n\n如果使用编程时API，则新建一个js或ts文件\n\n```javascript\n// js\nconst { build } = require(\"electron-builder\");\n\nbuild({\n    config: {\n        appId: \"com.xxx.xxx\",\n        productName: \"应用名称\",\n        // ...以下省略\n    }\n})\n\n// build函数返回一个promise\n// 可以 借助 electron-builder的类型声明文件来查看它有哪些方法和参数类型\n```\n\n然后用node执行这个js文件。如果是ts文件，可以使用ts-node，或者先用tsc编译再用node执行。\n\n`electron-builder`更详细的配置请查阅[官网](https://www.electron.build/configuration/configuration)\n\n## 总结\n\n1. 发布产品注意版本号的升级\n   1. `npm version patch`：自动升级patch\n   2. `npm version minor`：自动升级minor，path会清0\n   3. `npm version major`：自动升级major，minor和patch会清0\n\n2. 证书\n   1. windows下没有证书，可能会被杀软误杀\n   2. mac下没有证书，无法实现自动更新\n   3. windows下打包可以通过修改nsis来自定义安装逻辑\n   4. 开源软件可以基于 Travis, AppVeyor 持续集成","tags":["javascript","Electron","桌面端"],"categories":["Electron"]},{"title":"Electron-质量监控","url":"/posts/34a04fbb.html","content":"\n##  Electron质量保证\n\n|          | 开发                                                         | 测试                                                   | 上线                 | 监控                                     |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------ | -------------------- | ---------------------------------------- |\n| 渲染进程 | 代码静态检查：eslint<br />强类型语言：typescript<br />Code review | 单元测试<br />性能测试<br />UI自动化测试<br />冒烟测试 | 灰度发布<br />回滚   | 性能监控<br />异常监控<br />用户行为监控 |\n| 主进程   | 同上                                                         | Electron测试(Spectron)                                 | 功能开关<br />热修复 | **崩溃监控**                             |\n\n## 崩溃监控模型\n\n![electron错误收集](../../images/electron错误收集模型.png)\n\nElectron内置`crashReporter`模块，可以用来监控主进程和渲染检查的错误。然后将错误报告发送给服务器的`crash收集服务`\n\n崩溃报告将发送下面 `multipart/form-data` `POST` 型的数据给 `submitURL`:\n\n- `ver` String - Electron 的版本.\n- `platform` String - 例如 'win32'.\n- `process_type` String - 例如 'renderer'.\n- `guid` String - 例如 '5e1286fc-da97-479e-918b-6bfb0c3d1c72'.\n- `_version` String - `package.json` 里的版本号.\n- `_productName` String - `crashReporter` `options` 对象中的产品名字\n- `prod` String - Name of the underlying product. In this case Electron.\n- `_companyName` String - `crashReporter` `options` 对象中的公司名称\n- `upload_file_minidump` File - `minidump` 格式的崩溃报告\n- All level one properties of the `extra` object in the `crashReporter` `options` object.\n\n上述数据中的`upload_file_minidump`是个minidump格式的文件。直接时无法打开的。需要结合`electron-symbols`以及`node-minidump`，后面再说。\n\n## 实现监控\n\n### 服务端\n\n使用`koa`搭建一个crash收集服务\n\n\n```javascript\nconst Koa = require('koa')\nconst app = new Koa()\nconst Router = require('koa-router')\nconst multer = require('koa-multer') // 处理文件上传的库\nconst uploadCrash = multer({ dest: 'crash/' }) // 设置错误报告存放目录\n\nconst router = new Router()\n\nrouter.post('/crash', uploadCrash.single('upload_file_minidum'), (ctx, next) => {\n    // TODO 错误信息存储到DB\n    ctx.request.file // minidump文件\n})\n\napp.use(router.routes())\n    .use(router.allowedMethods())\n\napp.listen(33855)\n```\n\n### ELectron端\n\n配置`crashReporter`\n\n```javascript\n// crash.js\nconst { crashReporter } = require('electron')\n\nfunction init() {\n    crashReporter.start({\n        crashReporter.start({\n        \tproductName: '',\n        \tcompanyName: '',\n        \tsubmitURL: '服务器 处理异常接口地址'\n    \t})\n    })\n}\nmodules.exports = { init }\n\n// main.js\napp.on('will-finish-lanuching', () => {\n    require('./crash-reporter').init()\n})\n```\n\n### 解析错误日志\n\n服务端收到的是`minidump`文件。需要使用`symbols`以及`node-minidump`来解析日志\n\n先下载对应electron版本和对应os的symbols，[下载地址](https://github.com/electron/electron/releases)\n\n![symbols下载](../../images/symbols下载.png)\n\n建立一个node项目（也可以集成到crash收集服务中）。安装`node-minimap`\n\n执行`yarn add minidump`\n\n```javascript\nconst minidump = require('node-minidump')\nconst fs = require('fs')\nminidump.addSymbolPath('./symbols/electron-v10.0.0-beta.12-darwin-x64-symbols.zip') // 指定下载的symbols路径\n\n// 指定minidump文件地址\nminidump.walkStack('./e19fb34bc3rf6812', (err, res) => {\n    // res 解析结果\n    fs.writeFileSync('./res.txt', res) // 写入文件\n})\n```\n\n## 监控技巧\n\n渲染进程崩溃后提示用户重新加载\n通过 `preload`统一初始化崩溃监控\n主进程、渲染进程通过 `process.crash()`可以模拟崩溃\n\n通过`process`进行异常监控\n\n```javascript\nprocess.on('uncaughtException', () => {\n    // 上报异常\n})\n```\n\n","tags":["javascript","Electron","桌面端软件"],"categories":["Electron"]},{"title":"Electron-应用更新","url":"/posts/e7227c9a.html","content":"\n## 软件更新方式\n\n### 手动更新\n\n用户手动下载、安装新包。\n\n手动更新简单稳定，适合更新频率低，用户粘性高的场景，通常作为其它升级技术的`降级方案`。\n\n流程：\n\n1. 更新服务：匹配客户端版本，用户信息\n2. 检查更新器：返回包地址，更新文案\n3. 提示：新功能升级\n4. 手动操作：跳转浏览器，打开安装包覆盖\n\n### 文件覆盖\n\n程序自动替换文件以实现更新。\n\n不稳定，可能会写入失败。适合`打补丁`的场景\n\n流程：\n\n1. 更新服务：匹配客户端版本，用户信息\n2. 检查更新器：返回包地址，更新文案\n3. 提示：新功能升级\n4. 程序操作：吊起子程序，关闭应用，将补丁复制到应用目录，重新启动\n\n### 自动更新\n\n后台下载文件，重启即新版\n\n稳定，快，用户无感知。适合更新频率高的场景，以及对用户体验要求高的场景\n\n流程：更新服务 => 检查更新器 => 下载新包 => 重启应用加载新包\n\n### 应用商店\n\n通过各平台应用商店发布，例如Microsoft store和mac app store\n\n统一、稳定\n\n### 对比\n\n| 更新方式 | 手动更新                                         | 文件覆盖                             | 自动更新             | 应用商店           |\n| -------- | ------------------------------------------------ | ------------------------------------ | -------------------- | ------------------ |\n| 优点     | 简单、稳定                                       | 下载过程快                           | 稳定、快、打扰少     | 统一、稳定         |\n| 缺点     | 过程繁琐、慢、影响使用、                         | 实现复杂、稳定性差、文件写入可能失败 | 实现复杂             | 受应用商店局限     |\n| 使用场景 | 低频更新、用户粘性高、作为各种升级技术的降级方案 | 打补丁                               | 高频更新、体验要求高 | 需要上架商店的软件 |\n\n## Electron更新方式\n\n### Web化\n\n将渲染进程（业务）代码，放置远程服务器。Electron通过loadURL加载\n\n这样的话，只要更新服务器的代码就能实现系统更新。\n\n缺点：无法离线使用，Electron壳子无法更新。\n\n### 文件覆盖\n\nElectron检测服务器的release版本与本地是否一致，若有新版本提示升级。拉去服务器程序并覆盖本地，然后重启。\n\n相关实现请参考张鑫旭的[文档](https://www.zhangxinxu.com/wordpress/2017/06/how-electron-online-update-hot-fix/?replytocom=361528)\n\n### Electron-Updater\n\nElectron-Updater是由electron-builder提出的\n\n 优点\n\n1. 接入简单\n2. Windows 支持签名验证\n3. 支持进度条\n4. 基于 electron-builder 非常容易使用\n\n 缺点\n\n1. Windows 更新体验没有内置的好\n2. Windows 存在权限问题\n\n详见 https://www.electron.build/auto-update.html\n\n### 增量更新\n\n只更新需要更新的地方\n\n原理： 当前版本与最新版本做diff算法，将不同的地方打包成patch，更新就只更新patch部分。\n\n增量技术：\n\n1. bsdiff/bspatch：适用二进制文件、开源、免费、广泛使用（尤其移动端）\n2. Xdelta3：适用于二进制\n3. Courgette：谷歌提出的方案，是bsdiff的优化\n4. RTPatch：商业付费\n\n对比参考：https://www.shangyexin.com/2018/09/28/delta_algorithm/\n\n## 灰度发布\n\n灰度发布就是让一部分用户继续使用原来的产品功能，对另一部分用户逐渐开发新功能。然后针对新功能在做完善和优化。等到灰度发布完成后，所有用户都将使用新的产品功能。\n\n## Electron更新实战\n\n### 更新准备\n\n准备证书，Mac下自动更新必须要证书。打包时候配置。\n\n### 使用内置的[autoUpdater](https://www.electronjs.org/docs/api/auto-updater)模块\n\nElectron官方更新方法是基于内置的[Squirrel](https://github.com/Squirrel)框架和Electron的[autoUpdater](https://www.electronjs.org/docs/api/auto-updater)模块。\n\n#### autoUpdater模块简介\n\n```typescript\nconst { autoUpdater: updater } = require('electron')\n\n// 设置更新服务器地址\nupdater.setFeedURL({\n    url: '更新服务器地址',\n    headers: 'HTTP请求头',\n    serverType: 'default' // json or default \n})\n\n// 获取当前更新服务器地址\nupdater.getFeedURL()\n\n// 检查更新，访问更新服务器地址\n// 调用checkForUpdates之前必须设置setFeedURL\nupdater.checkForUpdates()\n\n// 此方法hui关闭所有应用窗口，然后自动调用app.quit()\n// 这个方法通常在 update-downloaded 事件触发后调用\nupdater.quitAndInstall()\n\n\n// 开始检查更新时触发\nupdater.on('check-for-update', () => {\n    // TODO...\n})\n\n// 检查更新后，发现有新版本后触发该事件\n// 该事件触发后，会自动下载最新版本\nupdater.on('update-avaliable', () => {\n    // TODO...\n})\n\n// 检查更新后，没有发现新版本（返回204）后触发该事件\nupdater.on('update-not-avaliable', () => {\n    // TODO...\n})\n\n// 最新版下载完成后触发该事件\n// 在 Windows 上只有 releaseName 是有效的。\nupdater.on('update-downloaded', (e, releaseNotes, releaseName, releaseDate, updateURL) => {\n    // TODO...\n    // 显示提示框，询问用户是否自动更新\n})\n\n// 用户调用quitAndInstall 后触发\nupdater.on('before-quit-for-update', () => {\n    // TODO...\n})\n\n// 更新发生错误时，触发\nupdater.on('error', (error) => {\n    // TODO...\n})\n```\n\n#### 更新流程\n\n##### mac更新\n\nElectron客户端请求服务器，服务器去检查是否有最新版本。如果有，服务端需要返回**相应数据**，没有就返回`204`状态码\n\nmac下服务端需要返回这样的`json`结构\n\n```json\n{\n\t\"url\": \"https://mycompany.example.com/myapp/releases/myrelease\", // url为包下载地址\n\t\"name\": \"My Release Name\",\n\t\"notes\": \"Theses are some release notes innit\",\n\t\"pub_date\": \"2013-09-18T12:29:53+01:00\" \n}\n```\n\n然后Electron客户端就会自动请求`url`地址去下载\n\n\n\n##### windows更新\n\nElectron客户端请求服务器，服务器去检查是否有最新版本。如果有，服务端需要返回**相应数据**，没有就返回`204`状态码\n\nwindow下需要返回RELEASES文件内容（使用Squirrel打包生成的），如`BBC6F98A5CD32C675AAB6737A5F67176248B900C appName-1.0.1-full.nupkg 62177782`\n\n客户端收到数据发现有最新版本，又会请求`feedURL/*.nupkg`地址。所以服务端要响应相应的请求。\n\n在Electron主进程加上`if(require('electron-squirrel-startup')) return`。作用是：如果在程序安装时、更新时以及卸载时启动程序，就直接返回（或者`app.quit()`）。即不启用程序（否则会报错）\n\nwindow更新注意： \n\n1. 安装包不能使用 NSIS，需要使用 Squirrel\n2. 更新需要 Squirrel 配套的 nupkg 包\n\n#### 服务端\n\n安装模块：`yarn add koa koa-router koa-static-server compare-versions`\n\n```javascript\nconst Koa = require('koa')\nconst app = new Koa()\nconst Router - require('koa-router')\nconst serve = require('koa-static-server')\nconst compareVersions = require('compare-versions')\n\n// 获取最新版本通常会去查询数据库，这里就直接mock了\nfunction getNewVersion(version) {\n    if(!version) return null\n    let maxVersion = {\n        name: '1.0.1',\n        pub_date: '2020-02-01T12:26:53+1:00',\n        notes: '新增功能AAA',\n        url: 'http://128.0.0.1:33855/public/xxxx-1.0.1-mac.zip'\n    }\n    if(compareVersions.compare(maxVersion.name, version, '>')) return maxVersion\n    return null\n}\n\n// for mac\nrouter.get('/darwin', (ctx, next) => {\n    // 处理Mac更新，?version=1.0&uid=123\n    let {version} = ctx.query\n    let newVersion = getNewVersion(version)\n    if(newVersion) {\n        ctx.body = newVersion\n    } else {\n        ctx.status = 204 // 204代表没有数据\n    }\n})\n\n// for win\nrouter.get('/win32', (ctx, next) => {\n    let {version} = ctx.query\n    let newVersion = getNewVersion(version)\n    if(newVersion) {\n        ctx.body = 'BBC6F23A34BC123BA123C900 xxxx-1.0.1-full.nupkg 62177782'\n    } else {\n        ctx.status = 204 // 204代表没有数据\n    }\n})\n\n// 重定向去下载\nrouter.get('/win32/*.nupkg', (ctx, next) => {\n    ctx.redirect(`/public/${ctx.params[0].nupkg}`)\n})\n\napp.use(server(rootDir: 'public', rootPath: '/public'))\n\napp.use(router.routes())\n\napp.listen(3385)\n```\n\n#### Electron端\n\n```javascript\n// update.js\n\nconst { autoUpdater, app, dialog } = require('electron')\n\nif(process.platform === 'darwin') {\n    autoUpdater.setFeedURL(`http://127.0.0.1:33855/darwin?version=${app.getVersion()}`)\n} else {\n    autoUpdater.setFeedURL(`http://127.0.0.1:33855/win32?version=${app.getVersion()}`)\n}\n\n// 定时轮调 or 服务端推送\nautoUpdater.checkForUpdater()\n\nautoUpdater.on('update-avaliable', () => {\n    console.log('update-avaliable')\n})\n\nautoUpdater.on('update-downloaded', (e, notes, version) => {\n    app.whenReady().then(() => {\n         // 提示用户更新\n        let clickId = dialog.showMessageBoxSync({\n            type: 'info',\n            title: '升级提示',\n            message: '存在最新版，是否立即升级',\n            buttons: ['马上升级', '取消'],\n            cancelId: 1, // 手动重启 为 cancel\n        })\n\n        if(clickId === 0) {\n            autoUpdater.quiteAndInstall()\n        }\n    }) \n})\n\nautoUpdater.on('error', err => {\n    console.log('error:', error)\n})\n\n// main.js\nconst isDev = require('electron-is-dev')\nif(require('electron-squirrel-startup')) app.quit()\n\napp.on(\"will-finish-launching\", () => {\n    !isDev && require('./update.js')\n})\n```\n\n### 使用Electron-Updater\n\n`electron-updater`是基于`electron-builder`的更新方案。\n\n#### electron-updater模块简介\n\n```javascript\nconst { autoUpdater: updater } = require('electron')\n\n// 设置更新服务器地址\n// options可以是一个url字符串 表示 安装包helatest.yml所在服务器地址\n// 也可以是个对象\nupdater.setFeedURL(options) \n\n// 获取当前更新服务器地址\nupdater.getFeedURL()\n\n// 检查更新，访问更新服务器地址\n// 调用checkForUpdates之前必须设置setFeedURL\n// 若有更新不会自动下载\nupdater.checkForUpdates()\n\n// 检查更新，若有更新自会自动下载并通知\nupdater.checkForUpdatesAndNotify()\n\n// 手动下载\n// 返回promise\nupdater.downloadUpdate()\n\n// 此方法hui关闭所有应用窗口，然后自动调用app.quit()\n// 这个方法通常在 update-downloaded 事件触发后调用\nupdater.quitAndInstall()\n\n// 更新通道\n// alpha beta lts等\n// 默认 latest\nupdater.channel = 'latest'\n\n// checkForUpdates或 checkForUpdatesAndNotify调用后触发\nupdater.on('checking-for-update', () => {\n    // TODO...\n})\n\n// 检查后，有最新版本时，触发\nupdater.on('update-available', (info) => {\n    // TODO...\n})\n\n// 检查后，没有最新版本时，触发\nupdater.on('update-not-available', () => {\n    // TODO...\n})\n\n// 下载过程中 轮调 触发\nupdater.on('download-progress', (progress, bytesPerSecond, percent, total, transferred) => {\n    // TODO...\n})\n\n// 下载完成后触发\nupdater.on('update-downloaded', (info) => {\n    // TODO...\n})\n\n// 更新发生错误时，触发\nupdater.on('error', (error) => {\n    // TODO...\n})\n\n```\n\n`electro-updater`的`autoUpdater`和electro内置的`autoUpdater`模块很相似，但前者比后者要强大不少，前者可以显示更新进度。\n\n#### 更新流程\n\n![electron-upadter更新流程](../../images/electron-updater更新流程.webp)\n\n几点补充：\n\n1. 在electron-builder打包配置中，一定要配置`public`字段，配置好后才能生成`latest.yml`文档。\n\n```json\n\"publish\": [\n    {\n        \"provider\": \"generic\",\n        \"url\": \"http://127.0.0.1:8000/\"  // 放置安装包和latest.yml的服务器地址\n    }\n],\n```\n\n2. 将打包后的`latest.yml`以及安装包。放置到服务器上，可以使用`nginx`来搭建文件服务器。Electron检查更新就是检查这个`latest.yml`文件\n\n#### Electron端\n\n```javascript\n// update.js\nconst { autoUpdater: updater } = require('electron-updater')\n\nupdater.setFeedURL('http://127.0.0.1:8000')\n\nupdater.checkForUpdatesAndNotify()\n\nupdater.on('update-available', () => {\n    // TODO 可以在这提醒用户更新\n})\n\nupdater.on('download-progress', (progress, bytesPerSecond, percent, total, transferred) => {\n    // TODO 显示进度条\n})\n\nupdater.on('update-downloaded', () => {\n    updater.quitAndInstall()\n})\n\nupdater.on('error', error => {\n    // TODO handle error\n})\n\n// main.js\napp.on(\"will-finish-launching\", () => {\n    require('./update.js')\n})\n```\n\n#### Nginx文件服务器\n\n```nginx\nautoindex on;# 显示目录\nautoindex_exact_size on;# 显示文件大小\nautoindex_localtime on;# 显示文件时间\n\nserver {\n    listen       8000 default_server;\n    listen       [::]:8000 default_server;\n    server_name  _;\n    root         /www/update/demo;  # 文件路径\n\n    location / {\n    }\n\n    error_page 404 /404.html;\n    location = /40x.html {\n    }\n\n    error_page 500 502 503 504 /50x.html;\n    location = /50x.html {\n    }\n}\n```\n\n","tags":["javascript","Electron","桌面端软件"],"categories":["Electron"]},{"title":"浏览器中的音视频","url":"/posts/4dbf3745.html","content":"\n## 浏览器如何采集摄像头和麦克风\n\n浏览器可以通过`navigator`上的`mediaDevices`属性来获取音视频流数据。`navigator.mediaDevices`返回一个[MediaDevices](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaDevices)对象\n\n![mediaDevice兼容性](../../images/mediaDevice兼容性.png)\n\n```javascript\nconst constraints = {\n    audio: true,\n    video: true,\n}\nnavigator.mediaDevices.getUserMedia(constraints).then(stream => {\n    videoElement.srcObject = stream\n    videoElement.onloadedmetadata = () => {\n        videoElement.play()\n    }\n})\n```\n\n通过`getUserMedia`可以获取摄像头视频以及麦克风的音频，它接受一个[MediaStreamConstraints](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaStreamConstraints)对象作为参数。并返回一个[MediaStream](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaStream)对象\n\n## 浏览器如何采集桌面\n\n`navigator.mediaDevices`还有一个`getDisplayMedia`方法，用来采集桌面（包括音视频）。用法和参数与`getUserMedia`一致\n\n```javascript\nconst constraints = {\n    audio: true,\n    video: true,\n}\nnavigator.mediaDevices.getDisplayMedia(constraints).then(stream => {\n    videoElement.srcObject = stream\n    videoElement.onloadedmetadata = () => {\n        videoElement.play()\n    }\n})\n```\n\n## 如何录制流\n\n录制音视频流需要通过[MediaRecorder](https://developer.mozilla.org/zh-CN/docs/Web/API/MediaRecorder)对象\n\n下例是录制麦克风\n\n```javascript\nlet recorder\nnavigator.mediaDevices.getUserMedia(constraints).then(stream => {\n    const mimeType = 'video/mp4'\n    if (MediaRecorder.isTypeSupported(mimeType)) { // 判断是否支持该类型\n        recorder = new MediaRecorder(stream, {\n            audioBitsPerSecond : 128000, // 音频的比特率 128kbps\n            videoBitsPerSecond : 2500000, // 视频的比特率 2.5Mbps\n            mimeType\n        })\n        // 当recorder.stop() 调用后， 触发该事件\n        recorder.ondataavailable = e => {\n            // e.data  blob对象\n            // ...\n        }\n        \n        recorder.start()\n    }\n})\n```\n\n## 如何解析音频\n\n有时候会遇到音频可视化的需求，比如播放器可能会显示音频的波形。这时就需要借助[AudoContext](https://developer.mozilla.org/zh-CN/docs/Web/API/AudioContext)对象来实现。\n\n直接上代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>audio analyser</title>\n  </head>\n  <body>\n    <canvas id=\"canvas\"></canvas>\n    <script>\n      navigator.mediaDevices\n        .getUserMedia({\n          audio: true,\n        })\n        .then((stream) => { // 获取麦克风的音频流\n            const audioCtx = new AudioContext(); \n            const source = audioCtx.createMediaStreamSource(stream);\n            // 创建 音频分析器\n            const analyser = audioCtx.createAnalyser();\n\t\t\t\t\n            analyser.fftSize = 2048;\n            const bufferLength = analyser.frequencyBinCount;\n          \t// 音频数据会放在 dataArray中\n            const dataArray = new Uint8Array(bufferLength);\n\t\t\t\n            source.connect(analyser);\n            analyser.connect(audioCtx.destination);\n\n            function draw() {\n                const canvas = document.querySelector(\"#canvas\");\n                const ctx = canvas.getContext(\"2d\");\n\n                const WIDTH = canvas.width;\n                const HEIGHT = canvas.height;\n\t\t\t\t\n                // 取出音频数据，放到dataArray中\n                analyser.getByteTimeDomainData(dataArray); \n\t\t\t\t\n                // ** 绘制波形 start\n                ctx.fillStyle = \"rgb(200, 200, 200)\";\n                ctx.fillRect(0, 0, WIDTH, HEIGHT);\n\n                ctx.lineWidth = 1;\n                ctx.strokeStyle = \"rgb(0, 0, 0)\";\n\n                var sliceWidth = (WIDTH * 1.0) / bufferLength;\n                var x = 0;\n\n                ctx.beginPath();\n                for (var i = 0; i < bufferLength; i++) {\n                    let v = dataArray[i] / 128.0,\n                        y = (v * HEIGHT) / 2;\n\n                    if (i === 0) ctx.moveTo(x, y);\n                    else ctx.lineTo(x, y);\n\n                    x += sliceWidth;\n                }\n\n                ctx.lineTo(canvas.width, canvas.height / 2);\n                ctx.stroke();\n                // ** 绘制波形 end\n\n                requestAnimationFrame(draw); // 绘制下一帧\n            }\n\n            draw();\n        })\n        .catch((err) => {\n            console.log(err);\n        });\n    </script>\n  </body>\n</html>\n\n```\n\n","tags":["javascript","网络","WebRTC","audio","video"],"categories":["Media"]},{"title":"WebRTC Introduction","url":"/posts/c51bfcb4.html","content":"\n\n## webRTC简介\n\n### 什么是webRTC？\n\n网络实时通信（Web Real Time Communication），用来实现浏览器之间的实时通信。通常用来传输音视频流，实现视频聊天、直播等功能。\n\n### 兼容性\n\n![pic](../../images/webrtc兼容性.png)\n\nie？ie就不应该有这种需求！！\n\n## webRTC中涉及到的概念\n\n1. sdp：sdp描述了各端的能力（例如支持的音视频解放、传输协议等信息）。建立webRTC连接时，两端会交换对方的sdp。这样就知道对方的信息。\n   1. offer：通常先发送sdp一方的sdp被称为offer\n   2. answer：另一方收到offer后发送的sdp被称为answer\n2. ice candidate：包含了 WebRTC 与远端通信时使用的协议、IP 地址和端口等数据。当双端交换完sdp数据后，就会收集candidate信息。同样双端也要交换candidate数据\n3. NAT： 网络地址转换。由于ipv4地址不够用，我们的个人pc在本地使用的是内网ip（例如:192.168.1.2）。当访问公网上的资源是，请求经过路由器时，会将内网地址转换成公网地址，再发给目的服务器\n4. p2p：点对点（peer to peer）。指连接双端直接通信，不需要经过中间服务器。webRTC就能实现p2p，只有当p2p失败才会采用服务器中继\n\n\n## 建立连接\n\n### 连接流程\n\n![连接流程](../../images/rtc连接时序图.png)\n\n### 编码\n\n```typescript\n// A 端\n\nfunction sendToB() {\n    // ...发送给B\n}\nfunction onMsgFromB(callback) {\n    // 获得来自B的数据\n}\n\nfunction getStreamFromA() {\n    // 获取A的音视频流\n}\n\n// 1. 先建立rtc连接\nconst pc = new RTCpeerConnection()\n// 2. 添加音视频流\nconst stream = getStreamFromA()\nfor (const track of stream.getTracks()) {\n    pc.addTrack(track);\n}\n\n// 3. 创建offer\npc.createOffer().then(offer => {\n    // 4.设置本地\n    pc.setLocalDescription(offer)\n    // 5. 将offer发送给B\n    sendToB({type: 'offer', data: offer})\n})\n\nonMsgFromB(({type, data}) => {\n    if(type === 'answer') {\n        // 12.设置远程answer\n        pc.setRemoteDescription(data)\n    }\n})\n\npc.ontrack = (e) => {\n    const stream = e.streams[0]\n    video.srcObject = stream // 播放流\n}\n\n\n// B端\nfunction sendToA() {\n    // ...发送给A\n}\nfunction onMsgFromA(callback) {\n    // 获得来自A的数据\n}\nfunction getStreamFromA() {\n    // 获取B的音视频流\n}\n// 6. 先建立rtc连接\nconst pc = new RTCpeerConnection()\n\n// 7. 添加音视频流\nconst stream = getStreamFromA()\nfor (const track of stream.getTracks()) {\n    pc.addTrack(track);\n}\n\nonMsgFromB(({type, data}) => {\n    if(type === 'offer') {\n        // 8. 设置offer\n        pc.setRemoteDescription(data)\n        // 9.创建answer\n        pc.createAnswer().then(answer => {\n            // 10.设置本地\n            pc.setLocalDescription(answer)\n            // 11. 将answer发送给A\n            sendToB({type: 'answer', data: answer})\n        })\n    }\n})\n\npc.ontrack = (e) => {\n    const stream = e.streams[0]\n    video.srcObject = stream // 播放流\n}\n```\n\n> 添加流用的是addTrack没有使用addStream（即将废弃）。addtrack 和 ontrack 是最新的API。\n>\n> 视频流的获取，请参考另一篇文章[浏览器中的音视频](https://zxffan.github.io/posts/4dbf3745.html)\n\n## candidate\n\n双端交换sdp后，并未真正建立连接。然后还需要收集双方的candidate（不止一个哦）并交换。然后浏览器会按照candidate列表逐一测试连通性，直到有一条candidate连接，webRTC连接才算真正的建立。\n\n### 连接流程\n\n![ice candidate](../../images/ice_candidate.png)\n\nSTUN和TURN下面会展开，暂且理解为部署在服务器上的服务，用来获取数据生成candidate的。\n\n### 编码\n\n```typescript\n// 基于上面修改\n// 1. 请求， RTCpeerConnection会自己做\n\n// A 端\n// 2. 服务器（STUN/TURN）返回candidate\npc.onicecandidate = (iceEvent) => {\n    // 3. 发送iceEvent(或者直接发送candidate也可以)给B端\n    sendToB({type: 'candidate', data: iceEvent})\n}\nonMsgFromB(({type, data}) => {\n    \n    // ...\n    \n    if(type === 'candidate') {\n        pc.addIceCandidate(data.candidate)\n    }\n})\n\n// B 端\n\n// 5. 服务器（STUN/TURN）返回candidate\npc.onicecandidate = (iceEvent) => {\n    // 6. 发送iceEventf给A端\n    sendToA({type: 'candidate', data: iceEvent})\n}\nonMsgFromB(({type, data}) => {\n  \n    // ...\n    \n    if(type === 'candidate') {\n        // 4. 设置A端发来的的candidate\n        pc.addIceCandidate(data.candidate)\n    }\n})\n```\n\n## STUN/TURN\n\nSTUN和TURN是两个服务，RTCPeerConnection会自动请求这两个服务来获取candidate。\n\n```typescript\n// 基于上面的代码\n\n// A端 & B端\n\n// 建立RTCpeerConnection时，配置服务地址\nconst pc = new RTCpeerConnection({\n  iceServers: [\n    { urls: \"stun:47.94.xxx.xx:3478\" },\n    { urls: \"turn:47.94.xxx.xx:3478\", username: \"usrname\", credential: \"password\" },\n  ],\n})\n\n\n```\n\n### STUN\n\n两个处于不同网段的客户端需要点对点通信必须知道对方的公网ip，并且在双方的NAT映射表中必须有一条映射记录。STUN服务用来获取公网地址。处于不同网段的两台客户端，需要访问STUN服务来获取其公网地址。\n\n### TURN\n\n当点对点通信失败后，将会采用中继的方式。也就是数据走服务器转发。TURN就是用来实现中继的。\n\n### 部署STUN/TURN\n\n`conturn`应该是比较知名的STUN/TURN服务器。\n\n如何部署请自行查阅资料，或参考官方[git repo](https://github.com/coturn/coturn)\n\n### candidate列表\n\n以下测试，A端（192.168.1.134）和B端（192.168.1.134）都是我本机。\n\nwebRTC的candidate分为三类\n\n- host 类型，即本机内网的 IP 和端口\n- srflx 类型, 即本机 NAT 映射后的外网的 IP 和端口\n- relay 类型，即中继服务器的 IP 和端口\n\n![candidate-list](../../images/candidate-list.png)\n\n1. webRTC会先测试host类型的candidate。这种类型时最容易收集的。就算没有配置STUN/TURN也能收集到。如果测通了就没必要往下测试了。\n2. srflx类型的candidate包含公网ip信息。它是从stun服务器获取的。\n3. 当前两种都没连通，就会测试relay类型的candidate，也就是通过turn服务进行中继。\n\n## 信令服务\n\n前面写了这么一段代码\n\n```typescript\n// A端\nfunction sendToB() {\n    // ...发送给B\n}\nfunction onMsgFromB(callback) {\n    // 获得来自B的数据\n}\n\n// B端同理\n```\n\n埋了一个伏笔，sendToB如何实现。答案就是信令服务\n\n### 概念\n\n信令服务就是在通信的双端之间搭建的一个用于建立webRTC连接的服务，用于转发sdp、candidate等。\n\n信令服务可以是一个webSocket服务，用来进行A、B端之间的媒体协商。\n\n> 媒体协商就是指交换sdp和candidate的过程\n\n### 流程\n\n![信令服务](../../images/信令服务.png)\n\n### 编码\n\n```typescript\nconst WebSocket = require(\"ws\");\nconst wss = new WebSocket.Server({ port: 3001 });\nconst code2Ws = new Map();\n\nwss.on(\"connection\", (ws, request) => {\n  ws.isAlive = true;\n  let code;\n  ws.sendData = (event, data) => {\n    ws.send(JSON.stringify({ event, data }));\n  };\n\n  ws.sendError = (msg) => ws.sendData(\"error\", msg);\n\n  ws.on(\"message\", (message) => {\n    try {\n      const parsedMsg = JSON.parse(message);\n      const { event, data } = parsedMsg;\n\n      switch (event) {\n        case \"login\":\n          //  为客户端生成唯一标识，也可以由客户端发送标识（如mac地址）\n          code = data.code || Math.floor(Math.random() * (9999999 - 1000000)) + 100000 + \"\";\n          code2Ws.set(code, ws); // 记录\n          ws.sendData(\"login\", { code }); // 范围标识\n          break;\n        case \"communicate\":\n          const remote = data.remote; // 需要通信的客户端标识\n          if (code2Ws.has(remote)) { // 存在就建立两端之间的映射关系\n            ws.sendData(\"communicate\", { success: true }); // 通知A端\n            ws.sendRemote = code2Ws.get(remote).sendData;\n            code2Ws.get(remote).sendRemote = ws.sendData;\n            ws.sendRemote(\"communicate\", { remote: code }); // 通知B端\n          } else {\n            ws.sendData(\"communicate\", { success: false }); // 没有，则通知A，失败\n          }\n          break;\n        case \"forward\":\n          ws.sendRemote && ws.sendRemote(data); // 转发消息\n          break;\n      }\n    } catch (e) {\n      ws.sendError(\"message invalid\");\n      return;\n    }\n  });\n  \n  // 连接关闭 就删除当前客户端的标识\n  ws.on(\"close\", () => {\n    code2Ws.delete(code);\n  });\n});\n\n// 定时检测连接\nconst interval = setInterval(function ping() {\n  wss.clients.forEach(function each(ws) {\n    if (ws.isAlive === false) return ws.terminate();\n\n    ws.isAlive = false;\n  });\n}, 5 * 60 * 1000);\n\nwss.on(\"close\", function close() {\n  clearInterval(interval);\n});\n\n```\n\n## 数据通道（RTCDataChannel）\n\n媒体协商一旦完成就可以关闭与信令服务的连接即关闭webSocket连接。之后的数据传输可以通过`数据通道`来传输。\n\n### 概念\n\n建立webRTC连接的两端能够开辟一个数据通道，用来传输非音视频流数据，比如文字聊天、文件传输、远程桌面、游戏控制、P2P 加速等。\n\n###  双向通信\n\nRTCDataChannel可以实现双向通信，有两种模式\n\n- `In-band`(默认)：假设通信双方中的一方调用 createDataChannel 创建 RTCDataChannel 对象时，将 options 参数中的 negotiated 字段设置为 false，则通信的另一方就可以通过它的 RTCPeerConnection 对象的 ondatachannel 事件来得到与对方通信的 RTCDataChannel 对象了，这种方式就是 In-band 协商方式。\n- `Out-fo-band`：这种方式不再是一端调用 createDataChannel，另一端监听 ondatachannel 事件，从而实现双方的数据通信；而是两端都调用 createDataChannel 方法创建 RTCDataChannel 对象，再通过 ID 绑定来实现双方的数据通信。\n\n### 实现\n\n#### In-band\n\n```typescript\n// A端\nconst pc = new RTCPeerConnection({ negotiated: true });\nconst dc = pc.createDataChannel(\"my channel\");\n\ndc.onmessage = function (event) {\n    console.log(\"received: \" + event.data);\n};\n\ndc.onopen = function () {\n    console.log(\"datachannel open\");\n};\n\ndc.onclose = function () {\n    console.log(\"datachannel close\");\n};\n\n// B端\npc.ondatachannel = (e) => {\n    const dc = e.channel // 获取\n    dc.onmessage = (e) => {\n        console.log(e.data)\n    };\n};\n```\n\n#### out-of-band\n\n```typescript\n// A 端\nconst pc = createDataChannel({ negotiated: true, id: 0 });\nconst dc = pc.createDataChannel(\"my channel\");\n\ndc.onmessage = function (event) {\n    console.log(\"received: \" + event.data);\n};\n\ndc.onopen = function () {\n    console.log(\"datachannel open\");\n};\n\ndc.onclose = function () {\n    console.log(\"datachannel close\");\n};\n\n// B 端\nconst pc = createDataChannel({ negotiated: true, id: 0 });\nconst dc = pc.createDataChannel(\"my channel\");\n\ndc.onmessage = function (event) {\n    console.log(\"received: \" + event.data);\n};\n\ndc.onopen = function () {\n    console.log(\"datachannel open\");\n};\n\ndc.onclose = function () {\n    console.log(\"datachannel close\");\n};\n```\n\n>注意：RTCDataChannel对象需要在媒体协商前创建。\n\n## 总结\n\n本文只讨论如何使用webRTC建立一对一通信。没有涉及到多对多场景。\n\n稍稍想想，如果考虑多对多的话，信令服务器应该设计成一个房间而不是现在这种映射表，数据流应该也要通过一个流媒体服务器，应该不能是p2p了。待我先研究一下，有时间再写一篇关于实现多对多的方案。\n\n","tags":["javascript","网络","WebRTC"],"categories":["Media"]},{"title":"正则表达式","url":"/posts/2f57a694.html","content":"\n## REGEXP对象\n\n两种实例化RegExp对象\n\n1. 字面量\n2. 构造函数\n\n```javascript\n// 字面量\nvar reg = /\\bis\\b/  // \\b表示单词边界\n\n'He is a boy. This is a dog. Where is she?'.replace(reg, 'IS') // 只会替换一处\n// He IS a boy. This is a dog. Where is she\n\nreg = /\\bis\\b/g // g 代表 global\n'He is a boy. This is a dog. Where is she?'.replace(reg, 'IS') // 指挥替换一处\n// He IS a boy. This IS a dog. Where IS she\n\n\n\n// 构造函数\nvar  reg = new RegExp('\\\\bis\\\\b', 'g')\n'He is a boy. This is a dog. Where is she?'.replace(reg, 'IS') // 指挥替换一处\n// He IS a boy. This IS a dog. Where IS she\n```\n\n## 修饰符\n\n1. g：global 全文搜索\n2. i：忽略大小写\n3. m：多行搜索\n\n## 元字符\n\n正则表达式有两种基本字符类型组成\n\n1. 愿意文本字符 abc\n2. 元字符（含有特殊含义的非字母字符）\n\n## 字符类\n\n元字符[]来构建一个类，来匹配一类字符\n\n[abc]来匹配a或b或c\n\n^可以创建反向类，\\[^abc]表示不是a或b或c的字符\n\n## 范围类\n\n[a-z]表示a到z的任意字符（包含a和z）\n\n[a-zA-z]\n\n[0-9]\n\n[0-9-]匹配0到9和横线-\n\n## 预定义类\n\n| 字符 | 等价类          | 含义                             |\n| ---- | --------------- | -------------------------------- |\n| .    | [^\\r\\n]         | 除了回车符和换行符之外的所有字符 |\n| \\d   | [0-9]           | 数字字符                         |\n| \\D   | [^0-9]          | 非数字字符                       |\n| \\s   | [\\t\\n\\x0B\\f\\r]  | 空白符                           |\n| \\S   | [^\\t\\n\\x0B\\f\\r] | 非空白符                         |\n| \\w   | [a-zA-Z_0-9]    | 单词字符（数字、字母下划线）     |\n| \\W   | [^a-zA-Z_0-9]   | 非单词字符                       |\n\n## 边界\n\n| 字符 | 含义       |\n| ---- | ---------- |\n| ^    | 以xxx开始  |\n| $    | 以xxx结束  |\n| \\b   | 单词边界   |\n| \\B   | 非单词边界 |\n\n## 量词\n\n| 字符  | 含义                     |\n| ----- | ------------------------ |\n| ？    | 出现零次或一次           |\n| +     | 出现一次或多次           |\n| *     | 出现零次或多次（任意次） |\n| {n}   | 出现n次                  |\n| {n,m} | 出现n到m次               |\n| {n,}  | 至少出现n次              |\n\n## 贪婪模式和非贪婪模式\n\n```javascript\n'12345678'.replace(/\\d{3,6}/g, 'X') // 会尽量多地匹配-贪婪模式\n// X78\n\n// 在量词后面加上?-非贪婪模式\n'12345678'.replace(/\\d{3,6}?/g, 'X') // 非贪婪模式\n// XX78\n```\n\n## 分组\n\n使用()实现分组的功能\n\n```javascript\n'a1b2c3d4'.replace(/[a-z]\\d{3}/g, 'X')\n// a1b2c3d4\n\n'a1b2c3d4'.replace(/([a-z]\\d){3}/g, 'X')\n// Xd4\n```\n\n## 或\n\n使用|可以实现或的效果\n\n## 反向引用\n\n2015-12-25 => 12-25-2015\n\n```js\n'2015-12-25'.replace(/(\\d{4})-(\\d{2})-(\\d{2})/g, '$2-$3-$1')\n// 12-25-2015\n```\n\n## 忽略分组\n\n使用?:来忽略分组\n\n(?:Byron).(ok)\n\n$1指的是 ok\n\n## 断言\n\n正则表达式从文本头部向尾部开始解析，文本尾部方向，成为“正向”\n\n正向断言就是在正则表达式匹配到规则的时候，向前检查是否符合断言\n\nJavaScript不支持反向断言\n\nES2018（ES9）新增反向断言\n\n符合和不符合特定断言成为肯定/正向匹配和否定/反向匹配\n\n| 名称         | 正则           | 含义 |\n| ------------ | -------------- | ---- |\n| 正向断言     | exp(?=assert)  |      |\n| 否定正向断言 | exp(?!assert)  |      |\n| 反向断言     | exp(?<=assert) |      |\n| 否定反向断言 | exp(?<!assert) |      |\n|              |                |      |\n\n```javascript\n'a2*34v8'.replace(/\\w(?=\\d)/g, 'X')\n// X2*34X8\n\n'a2*34vv'.replace(/\\w(?!\\d)/g, 'X')\n// aX*3XXX\n\nvar match = /(?<=\\D)\\d+/.exec('$123.89')\nconsole.log( match[0] ); // 123\n\nvar match = /(?<!\\D)\\d+/.exec('$123.89')\nconsole.log( match[0] ); // 23\n\n```\n\n## 对象属性\n\nglobal: 是否全文搜索，默认false\n\nignore case：是否大小写敏感，默认false\n\nmultiline：多行搜索，默认false\n\nlastIndex：是当前白表达式匹配内容最后一个字符的下一个位置\n\nsource：正则表达式的文本字符串\n\n## 正则表达式的方法\n\n### test方法\n\n检测字符串中是否有匹配正则的内容，若有返回true，没有返回false\n\n```javascript\nvar reg1 = /\\w/\nvar reg2 = /\\w/g\n\nreg1.test('a') // true\nreg2.test('$') // false\n\nwhile(reg2.test('ab')) {\n    console.log(reg2.lastIndex)\n}\n// 1\n// 2\n```\n\n**坑**\n\n使用test时，正则表达式不要使用g（全局匹配），如下\n\n```javascript\nvar reg = /\\w/g\nundefined\nreg.test(\"wom\")\n// true\nreg.test(\"wom\")\n// true\nreg.test(\"wom\")\n// true\nreg.test(\"wom\")\n// false\nreg.test(\"wom\")\n// true\n```\n\n第四次匹配变成了false，这是因为每次匹配都会改变reg的lastIndex属性。下次匹配在从lastIndex位置开始匹配。第四次匹配前lastIndex为3，从index为3的位置开启匹配所以匹配不到，这次匹配完后lastIndex又改成0所以下次又能匹配到。\n\n### exec方法\n\n未匹配到返回null，匹配到返回一个结果数组\n\n返回的数组\n\n1. 第一个元素是与正则表达式相匹配的文本\n2. 第二个元素是与RegExpObject的第一个子表达式相匹配的文本（如果有的话），子表达式就是分组，也就是指分组匹配的文本\n3. 第三个元素是与RegExp对象的第二个子表达式相匹配的文本（如果有的话），依此类推\n\n```javascript\nvar reg1 = /\\d(\\w)(\\w)\\d/\nvar reg2 = /\\d(\\w)(\\w)\\d/g\n\nvar ts = \"ab1cd2fg3hi4jk5mop\"\n\n// 非全局匹配-不存在lastIndex\nvar ret = reg1.exec(ts)\nconsole.log(ret)\n/* 输出\n [\"1cd2\", \"c\", \"d\", index: 2, input: \"ab1cd2fg3hi4jk5mop\", groups: undefined]\n*/\n\n\n\n// 全局匹配-需要循环，每次匹配修改lastIndex的值\nvar ret\nwhile(ret = reg2.exec(ts)) {\n  console.log(ret)\n}\n/*\n[\"1cd2\", \"c\", \"d\", index: 2, input: \"ab1cd2fg3hi4jk5mop\", groups: undefined]\n\n[\"3hi4\", \"h\", \"i\", index: 8, input: \"ab1cd2fg3hi4jk5mop\", groups: undefined]\n*/\n```\n\n## 字符串对象的方法\n\n### search方法\n\nsearch()用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串\n\n方法返回第一个匹配结果index，查不到返回-1\n\n### match方法\n\nmatch()方法将检索字符串，以找到一个或多个与regexp匹配的文本\n\nregexp是否具有标志g对结果影响很大，\n\n1. 如果regexp没有标志位g，那么match（）方法就只能在字符串中执行一次匹配如果没有找到任何匹配的文本，将返回null \n\n```javascript\nvar reg1 = /\\d(\\w)(\\w)\\d/\nvar reg2 = /\\d(\\w)(\\w)\\d/g\n\nvar ts = \"ab1cd2fg3hi4jk5mop\"\n\nts.match(reg1)\n//[\"1cd2\", \"c\", \"d\", index: 2, input: \"ab1cd2fg3hi4jk5mop\", groups: undefined]\n```\n\n2. 否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息\n\n```javascript\nts.match(reg2)\n// [\"1cd2\", \"3hi4\"]\n```\n\n### split方法\n\n```js\n'a1b2c3d4'.split(/\\d/)\n// ['a', 'b', 'c', 'd']\n```\n\n### replace方法\n\n```js\n'a1b'.replace('1', 2) // a2b\n\n'a1b1c1'.replace('1', '2') // a2b1c1\n'a1b1c1'.replace(/1/g, '2') // a2b2c2\n\n'a1b2c3d4'.replace(/\\d/g, function(match, index, origin) {\n  console.log(match,index,origin);\n  return +match + 1\n})\n/*\n1 1 a1b2c3d4\n2 3 a1b2c3d4\n3 5 a1b2c3d4\n4 7 a1b2c3d4\n\"a2b3c4d5\"\n*/\n```","tags":["javascript","regExp"],"categories":["JavaScript"]},{"title":"HTTPS工作流程","url":"/posts/ef0f9b3a.html","content":"## HTTP与HTTPS\n\nHTTP(超文本传输协议)，有着一个致命的缺陷，那就是内容是**明文传输**的，没有经过任何加密，而这些明文数据会经过**WiFi、路由器、运营商、机房**等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露，，这一攻击手法叫做MITM（Man In The Middle）**中间人**攻击。\n\n常见的如运行商劫持，推送广告\n\n![劫持](../../images/network/运营商劫持.webp)\n\n## HTTPS工作流程\n\n![https](../../images/network/HTTP-process.webp)\n\n1. 客户端发送HTTPS请求（默认端口443）\n2. 服务端有一套`CA数字证书`，证书含有一个`公钥public`。服务端接收到请求，会将这个证书发送给客户端。服务端还有一个`私钥private`，私钥是一直保存再服务端不公开的。\n3. 客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续。\n4. 客户端先生成一段`随机key`，再利用证书中的`公钥public`加密这段`随机key`，并将这个`随机key密文`发送给服务端。\n5. 服务端收到这个`随机key密文`文后，通过`私钥private`来解密，获取客户端真正的`随机key`\n6. 服务端使用`随机key`来加密需要传输的HTTP数据，并发送给客户端\n7. 客户端再用`随机key`来解密服务端传输过来的密文，获取真正的数据\n8. 后续HTTPS请求使用之前交换好的`随机Key`进行对称加解密。\n\n>  由于随机key明文没有再网络上传输，所以\"中间人\"并不知道用于加密和解密的随机key，因此是安全的\n\n## 对称加密和非对称加密\n\nHTTPS的工作流程其实就是 非对称加密+对称加密。\n\n- 非对称加密：公钥加密，私钥解密\n\n- 对称加密：随机key加密解密\n\n**非对称加解密耗时要远大于对称加解密**，对性能有很大损耗\n\n## CA颁发机构\n\n上述的HTTPS工作流程中的CA证书验证十分重要。如果没有它，会发生以下情况：\n\n![劫持](../../images/network/https劫持.webp)\n\n1. 服务端发送公钥A1给客户端，中间人把服务端的公钥替换为自己的公钥B1\n2. 客户端通过公钥B1加密生成K密文，并发送给服务端\n3. 中间人通过自己的私钥B2解密K密文得到K，再用公钥A1加密，发送给服务端\n4. 客户端与服务端通信的K，已被中间人获取，所以不再安全\n\n出现这一问题的核心原因是**客户端无法确认收到的公钥是不是真的是服务端发来的**。为了解决这个问题，互联网引入了一个公信机构，这就是CA。\n\n1. CA机构拥有自己的一对公钥和私钥\n2. CA机构在颁发证书时对证书明文信息进行哈希\n3. 将哈希值用`私钥`进行**加签**，得到数字签名\n\n明文数据和数字签名组成证书，传递给客户端。\n\n1. 客户端得到证书，分解成明文部分Text和数字签名Sig1\n2. 用CA机构的公钥进行**解签**，得到Sig2（由于CA机构是一种公信身份，因此在系统或浏览器中会内置CA机构的证书和公钥信息）\n3. 用证书里声明的哈希算法对明文Text部分进行哈希得到T\n4. 当自己计算得到的哈希值T与**解签**后的Sig2**相等**，表示证书可信，**没有被篡改**","tags":["NetWork","HTTP"],"categories":["NetWork"]},{"title":"手写webpack的plugin","url":"/posts/b6d2303e.html","content":"## 概述\n\n> 一句话：本质上来说， plugin 就是通过监听 compiler 的某些 hook 特定时机，然后处理 stats。\n\n首先我们来看下 Webpack 插件需要包含的几个条件： \n\n- Webapck 的插件必须要是一个类； \n- 该类必须包含一个 apply 的函数，该函数接收 compiler 对象参数； \n- 该类可以使用 Webpack 的 compiler 和 Compilation 对象的钩子； \n- 也可以自定义自己的钩子系统。\n\n```javascript\nclass MyPlugin {\n  constructor(options) {\n    // 自定义配置\n    this.options = options\n  }\n\tapply(compiler) {\n    compiler.hooks.done.tap('MyPlugin', () => {})\n    \n    compiler.hooks.emit.tapPromise('MyPlugin', compilation => {\n      // 返回一个 Promise，在我们的异步任务完成时 resolve……\n      return new Promise((resolve, reject) => {\n        setTimeout(function() {\n          console.log('异步工作完成……');\n          \tresolve();\n          }, 1000);\n        });\n      });\n\t}\n}\n\nmodule.exports = MyPlugin\n```\n\n## 官方DEMO——FileListPlugin\n\n```js\nclass FileListPlugin {\n    apply(compiler) {\n        // emit 是异步 hook，使用 tapAsync 触及它，还可以使用 tapPromise/tap(同步)\n        compiler.hooks.emit.tapAsync('FileListPlugin', (compilation, callback) => {\n            // 在生成文件中，创建一个头部字符串：\n            var filelist = 'In this build:\\n\\n';\n\n            // 遍历所有编译过的资源文件，\n            // 对于每个文件名称，都添加一行内容。\n            for (var filename in compilation.assets) {\n                filelist += '- ' + filename + '\\n';\n            }\n\n            // 将这个列表作为一个新的文件资源，插入到 webpack 构建中：\n            compilation.assets['filelist.md'] = {\n                source: function() {\n                    return filelist;\n                },\n                size: function() {\n                    return filelist.length;\n                }\n            };\n\n            callback();\n        });\n    }\n}\n```\n\n## 自定义 Plugin——prefetch-webpack-plugin\n\n### 实现目标\n\n假如我们有个 `lazy.js` 模块需要 Prefetch，那么可以直接使用如下配置\n\n```javascript\n// 下面是魔法注释 （magic comments）\nimport(/* webpackPrefetch: true */ './lazy');\n```\n\n有了这个注释，在获取 chunk 对象的时候，就可以拿到它的这个标注，从而根据这个注释给页面增加`<link rel=\"prefetch\">`标签。\n\n> Tips： \n>\n> - `/* webpackPrefetch: true */` ：把主加载流程加载完毕，在空闲时在加载其它，等再点击其他时，只需 要从缓存中读取即可，性能更好，推荐使用；能够提高代码利用率，把一些交互后才能用到的代码写到异 步组件里，通过懒加载的形式，去把这块的代码逻辑加载进来，性能提升，页面访问速度更快；*\n> - `/* webpackPreload: true */` : 和主加载流程一起并行加载。\n\n### 原理和实现步骤\n\n1. 首先我们应该利用`compiler.compilation`这个钩子，得到`Compilation`对象；\n2. 然后在`Compilation`对象中监听 html-webpack-plugin 的钩子，拿到 HTML 对象，这里需要区分 html-webpack-plugin 的版本：\n   1. 在`3.x`版本，html-webpack-plugin 的钩子是直接挂在 Compilation 对象上的，我们使用的是`compilation.hooks.htmlWebpackPluginAfterHtmlProcessing`；\n   2. 在`4.x`版本（截稿最新版本是 4.0-beta.3）中，html-webpack-plugin 自己使用`Tapable`实现了自定义钩子，需要使用`HtmlWebpackPlugin.getHooks(compilation)`的方式获取自定义的钩子。\n3. 然后我们从`Compilation`对象中读取当前 HTML 页面的所有`chunks`，筛选异步加载的 chunk 模块，这里有两种情况：\n   1. 生成多个 HTML 页面，那么 html-webpack-plugin 插件会设置`chunks`选项，我们需要从 `Compilation.chunks`来选取 HTML 页面真正用到的 chunks，然后在从 chunks 中过滤出 Prefetch chunk；\n   2. 如果是单页应用，那么不存在`chunks`选项，这时候默认`chunks='all'`，我们需要从全部 `Compilation.chunks` 中过滤出 Prefetch chunk。\n4. 最后结合 Webpack 配置的`publicPath`得到异步 chunk 的实际线上地址，然后修改 html-webpack-plugin 钩子得到的 HTML 对象，给 HTML 的``添加``内容。\n\n","tags":["javascript","webpack","架构"],"categories":["Webpack"]},{"title":"手写webpack的loader","url":"/posts/e0efe5dc.html","content":"## 概述\n\nwebpack的loader本质上就是一个函数\n\n```javascript\nmodule.exports = function(content, sourcemap) {\n  // 处理 content 操作...\n  \n  this.callback(null, content) // 或者 return content\n}\n```\n\n> this 是 webpack 调用 loader 时候传入的自定义的特殊上下文，所以不应该使用箭头函数！\n\nthis.callback 可以传入四个参数（其中后两个参数可以省略），分别是： \n\n- error ：当 loader 出错时向外抛出一个 Error 对象，成功则传入 null ；\n- content ：经过 loader 编译后需要导出的内容，类型可以是为 String 或者 Buffer ； \n- sourceMap ：为方便调试生成的编译后内容的 source map； \n- ast : 本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，可以省去重复生成 AST 的 过程。\n\n## loader 异步处理数据\n\n第一种方式是是使用 `async/await` 异步函数写法\n\n```javascript\nmodule.exports = async function(content) {\n  function timeout(delay) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n      \t// 模拟一些异步操作处理 content\n        resolve(content);\n        }, delay);\n      });\n    }\n    const data = await timeout(1000);\n    return data;\n};\n\n```\n\n第二种方式是使用 `this.async` 方法获取一个异步的 callback ，然后返回它。\n\n```javascript\nmodule.exports = function(content) {\n  function timeout(delay) {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        // 模拟异步操作\n        resolve(content)\n      }, delay)\n    })\n  }\n  const callback = this.async()\n  timeout(1000).then(data => {\n    callback(null, data)\n  })\n}\n```\n\n> this.async 获取的 callback，参数也是跟 this.callback 的参数一致，即 error，content，sourcemap 和 ast。\n\n## 处理二进制数据\n\n像 file-loader 这样的 Loader，实际处理的内容是二进制数据，那么就需要通过设置 `moudle.exports.raw = true;` 来告诉 Webpack 给 loader 传入二进制格式的数据。\n\n```javascript\nmodule.exports = function(source) {\n  if (source instanceof Buffer) {\n    // 一系列的操作\n    return source // 本身也可以返回二进制数据提供给下一个loader\n  }\n}\nmodule.exports.raw = true // 不设置，就会拿到字符串\n```\n\n## loader 的 pitch\n\nloader 的执行分为两个阶段，pitch阶段loader从左到右链式调用。而Normal阶段是从右到左的链式调用。\n\n![loader_pitch](../images/framework/loader-pitch.webp)\n\n在一些场景下，loader 并不依赖上一个 loader 的结果，而只关心原输入内容。这时候，要 拿到一开始的文件原内容，就需要使用 `module.exports.pitch = function();`\n\n```javascript\nmodule.exports.pitch = function(remainingRequest, precedingRequest, data) {\n  if (somothingFlag()) {\n  \treturn 'module.exports = require(' + JSON.stringify('-!' + remaining) + ');'\n  }\n  data.value = 1\n}\n```\n\npitch函数的data，在执行阶段也会暴露在 `this.data` 之下，并且可以用于在循环时，捕获和共享前面的信息。\n\n## loader 结果缓存\n\nWebpack 增量编译机制会观察每次编译时的变更文件，在默认情况下，Webpack 会对 loader 的执行结果进行缓 存，这样能够大幅度提升构建速度，不过我们也可以手动关闭它：\n\n```javascript\nmodule.exports = function(content) {\n  this.cacheable(false)\n  return content\n}\n```\n\n## loader 工具库\n\n### loader-utils\n\nloader-utils 提供了各种跟 loader 选项（options）相关的工具函数\n\n```javascript\nconst { getOptions，stringifyRequest, parseQuery } = require('loader-utils');\n\nmodule.exports = function(content) {\n  // getOptions 用于在loader里获取传入的options，返回的是对象值。\n  const options = getOptions(this);\n  \n  // stringifyRequest转换路径，避免require()或impot时使用的绝对路径\n  stringifyRequest(this, './test.js'); // Result => \"\\\"./test.js\\\"\"\n  \n  // parseQuery获取query参数的\n  parseQuery('?name=kev&age=14') // Result => {name: 'kev', age: '14'}\n}\n```\n\n### schema-utils\n\nschema-utils 是 loader 和 plugin 的参数认证器，检测传入的参数是否符合预期\n\n```javascript\nconst validateOptions = require('schema-utils');\n// 下面是一个schema描述\nconst schema = {\n  type: 'object',\n  properties: {\n    name: {\n    \ttype: 'string'\n  \t},\n    test: {\n      anyOf: [{type: 'array'}, {type: 'string'}, {instanceof: 'RegExp'}]\n    },\n    transform: {\n      instanceof: 'Function'\n    },\n    sourceMap: {\n      type: 'boolean'\n    }\n  },\n  additionalProperties: false\n};\n\nmodule.exports = function(source) {\n  // 验证参数的类型是否正确。\n  validateOptions(schema, options, 'loader name');\n};\n```\n\n## loader 上下文\n\nloader 中 this 相关的其它方法和属性 \n\n- this.context : 当前处理转换的文件所在的目录； \n- this.resource : 当前处理转换的文件完整请求路径，包括 querystring； this.resourcePath : 当前处理转换的文件的路径； \n- this.resourceQuery : 当前处理文件的 querystring； \n- this.target : Webpack 配置的 target； \n- this.loadMoudle : 处理文件时，需要依赖其它文件的处理结果时，可以使用 this.loadMoudle(request: strin g, callback: function(err, source, sourceMap, module)) 去获取到依赖文件的处理结果； \n- this.resolve : 获取指定文件的完整路径；\n- this.addDependency : 为当前处理文件添加依赖文件，以便依赖文件发生变化时重新调用 Loader 转换该文件， this.addDependency(file: string) ； \n- this.addContextDependency : 为当前处理文件添加依赖文件目录，以便依赖文件目录里文件发生变化时重新调 用 Loader 转换该文件， this.addContextDependency(dir: string) ； \n- this.clearDependencies : 清除当前正在处理文件的所有依赖； \n- this.emitFile : 输出一个文件，使用的方法为 this.emitFile(name: string, content: Buffer | string, so urceMap: {...}) ； \n- this.emitError ：发送一个错误信息。\n\n## markdown-loader\n\n```javascript\nconst showdown = require('showdown') // 第三方工具，把md转成html\nconst { getOptions } = require('loader-utils')\n\nmodule.exports = function(content) {\n  // 获取options\n  const options = getOptions(this)\n\n  // 获取cache\n  this.cacheable()\n\n  // 初始化showdown转换器\n  const converter = new showdown.Converter(options)\n\n  // 处理content\n  content = converter.makeHtml(content)\n\n  // 返回结果\n  this.callback(null, content)\n}\n\n```","tags":["javascript","webpack","架构"],"categories":["Webpack"]},{"title":"Webpack原理","url":"/posts/e2b02a9e.html","content":"## Webpack工作流程\n\n### 类比\n\nWebpack 可以看做是一个工厂车间， `plugin` 和 `loader` 是车间中的两类机器，工厂有一个车间主任和一个生 产车间。车间主任叫 `Compiler` ，负责指挥生产车间机器 `Compilation` 进行生产劳动， `Compilation` 会首先将 进来的原材料（ `entry` ）使用一种叫做 `loader` 的机器进行加工，生产出来的产品就是 `Chunk` ； `Chunk` 生产出 来之后，会被组装成 `Bundle` ，然后通过一类 `plugin` 的机器继续加工，得到最后的 `Bundle` ，然后运输到对应 的仓库（`output`）。这个工厂的生产线就是 `Tapable`，厂子运作的整个流程都是生产线控制的，车间中有好几 条生产线，每个生产线有很多的操作步骤（ `hook` ），一步操作完毕，会进入到下一步操作，直到生产线全流 程完成，再将产出传给下一个产品线处理。整个车间生产线也组成了一条最大的生产线。\n\n### 工作流程\n\n#### 三个阶段\n\n- 准备阶段：主要任务是创建 Compiler 和 Compilation 对象；\n-  编译阶段：这个阶段任务是完成 modules 解析，并且生成 chunks；\n  - module 解析：包含了三个主要步骤，创建实例、loaders 应用和依赖收集；\n  - chunks 生成，主要步骤是找到每个 chunk 所需要包含的 modules 。 \n- 产出阶段：这个阶段的主要任务是根据 chunks 生成最终文件，主要有三个步骤：模板 Hash 更新，模板渲染 chunk，生成文件。\n\n#### 细化\n\n1. 初始化参数：包括从配置文件和 shell 中读取和合并参数，然后得出最终参数；**shell 中的参数要优于配置文件的**\n2. 使用上一步得到的参数**实例化一个 Compiler 类**，注册所有的插件，给对应的 Webpack 构建生命周期绑定 Hook\n3. 开始编译：执行 Compiler 类的 run 方法开始执行编译\n4. compiler.run 方法调用 compiler.compile ，在 compile 内**实例化一个 Compilation 类**， Compilation 是做构 建打包的事情，主要事情包括： \n   1. 查找入口：根据 entry 配置，找出全部的入口文件\n   2. 编译模块：根据文件类型和 loader 配置，使用对应 loader 对文件进行转换处理\n   3. 解析文件的 AST 语法树\n   4. 找出文件依赖关系\n   5. 递归编译依赖的模块\n5. 递归完后得到每个文件的最终结果，根据 entry 配置生成代码块 chunk\n6. 输出所有 chunk 到对应的 output 路径\n\n![webpack工作流程](../images/framework/webpack-proceed.png)\n\n## Tapable\n\n### 概述\n\n`Tapable`是webpack的核心模块。其原理和nodejs的`EventEmitter` 类似，但是功能更强大，包括多种类型，通过**事件的注册和监听**，触发 Webpack 生命周期中的函数方法。tapable 都是放到对象的 hooks 上，所以我们叫它们 钩子。\n\n```javascript\n// webpack 4.29.6\n// lib/compiler\nclass Compiler extends Tapable {\n  constructor(context) {\n    super();\n    this.hooks = {\n      shouldEmit: new SyncBailHook(['compilation']),\n      done: new AsyncSeriesHook(['stats']),\n      additionalPass: new AsyncSeriesHook([]),\n      beforeRun: new AsyncSeriesHook(['compiler']),\n      run: new AsyncSeriesHook(['compiler']),\n      emit: new AsyncSeriesHook(['compilation']),\n      afterEmit: new AsyncSeriesHook(['compilation']),\n      thisCompilation: new SyncHook(['compilation', 'params']),\n      compilation: new SyncHook(['compilation', 'params']),\n      normalModuleFactory: new SyncHook(['normalModuleFactory']),\n      contextModuleFactory: new SyncHook(['contextModulefactory']),\n      beforeCompile: new AsyncSeriesHook(['params']),\n      compile: new SyncHook(['params']),\n      make: new AsyncParallelHook(['compilation']),\n      afterCompile: new AsyncSeriesHook(['compilation']),\n      watchRun: new AsyncSeriesHook(['compiler']),\n      failed: new SyncHook(['error']),\n      invalid: new SyncHook(['filename', 'changeTime']),\n      watchClose: new SyncHook([]),\n      environment: new SyncHook([]),\n      afterEnvironment: new SyncHook([]),\n      afterPlugins: new SyncHook(['compiler']),\n      entryOption: new SyncBailHook(['context', 'entry'])\n    };\n  }\n}\n\n```\n\n### Tapable中Hook类型\n\nHook 类型可以分为同步（ Sync ）和异步（ Async ），异步又分为并行和串行：\n\n![tapable_hook](../images/framework/tapable_hook.png)\n\n根据使用方式来分，又可以分为 Basic 、 Waterfall 、 Bail 和 Loop 四类，每类 Hook 都有自己的使用要点：\n\n| 类型      | 使用要点                                                                                  | hook                                                               |\n| --------- | ----------------------------------------------------------------------------------------- | ------------------------------------------------------------------ |\n| Basic     | 基础类型，不关心监听函数的返回值，不根据返回值做事情                                      | `SyncHook` 、 `AsyncParallelHook` 和 `AsyncSeriesHook`             |\n| Bail      | 保险式，只要监听函数中有返回值（不为 undefined ），则跳过之后的监听函数（类比Array.find） | `SyncBailHook `、 `AsyncSeriesBailHook` 、 `AsyncParallelBailHook` |\n| Waterfall | 瀑布式，上一步的返回值(非undefined)继续交给下一步处理和使用（类比Array.reduce）           | `SyncWaterfallHook` 和 `AsyncSeriesWaterfallHook`                  |\n| Loop      | 循环类型，如果该监听函数返回 true 则这个监听函数会反复执行，如果返回 undefined 则退出循环 | `SyncLoopHook`                                                     |\n\n### Tapable原理解析\n\nTapable执行分为四步\n\n1. 使用 tap* 对事件进行注册绑定。根据类型不同，提供三种绑定的方式： `tap` 、 `tapPromise` 、 `tapAsync` ，其中 `tapPromise` 、 `tapAsync` 为异步类 Hook 的绑定方法\n2. 使用 call* 对事件进行触发，根据类型不同，也提供了三种触发的方式： `call` 、 `promise` 、 `callAsync` \n3. 生成对应类型的代码片段（要执行的代码实际是拼字符串拼出来的）\n4. 生成第三步生成的代码片段。\n\n### 总结 \n\nTapable 是 Webpack 的核心模块，Webpack 的所有工作流程都是通过 Tapable 来实现的。Tapable 本质上是提供 了多种类型的事件绑定机制，根据不同的流程特点可以选择不同类型的 Hook 来使用。Tapable 的核心实现在绑定 事件阶段跟我们平时的自定义 JavaScript事件绑定（例如EventEmitter）没有太大区别，但是在事件触发执行的时 候，会临时生成可以执行的函数代码片段。通过这种实现方式，Tapable 实现了强大的事件流程控制能力，也增加 了如 waterfall / parallel 系列方法，实现了异步/并行等事件流的控制能力。\n\n## Compiler 和 Compilation\n\ncompiler和compilation都继承Tapable，不同点是Compiler是每 个 Webpack 的配置，对应一个Compiler对象，记录着整个 Webpack 的生命周期；在构建的过程中，每次构建都 会产生一次Compilation，Compilation则是构建周期的产物。\n\n### Compiler\n\n每次执行webpack构建的时候，webpack内部都会实例化一个`Compiler`对象，然后调用它的`run`方法开始一次完整的编译过程。\n\n```javascript\nconst webpack = require('webpack')\nconst webpackConfig = require('./webpack.config.js')\n\n// 只传入config\nconst compiler = webapck(webpackConfig)\n\n// 执行\ncompiler.run()\n\n// 上面两句等价于\nwebpack(webpackConfig, callback)\n```\n\n> 使用`webpack-dev-server`API方式时，只需要将compiler对象给dev server即可，不需要手动执行`compiler.run()`；如果需要手动实例化`Compiler`对象，可以通过`const Compiler = webpack.Compiler`来获取它的类。\n\n### Compiler钩子\n\n| 钩子名               | Tapable 类型      | 触发时机                                                         | 传入 callback 的参数               |\n| :------------------- | :---------------- | :--------------------------------------------------------------- | :--------------------------------- |\n| entryOption          | SyncBailHook      | 在 webpack 中的 entry 配置处理过之后                             | `context`，`entry`                 |\n| afterPlugins         | SyncHook          | 初始化完内置插件之后                                             | `compiler`                         |\n| afterResolvers       | SyncHook          | resolver 完成之后（后面解释resolver是什么）                      | `compiler`                         |\n| environment          | SyncHook          | 准备编译环境，webpack plugins配置初始化完成之后                  | `compiler`                         |\n| afterEnvironment     | SyncHook          | 编译环境准备好之后                                               | `compiler`                         |\n| beforeRun            | AsyncSeriesHook   | 开始正式编译之前                                                 | `compiler`                         |\n| run                  | AsyncSeriesHook   | 开始编译之后，读取 records 之前；监听模式触发`watch-run`         | `compiler`                         |\n| watchRun             | AsyncSeriesHook   | 监听模式下，一个新的编译触发之后                                 | `compiler`                         |\n| normalModuleFactory  | SyncHook          | NormalModuleFactory 创建之后                                     | `normalModuleFactory`实例          |\n| contextModuleFactory | SyncHook          | ContextModuleFactory 创建之后                                    | `contextModuleFactory`实例         |\n| beforeCompile        | AsyncSeriesHook   | compilation 实例化需要的参数创建完毕之后                         | `compilationParams`                |\n| compile              | SyncHook          | 一次 compilation 编译创建之前                                    | `compilationParams`                |\n| thisCompilation      | SyncHook          | 触发 compilation 事件之前执行                                    | `compilation`，`compilationParams` |\n| compilation          | SyncHook          | compilation创建成功之后                                          | `compilation`，`compilationParams` |\n| make                 | AsyncParallelHook | 完成编译之前                                                     | `compilation`                      |\n| afterCompile         | AsyncSeriesHook   | 完成编译和封存（seal）编译产出之后                               | `compilation`                      |\n| shouldEmit           | SyncBailHook      | 发布构建后资源之前触发，回调必须返回`true`/`false`，`true`则继续 | `compilation`                      |\n| emit                 | AsyncSeriesHook   | 生成资源到 output 目录之前                                       | `compilation`                      |\n| afterEmit            | AsyncSeriesHook   | 生成资源到 output 目录之后                                       | `compilation`                      |\n| done                 | AsyncSeriesHook   | compilation完成之后                                              | `stats`                            |\n| failed               | SyncHook          | compilation失败                                                  | `error`                            |\n| invalid              | SyncHook          | 监听模式下，编译无效时                                           | `fileName`，`changeTime`           |\n| watchClose           | SyncHook          | 监听模式停止                                                     | 无                                 |\n\n> Tips：整个`Compiler`完整地展现了 Webpack 的构建流程：\n>\n> - 准备阶段：run之前做的事情都属于准备阶段，这阶段的calback入参以compiler为主； \n> - 编译阶段：这阶段以compilation的钩子为主，calback入参以compilation为主； \n> - 产出阶段：这阶段从compilation开始，最后回到Compiler钩子上，calback传入参数是跟结果相关的数据，包括stats、error\n\n钩子的调用需要使用`tap`、`tapPromise`或`tapAsync`\n\n```javascript\ncompiler.hooks.someHook.tap('MyPlugin', params => {    /* ... */ });\n```\n\n注解1: Resolver\n\nCompiler 的 Resolver 是指来自于enhanced-resolve模块，它主要功能是一个提供异步require.resolve()，即从哪里去查找文件的路径，可以通过Webpack的resolve和resolveLoader来配置。Compiler类有三种类型的内置 Resolver：\n\n- Normal：通过绝对路径或相对路径，解析一个模块； \n- Context：通过给定的上下文（context）解析一个模块； \n- Loader：解析一个 webpack loader。\n\n注解2： ：`thisCompilation`和`compilation`\n\n这里为什么会有 thisCompilation和compilation 两个钩子呢？其实是跟子编译（child compiler）有关， Compiler 实例通过 createChildCompiler 方法可以创建子编译实例 childCompiler。创建childCompiler时，childCompiler会复制 compiler 实例的任务点监听器。compilation的钩子会被复制，而 的钩子会被复制，而 thisCompilation 钩子则 钩子则不会被复制。\n\n### Compilation\n\n在 Compilation 阶段，模块会被加载(loaded)、封存(sealed)、优化(optimized)、分块(chunked)、哈希(hashed)和重新创建(restored)，Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以监听（watch）模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展，通过 Compilation 也能读取到 Compiler 对象。\n\n#### Compilation钩子\n\ncompilation先从单个 module 开始处理，查找依赖关系， 最后完成单个module 处理，完成全部modules 之后，开始 chunks 阶段处理，最后在根据优化配置，按需生成 assets。\n\n带★是比较重要的\n\n| 钩子名                    | Tapable 类型      | 触发时机                                                                  | 传入 callback 的参数                             |\n| :------------------------ | :---------------- | :------------------------------------------------------------------------ | :----------------------------------------------- |\n| buildModule               | SyncHook          | 在模块构建开始之前触发                                                    | `module`                                         |\n| rebuildModule             | SyncHook          | 在重新构建一个模块之前触发                                                | `module`                                         |\n| failedModule              | SyncHook          | 模块构建失败时执行                                                        | `module`，`error`                                |\n| succeedModule             | SyncHook          | 模块构建成功时执行                                                        | `module`                                         |\n| finishModules             | SyncHook          | 所有模块都完成构建                                                        | `module`                                         |\n| finishRebuildingModule    | SyncHook          | 一个模块完成重新构建                                                      | `module`                                         |\n| seal                      | SyncHook          | ★编译（compilation）停止接收新模块时触发                                  | `module`                                         |\n| unseal                    | SyncHook          | 编译（compilation）开始接收新模块时触发                                   | `module`                                         |\n| optimizeDependencies      | SyncBailHook      | 依赖优化开始时触发                                                        | `modules`                                        |\n| afterOptimizeDependencies | SyncHook          | 依赖优化结束时触发                                                        | `modules`                                        |\n| optimize                  | SyncHook          | ★优化阶段开始时触发                                                       | `modules`                                        |\n| optimizeModules           | SyncBailHook      | ★模块的优化                                                               | `modules`                                        |\n| afterOptimizeModules      | SyncHook          | 模块优化结束时触发                                                        | `modules`                                        |\n| optimizeChunks            | SyncBailHook      | ★优化 chunks                                                              | `chunks`                                         |\n| afterOptimizeChunks       | SyncHook          | chunk 优化完成之后触发                                                    | `chunks`                                         |\n| optimizeTree              | AsyncSeriesHook   | 异步优化依赖树                                                            | `chunks`，`modules`                              |\n| afterOptimizeTree         | SyncHook          | 异步优化依赖树完成时                                                      | `chunks`，`modules`                              |\n| optimizeChunkModules      | SyncBailHook      | 优化单个chunk中的 modules 开始                                            | `chunks`                                         |\n| afterOptimizeChunkModules | SyncHook          | 优化单个chunk中的 modules 结束                                            | `chunks`                                         |\n| shouldRecord              | SyncHook          |                                                                           | `chunks`                                         |\n| reviveModules             | SyncHook          | 从 records 中恢复模块信息                                                 | `modules`，`records`                             |\n| optimizeModuleOrder       | SyncHook          | 将模块从最重要的到最不重要的进行排序                                      | `chunks`                                         |\n| beforeModuleIds           | SyncHook          | 处理 modulesId 之前                                                       | `modules`                                        |\n| moduleIds                 | SyncHook          | 处理 modulesId                                                            | `modules`                                        |\n| optimizeModuleIds         | SyncHook          | 优化 modulesId                                                            | `chunks`                                         |\n| afterOptimizeModuleIds    | SyncHook          | 优化 modulesId之后                                                        | `chunks`                                         |\n| reviveChunks              | SyncHook          | 从 records 中恢复 chunk 信息                                              | `modules`，`records`                             |\n| optimizeChunkOrder        | SyncHook          | 将 chunk 从最重要的到最不重要的进行排序                                   | `chunks`                                         |\n| beforeOptimizeChunkIds    | SyncHook          | chunk id 优化之前触发                                                     | `chunks`                                         |\n| optimizeChunkIds          | SyncHook          | chunk id 优化开始触发                                                     | `chunks`                                         |\n| afterOptimizeChunkIds     | SyncHook          | chunk id 优化结束触发                                                     | `chunks`                                         |\n| recordModules             | SyncHook          | 将模块信息存储到 records                                                  | `modules`，`records`                             |\n| recordChunks              | SyncHook          | 将 chunk 信息存储到 records                                               | `chunks`，`records`                              |\n| beforeHash                | SyncHook          | 在编译被哈希（hashed）之前                                                | -                                                |\n| afterHash                 | SyncHook          | 在编译被哈希（hashed）之后                                                | -                                                |\n| record                    | SyncHook          | 将 compilation 相关信息存储到 records 中                                  | `compilation`，`records`                         |\n| beforeChunkAssets         | SyncHook          | 在创建 chunk 资源（asset）之前                                            | `chunks`                                         |\n| additionalChunkAssets     | SyncHook          | 为 chunk 创建附加资源（asset）                                            | `chunks`                                         |\n| additionalAssets          | AsyncSeriesHook   | ★为编译（compilation）创建附加资源（asset）                               | -                                                |\n| optimizeChunkAssets       | AsyncSeriesHook   | ★优化所有 chunk 资源（asset）                                             | `chunks`                                         |\n| afterOptimizeChunkAssets  | SyncHook          | chunk 资源（asset）已经被优化                                             | `chunks`                                         |\n| optimizeAssets            | AsyncSeriesHook   | ★优化存储在 compilation.assets 中的所有资源（asset）                      | `assets`                                         |\n| afterOptimizeAssets       | SyncHook          | 优化compilation.assets 中的所有资源（asset）之后                          | `assets`                                         |\n| moduleAsset               | SyncHook          | 一个模块中的一个资源被添加到编译中                                        | `module`，`filename`                             |\n| chunkAsset                | SyncHook          | 一个 chunk 中的一个资源被添加到编译中                                     | `chunk`，`filename`                              |\n| assetPath                 | SyncWaterfallHook | asset 路径确认之后                                                        | `filename`，`data`                               |\n| childCompiler             | SyncHook          | 子编译（compiler）触发                                                    | `childCompiler`，`compilerName`，`compilerIndex` |\n| normalModuleLoader        | SyncHook          | ★普通模块 loader，真正（一个接一个地）加载模块图（graph）中所有模块的函数 | `loaderContext`，`module`                        |\n\n#### Stats\n\n在webpack的回调函数——`webpack(cofnig, (err, stats) => {})`中会得到stats对象，这个对象实际来自于`Compilation.getStats()`，返回的是主要含有`modules`、`chunks`和`assets`三个属性值的对象。\n\n- modules： 记录了所有解析后的模块\n- chunks：记录了所有chunk\n- assets：记录了所有要生成的文件\n\nStats对象本质是来自于`lib/Stats.js`的类的实例。常用的方法：\n\n- stats.hasWarnings()\n- stats.hasErrors()\n- stats.toJson()\n- stats.toString()\n\n#### Stats对象数据结构\n\n在webpack的回调中获取stats，然后再调用`toJson`方法获取stats的数据接口\n\n```javascript\nwebpack(config, (err, stats) => {\n    console.log(stats.toJson())\n})\n```\n\nStats对象可以通过`webpack-cli`打包成一个json文件：`webpack --profile --json > compilation-stats.json`\n\n数据结构如下：\n\n```json\n{\n    \"version\": \"4.29.6\", // 用来编译的 webpack 的版本\n    \"hash\": \"11593e3b3ac85436984a\", // 编译使用的 hash\n    \"time\": 2469, // 编译耗时 (ms)\n    \"filteredModules\": 0, // 当 `exclude`传入`toJson` 函数时，统计被无视的模块的数量\n    \"outputPath\": \"/\", // path to webpack 输出目录的 path 路径\n    \"assetsByChunkName\": {\n        // 用作映射的 chunk 的名称\n        \"main\": \"web.js?h=11593e3b3ac85436984a\",\n        \"named-chunk\": \"named-chunk.web.js\",\n        \"other-chunk\": [\"other-chunk.js\", \"other-chunk.css\"]\n    },\n    \"assets\": [\n        // asset 对象 (asset objects) 的数组\n    ],\n    \"chunks\": [\n        // chunk 对象 (chunk objects) 的数组\n    ],\n    \"modules\": [\n        // 模块对象 (module objects) 的数组\n    ],\n    \"errors\": [\n        // 错误字符串 (error string) 的数组\n    ],\n    \"warnings\": [\n        // 警告字符串 (warning string) 的数组\n    ]\n}\n```\n\n> stats.toJson可以指定要不要输出对应的数据。例如不想输出 modules 和 chunks，可以使用stats. toJson({modules: false, chunks: false})\n\n#### module\n\n在每个 module 中，我们可以得到它的所有信息，这些信息可以分为四大类：\n\n1. 基本信息：包括最基本的内容、大小、id；\n2. 依赖关系：`module.reasons`对象描述了这个模块被加入依赖图表的理由，包含了引入的方式、引入的 module 信息及其对应代码在第几行第几列等，可以通过这个计算出 module 之间的依赖关系图表（graph）；\n3. chunks 和 assets 关系：`module.chunks`和`module.assets`包含到 chunks 和 assets 中的对应 id 等；\n4. 被 webpack 处理的后的信息：包含`module.failed`、`module.errors`、`module.warnings`等。\n\n```json\n{\n    \"assets\": [\n        // asset对象 (asset objects)的数组\n    ],\n    \"built\": true, // 表示这个模块会参与 Loaders , 解析, 并被编译\n    \"cacheable\": true, // 表示这个模块是否会被缓存\n    \"chunks\": [\n        // 包含这个模块的 chunks 的 id\n    ],\n    \"errors\": 0, // 处理这个模块发现的错误的数量\n    \"failed\": false, // 编译是否失败\n    \"id\": 0, // 这个模块的ID (类似于 `module.id`)\n    \"identifier\": \"(webpack)\\\\test\\\\browsertest\\\\lib\\\\index.web.js\", // webpack内部使用的唯一的标识\n    \"name\": \"./lib/index.web.js\", // 实际文件的地址\n    \"optional\": false, // 每一个对这个模块的请求都会包裹在 `try... catch` 内 (与ESM无关)\n    \"prefetched\": false, // 表示这个模块是否会被 prefetched\n    \"profile\": {\n        // 有关 `--profile` flag 的这个模块特有的编译数据 (ms)\n        \"building\": 73, // 载入和解析\n        \"dependencies\": 242, // 编译依赖\n        \"factory\": 11 // 解决依赖\n    },\n    \"reasons\": [\n        // 见下文描述\n    ],\n    \"size\": 3593, // 预估模块的大小 (byte)\n    \"source\": \"// Should not break it...\\r\\nif(typeof...\", // 字符串化的输入\n    \"warnings\": 0 // 处理模块时警告的数量\n}\n```\n\n其中`module.reasons`数据结构如下：\n\n```json\n{\n    \"loc\": \"33:24-93\", // 导致这个被加入依赖图标的代码行数\n    \"module\": \"./lib/index.web.js\", // 所基于模块的相对地址 context\n    \"moduleId\": 0, // 模块的 ID\n    \"moduleIdentifier\": \"(webpack)\\\\test\\\\browsertest\\\\lib\\\\index.web.js\", // 模块的地址\n    \"moduleName\": \"./lib/index.web.js\", // 可读性更好的模块名称 (用于 \"更好的打印 (pretty-printing)\")\n    \"type\": \"require.context\", // 使用的请求的种类 (type of request)\n    \"\n```\n\n#### chunk\n\n在每个 chunk 中，信息也可以分为四大类：\n\n1. 基本信息：包括最基本的内容、大小、id；\n2. 来源：`chunk.origins`对象描述了这个模块被加入的理由，包含了引入的方式、引入的 module 信息及其对应代码在第几行第几列等，可以通过这个计算出 module 之间的依赖关系图表（graph）；\n3. 引用关系：`chunk.parents`和`chunk.children`被引用和引用的 ids；\n4. 包含和被包含：`chunk.files`和`chunk.modules`包含到 assets 和自己包含 modules 中信息等。\n\n```json\n{\n    \"entry\": true, // 表示这个 chunk 是否包含 webpack 的运行时\n    \"files\": [\n        // 一个包含这个 chunk 的文件名的数组\n    ],\n    \"filteredModules\": 0, // 见上文的 结构\n    \"id\": 0, // 这个 chunk 的id\n    \"initial\": true, // 表示这个 chunk 是开始就要加载还是 懒加载(lazy-loading)\n    \"modules\": [\n        // 模块对象 (module objects)的数组\n        \"web.js?h=11593e3b3ac85436984a\"\n    ],\n    \"names\": [\n        // 包含在这个 chunk 内的 chunk 的名字的数组\n    ],\n    \"origins\": [\n        // 下文详述\n    ],\n    \"parents\": [], // 父 chunk 的 ids\n    // 生成 assets 的原因\n    \"reason\": \"split chunk (cache group: asyncVendors) (name: async)\",\n    \"hash\": \"170746935298270ad813\",\n    // 自己引用谁\n    \"children\": [],\n    // 引用的顺序\n    \"childrenByOrder\": {},\n    \"modules\": [],\n    \"rendered\": true, // 表示这个 chunk 是否会参与进编译\n    \"size\": 188057 // chunk 的大小(byte)\n}\n```\n\n`chunk.origins`对应的格式如下：\n\n```json\n{\n    \"loc\": \"\", // 具体是哪行生成了这个chunk\n    \"module\": \"(webpack)\\\\test\\\\browsertest\\\\lib\\\\index.web.js\", // 模块的位置\n    \"moduleId\": 0, // 模块的ID\n    \"moduleIdentifier\": \"(webpack)\\\\test\\\\browsertest\\\\lib\\\\index.web.js\", // 模块的地址\n    \"moduleName\": \"./lib/index.web.js\", // 模块的相对地址\n    \"name\": \"main\", // chunk的名称\n    \"reasons\": [\n        // 模块对象中`reason`的数组\n    ]\n}\n```\n\n#### asset\n\n`asset`相对简单一些，内容如下：\n\n```json\n{\n    \"chunkNames\": [], // 这个 asset 包含的 chunk\n    \"chunks\": [10, 6], // 这个 asset 包含的 chunk 的 id\n    \"emitted\": true, // 表示这个 asset 是否会让它输出到 output 目录\n    \"name\": \"10.web.js\", // 输出的文件名\n    \"size\": 1058 // 文件的大小\n}\n```","tags":["javascript","webpack","架构"],"categories":["Webpack"]}]