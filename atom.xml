<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zxfan</title>
  
  <subtitle>zxfan&#39;s Blog</subtitle>
  <link href="https://zxffan.github.io/atom.xml" rel="self"/>
  
  <link href="https://zxffan.github.io/"/>
  <updated>2021-06-29T14:01:39.716Z</updated>
  <id>https://zxffan.github.io/</id>
  
  <author>
    <name>zxfan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Crypto</title>
    <link href="https://zxffan.github.io/posts/6f842db3.html"/>
    <id>https://zxffan.github.io/posts/6f842db3.html</id>
    <published>2021-06-19T16:00:00.000Z</published>
    <updated>2021-06-29T14:01:39.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>哈希算法又称为散列算法。将一个任意长度的的数组作为输入，能够获得固定长度的输出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(crypto.getHashes());</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">  &#x27;RSA-MD4&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;RSA-MD5&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;RSA-MDC2&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;RSA-RIPEMD160&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;RSA-SHA1&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;RSA-SHA1-2&#x27;,</span></span><br><span class="line"><span class="comment">  &#x27;RSA-SHA224&#x27;,</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">  ...</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以<code>md5</code>为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;hello crypto!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> md5 = crypto.createHash(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> result = md5.update(text).digest(<span class="string">&quot;hex&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><ul><li><code>createHash</code>：创建hash，参数为hash算法，具体见<code>crypto.getHashes()</code></li><li><code>update</code>：对字符串进行hash</li><li><code>digest</code>：获取信息摘要<ul><li>不传参数，返回Buffer</li><li>参数为字符编码，<code>hex</code>返回16进制</li></ul></li></ul><p>md5是不可逆的，破解md5也只能使用暴力的“碰撞破解”。所以一般会对文本进行多次md5哈希：<code>md5.update(text).update(text).update(text)</code></p><blockquote><p>哈希算法通常用作信息摘要算法，比如双发通信时，发送方将资源（数据，用户）的信息摘要进行加密，接收方再去验证比对</p></blockquote><h2 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h2><p><code>Hmac</code>被称为加盐算法，即 <code>Hmac = hash + 密钥</code>。比如<code>sha-1</code>算法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;hello crypto!&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = crypto.createHmac(<span class="string">&quot;sha1&quot;</span>, <span class="string">&quot;miyao&quot;</span>).update(text).digest(<span class="string">&quot;hex&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 09ef939a42b909a48d8ea3803692ec88eedc4c04</span></span><br></pre></td></tr></table></figure><p><code>createHmac</code>第二个参数密钥</p><blockquote><p>密钥可以通过<code>openssl</code>来创建</p><p><code>openssl genrsa -out rsa_private.key 1024</code></p></blockquote><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称加密指：利用同意个密钥来加密/解密数据。这有两个关键点：</p><ul><li>有加密也有解密，所以加密算法是可逆的</li><li>同一个密钥</li></ul><p>以<code>aes192</code>为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">&quot;crypto&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = <span class="string">&quot;hello crypto!&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> key = crypto.scryptSync(<span class="string">&quot;woshimiyao&quot;</span>, <span class="string">&quot;yanzhi&quot;</span>, <span class="number">24</span>); <span class="comment">// 密钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encrypt</span>(<span class="params">data, iv</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cipher = crypto.createCipheriv(<span class="string">&quot;aes192&quot;</span>, key, iv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cipher.update(data, <span class="string">&quot;utf-8&quot;</span>, <span class="string">&quot;hex&quot;</span>).final(<span class="string">&quot;hex&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decrypt</span>(<span class="params">data, iv</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> decipher = crypto.createDecipheriv(<span class="string">&quot;aes192&quot;</span>, key, iv);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> decipher.update(data, <span class="string">&quot;hex&quot;</span>, <span class="string">&quot;utf-8&quot;</span>).final(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> iv = Buffer.alloc(<span class="number">16</span>, <span class="number">0</span>); <span class="comment">// 初始化向量</span></span><br><span class="line"><span class="keyword">const</span> e = encrypt(text, iv);</span><br><span class="line"><span class="keyword">const</span> d = decrypt(e, iv);</span><br><span class="line"><span class="built_in">console</span>.log(e, d); <span class="comment">// 3e07418b2c1ed2b128943b005610f166 hello crypto!</span></span><br></pre></td></tr></table></figure><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>非对称加密：利用两个密钥，一个用于加密另一个用于解密。这也有两个关键点：</p><ul><li>有加密也有解密，所以加密算法是可逆的</li><li>两个密钥：<ul><li>公钥：用于加密</li><li>私钥：用于解密</li></ul></li></ul><h2 id="常见加密算法"><a href="#常见加密算法" class="headerlink" title="常见加密算法"></a>常见加密算法</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;哈希&quot;&gt;&lt;a href=&quot;#哈希&quot; class=&quot;headerlink&quot; title=&quot;哈希&quot;&gt;&lt;/a&gt;哈希&lt;/h2&gt;&lt;p&gt;哈希算法又称为散列算法。将一个任意长度的的数组作为输入，能够获得固定长度的输出。&lt;/p&gt;
&lt;figure class=&quot;highlight </summary>
      
    
    
    
    <category term="experience" scheme="https://zxffan.github.io/categories/experience/"/>
    
    
    <category term="Nodejs" scheme="https://zxffan.github.io/tags/Nodejs/"/>
    
    <category term="crypto" scheme="https://zxffan.github.io/tags/crypto/"/>
    
  </entry>
  
  <entry>
    <title>字节跳动面试</title>
    <link href="https://zxffan.github.io/posts/33f3fd9d.html"/>
    <id>https://zxffan.github.io/posts/33f3fd9d.html</id>
    <published>2021-06-04T16:00:00.000Z</published>
    <updated>2021-06-29T14:06:58.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><ol><li><p>自我介绍</p></li><li><p>网络模型：osi七层模型，每层干什么的？</p></li><li><p>http协议的理解。想到啥说啥。就是你随便说，面试官会顺着问</p><ol><li>无状态</li><li>应用层协议，基于tcp</li><li>发展历史：从0.9到3.0</li><li>缓存</li><li>http状态吗：从1xx一直说到5xx</li></ol></li><li><p>https？说了一下tls协商</p></li><li><p>es6相关，说一些用过哪些？面试官会顺着问。</p><ol><li>var/let/const ， 面试官顺着问了它们的区别</li><li>字符串有哪些方法。这个问题应该是问错了，他想问得是数组：map filter reduce sort…</li><li>模块规范 esm cjs 区别</li><li>promise，然后就开始手写。估计他最初是想让我实现数组相关的方法，但是发现自己问错了就跳过了。</li></ol></li><li><p>3道题</p><ol><li>Promise.all</li><li>快排、归并，dfs选一个写</li><li>最小银币找零问题：现有[1,2,5,9,10]几种硬币，当有18面值的硬币时，如何找零使得硬币数量最少；答案是2——18 = 9+9</li></ol></li><li><p>感受：一面还是非常基础的。问了挺多的网络相关的内容</p></li></ol><h2 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h2><ol><li><p>自我介绍？没让自我介绍直接开始。</p></li><li><p>看简历：</p><ol><li>问你是怎么优化（webpack）构建性能的？<ol><li>缓存：如何根据js代码变化去修改缓存的？</li><li>thread-loader 怎么选取进程数量的？</li><li>如何去做chunk拆分，怎么考量的？</li></ol></li><li>cli脚手架 怎么设计的？</li></ol></li><li><p>vue的computed如何进行依赖收集？说了computed的实现机制。</p></li><li><p>vue3相对于vue2做了哪些改进？讲了响应式和compiler的优化（静态提升、pathFlag、BlockTree）</p></li><li><p>手写题目：类似vue中的渲染函数（render），让你生成dom元素（返回一个dom对象）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vnode = el(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">class</span>: <span class="string">&quot;container&quot;</span> &#125;, [</span><br><span class="line">  el(<span class="string">&quot;span&quot;</span>, &#123;&#125;, [<span class="string">&quot;hello world&quot;</span>]),</span><br><span class="line">]);</span><br><span class="line">vnode.render();</span><br></pre></td></tr></table></figure></li><li><p>场景题：</p><p>一个多语言应用，大概14种语言。假如每个语言都放在一个js文件中（中文的一个文件，英文的一个文件）。目前存在两个问题</p><ul><li>应用启动时，会加载这14种语言（js文件），但实际上只需要1种语言，问如何优化？</li><li>随着开发，有一些语言的值不在使用了，但还是加载到内存中去了，如何优化？</li></ul></li><li><p>感受：二面连自我介绍都省了，哈哈！！感觉面试官爱从编译的角度问问题，估计这和他的具体工作相关吧。总体感觉这位面试官还是不错的，问得都是比较实际的问题。</p></li></ol><h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>三面聊得特别广，也挺深的。</p><ol><li><p>之前性能优化怎么做的，这个聊了很久</p></li><li><p>cdn为什么会快？</p></li><li><p>从url到页面渲染的过程</p><ol><li>知道http如何判断响应返回的吗？</li><li>script 加载为什么会阻塞dom解析，既然有defer和async，为什么浏览器不默认defer/async?</li></ol></li><li><p>js中函数是一等公民。js中函数可以返回一个函数（闭包），知道这个特性实现难点在哪吗？</p></li><li><p>你的项目（自己的开源项目）有做过设计吗？看过设计相关的书吗？</p><ol><li>设计模式</li><li>函数式编程</li></ol></li><li><p>你项目写了虚拟列表优化，怎么做的</p><ol><li>滚动得快的话，出现白屏怎么优化？</li><li>如果高度不固定，怎么实现？</li></ol></li><li><p>为什么会学习electron？</p><ol><li>electron的进程模型</li><li>浏览器的进程模型</li></ol></li><li><p>手写题：</p><p>场景：根据ip判断ip所在范围，要求：尽可能高效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假如在这两个范围内的 是中国的ip</span></span><br><span class="line"><span class="keyword">const</span> db = [</span><br><span class="line">  [<span class="string">&quot;0.0.0.0&quot;</span>, <span class="string">&quot;10.0.0.0&quot;</span>],</span><br><span class="line">  [<span class="string">&quot;11.0.0.0&quot;</span>, <span class="string">&quot;200.0.0.0&quot;</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// ip: string，判断ip是否是中国ip</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInChain</span>(<span class="params">ip</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><p>感觉三面的面试官的职责可能不仅仅是前端，喜欢问一些特别底层的问题。</p><blockquote><p>三轮技术面试都没有怎么考算法，就一面考了一道动态规划。飞书的面试官还是比较注重实际的开发能力的。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;自我介绍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网络模型：osi七层模型，每层干什么的？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;h</summary>
      
    
    
    
    <category term="self" scheme="https://zxffan.github.io/categories/self/"/>
    
    
    <category term="前端" scheme="https://zxffan.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="interview" scheme="https://zxffan.github.io/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>clear 清除浮动</title>
    <link href="https://zxffan.github.io/posts/d8bddba6.html"/>
    <id>https://zxffan.github.io/posts/d8bddba6.html</id>
    <published>2021-05-30T16:00:00.000Z</published>
    <updated>2021-06-29T14:04:02.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>clear用于解决，由于float造成的浮动塌陷问题。</p><h2 id="只能清除前面的浮动"><a href="#只能清除前面的浮动" class="headerlink" title="只能清除前面的浮动"></a>只能清除前面的浮动</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span>&gt;</span>a<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;b&quot;</span>&gt;</span>b<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c&quot;</span>&gt;</span>c<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">  .box &#123;</span><br><span class="line"><span class="css">    <span class="attribute">background</span>: red;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .a,</span><br><span class="line">  .b,</span><br><span class="line">  .c &#123;</span><br><span class="line"><span class="css">    <span class="attribute">float</span>: left;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .b &#123;</span><br><span class="line"><span class="css">    <span class="attribute">clear</span>: left</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>无论对<code>b</code>设置<code>clear: left/right/both</code>。都只能清除<code>a</code>的浮动（a将独占一行），然而无法清除b的浮动。这是因为浏览器的解析顺序的缘故。</p><p>那么<code>clear: right</code>有什么用？当<code>float:right</code>时不就能清除右侧浮动了么！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;clear用于解决，由于float造成的浮动塌陷问题。&lt;/p&gt;
&lt;h2 id=&quot;只能清除前面的浮动&quot;&gt;&lt;a href=&quot;#只能清除前面的浮动</summary>
      
    
    
    
    <category term="CSS" scheme="https://zxffan.github.io/categories/CSS/"/>
    
    
    <category term="css" scheme="https://zxffan.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>前端性能优化</title>
    <link href="https://zxffan.github.io/posts/616f4683.html"/>
    <id>https://zxffan.github.io/posts/616f4683.html</id>
    <published>2021-05-17T16:00:00.000Z</published>
    <updated>2021-06-29T14:02:54.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>性能优化是很大的话题，可以从两个角度入手</p><ul><li>优化资源体积</li><li>优化请求速度</li></ul><h2 id="优化资源体积"><a href="#优化资源体积" class="headerlink" title="优化资源体积"></a>优化资源体积</h2><h3 id="资源懒加载"><a href="#资源懒加载" class="headerlink" title="资源懒加载"></a>资源懒加载</h3><p>资源懒加载就是指，当前这个页面只去加载本页面的资源。其它资源不去加载</p><h4 id="按照路由懒加载"><a href="#按照路由懒加载" class="headerlink" title="按照路由懒加载"></a>按照路由懒加载</h4><p>如果使用<code>webpack</code>这种构建工具，可以使用动态<code>import</code>函数来按照路由实现拆分chunk</p><h4 id="拆分node-modules"><a href="#拆分node-modules" class="headerlink" title="拆分node_modules"></a>拆分node_modules</h4><p>如果一个项目使用到了诸如：<code>element-ui</code> <code>vue</code> <code>pdfjs</code> <code>videojs</code>这些插件；<code>webpack</code>默认会将所有<code>node_modules</code>打包成一个<code>chunk</code>。但是某一个页面只用到了vue没有用到其它库，这是就会导致这个页面加载了许多无用的资源</p><p>所以我们要根据使用情况来拆分<code>node_modules</code>。具体做法就是通过<code>webpack</code>的<code>splitChunk</code>功能来实现。</p><blockquote><p>把这些库都拆分出去了，不就影响到下个页面的性能的吗？</p><p>利用<code>preftch</code>解决</p><ul><li>import函数可以使用魔法注释 <code>/*.webpackPrefetch: true */</code> <code>/*.webpackPreload: true */</code></li></ul></blockquote><h4 id="库按需加载"><a href="#库按需加载" class="headerlink" title="库按需加载"></a>库按需加载</h4><p>比如<code>element-ui</code>，它内置了大量组件。我们应该去按需引用他们。</p><p>使用<code>babel-plugin-import</code>来实现组件库（js和css）的按需加载</p><h3 id="资源压缩"><a href="#资源压缩" class="headerlink" title="资源压缩"></a>资源压缩</h3><h4 id="客户端压缩"><a href="#客户端压缩" class="headerlink" title="客户端压缩"></a>客户端压缩</h4><p>客户端压缩资源文件，比如<code>js</code> <code>css</code> <code>img</code>等</p><ul><li>js：使用<code>terser-webpack-plugin</code>压缩脚本代码</li><li>css：使用<code>optimize-css-webpack-plugin</code></li><li>Img: 图片可以使用 <code>image-webpack-loader</code>压缩</li></ul><h4 id="服务端压缩"><a href="#服务端压缩" class="headerlink" title="服务端压缩"></a>服务端压缩</h4><p>服务端开启<code>g-zip</code>压缩</p><p>比如nginx，直接配置<code>gzip: on</code>即可</p><h2 id="优化请求速度"><a href="#优化请求速度" class="headerlink" title="优化请求速度"></a>优化请求速度</h2><p>从请求速度角度入手。首先，需要理清楚页面显示之前都发生了些什么。</p><h3 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h3><p>输入url，后首先不是DNS，而是检查浏览器缓存。浏览器缓存可以分成四种</p><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p><code>service worder</code>就是服务端与客户端之间的代理人。客户端对资源的请求会被<code>service worker</code>拦截下来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="comment">/* 监听安装事件，install 事件一般是被用来设置你的浏览器的离线缓存逻辑 */</span></span><br><span class="line"><span class="built_in">this</span>.addEventListener(<span class="string">&#x27;install&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 通过这个方法可以防止缓存未完成，就关闭serviceWorker */</span></span><br><span class="line">  event.waitUntil(</span><br><span class="line">    <span class="comment">/* 创建一个名叫V1的缓存版本 */</span></span><br><span class="line">    caches.open(<span class="string">&#x27;v1&#x27;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="comment">/* 指定要缓存的内容，地址为相对于跟域名的访问路径 */</span></span><br><span class="line">      <span class="keyword">return</span> cache.addAll([</span><br><span class="line">        <span class="string">&#x27;./index.html&#x27;</span> <span class="comment">// 资源URL</span></span><br><span class="line">      ]);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册fetch事件，拦截全站的请求 */</span></span><br><span class="line"><span class="built_in">this</span>.addEventListener(<span class="string">&#x27;fetch&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 在缓存中匹配对应请求资源直接返回 */</span></span><br><span class="line">  event.respondWith(caches.match(event.request));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>service worker</code>需要注册, <code>navigator.serviceWorker.register</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="comment">/* 判断当前浏览器是否支持serviceWorker */</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="comment">/* 当页面加载完成就创建一个serviceWorker */</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* 创建并指定对应的执行内容 */</span></span><br><span class="line">    <span class="comment">/* scope 参数是可选的，可以用来指定你想让 service worker 控制的内容的子目录。 在这个例子里，我们指定了 &#x27;/&#x27;，表示 根网域下的所有内容。这也是默认值。 */</span></span><br><span class="line">    navigator.serviceWorker.register(<span class="string">&#x27;./serviceWorker.js&#x27;</span>, &#123;<span class="attr">scope</span>: <span class="string">&#x27;./&#x27;</span>&#125;)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span> (<span class="params">registration</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;ServiceWorker registration successful with scope: &#x27;</span>, registration.scope);</span><br><span class="line">    &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;ServiceWorker registration failed: &#x27;</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>service worker是基于web worker</p></blockquote><h4 id="memory-cache-amp-disk-cache"><a href="#memory-cache-amp-disk-cache" class="headerlink" title="memory cache &amp; disk cache"></a>memory cache &amp; disk cache</h4><ul><li><p>内存缓存，这部分资源存放到内存中的</p></li><li><p>磁盘缓存，这部分资源是存放到磁盘中的。也就是我们常说的<strong>强缓存</strong>和<strong>协商缓存</strong></p></li></ul><p><code>chrome</code>会自动将磁盘缓存存放到内存中，下次请求时，就会自动从内存中去。内存IO的性能肯定优于磁盘IO。当浏览器关闭后，存放到内存的缓存就会自动清空，而磁盘缓存一致存在</p><h4 id="push-cache"><a href="#push-cache" class="headerlink" title="push cache"></a>push cache</h4><p><code>HTTP2</code>拥有<strong>服务端推送的功能</strong>。</p><h3 id="DNS-prefetch"><a href="#DNS-prefetch" class="headerlink" title="DNS prefetch"></a>DNS prefetch</h3><p>开启DNS 预取，在加载HTML时，开始解析域名获取IP。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 会自动加上响应头，告诉浏览器开始dns预解析 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;x-dns-prefetch-control&quot;</span> <span class="attr">content</span>=<span class="string">&quot;on&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 指定要解析的域名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;dns-prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//www.zhix.net&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><p>将一些图片或者不变的大资源，采用CDN上云的方式。从而加快请求速度</p><h3 id="并发限制"><a href="#并发限制" class="headerlink" title="并发限制"></a>并发限制</h3><p>现代浏览器对同一个域的请求是有并发限制的。比如<code>chrome</code>最多并发6个请求。我们有两种方案来解决：</p><ul><li>拆分不同的域名：那我们可以将资源拆分到不同的域下，从而绕开限制。</li><li>使用HTTP2：<code>http2</code>可以实现多路复用，一个域名只需要建立一个tcp连接</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;性能优化&quot;&gt;&lt;a href=&quot;#性能优化&quot; class=&quot;headerlink&quot; title=&quot;性能优化&quot;&gt;&lt;/a&gt;性能优化&lt;/h2&gt;&lt;p&gt;性能优化是很大的话题，可以从两个角度入手&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化资源体积&lt;/li&gt;
&lt;li&gt;优化请求速度&lt;/li&gt;
</summary>
      
    
    
    
    <category term="experience" scheme="https://zxffan.github.io/categories/experience/"/>
    
    
    <category term="Nodejs" scheme="https://zxffan.github.io/tags/Nodejs/"/>
    
    <category term="网络" scheme="https://zxffan.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Vuex@4.x</title>
    <link href="https://zxffan.github.io/posts/340f0a10.html"/>
    <id>https://zxffan.github.io/posts/340f0a10.html</id>
    <published>2021-05-12T16:00:00.000Z</published>
    <updated>2021-06-29T14:07:43.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vuex注册流程"><a href="#Vuex注册流程" class="headerlink" title="Vuex注册流程"></a>Vuex注册流程</h2><p>首先通过<code>createStore</code>方法创建一个store对象。然后使用<code>app.use(store)</code>。<code>store</code>对象是一个vue插件。所以必须实现install方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  install (app, injectKey) &#123;</span><br><span class="line">    app.provide(injectKey || storeKey, <span class="built_in">this</span>)</span><br><span class="line">    app.config.globalProperties.$store = <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在组件里使用vuex</span></span><br><span class="line"><span class="comment">// 1: this.$store</span></span><br><span class="line"><span class="comment">// 2: inject: [injectKey] </span></span><br></pre></td></tr></table></figure><p>创建store对象的流程：</p><ol><li>初始化所有module</li><li>resetStoreState<ul><li>注册getter</li><li>响应式state</li></ul></li></ol><h2 id="如何注册module"><a href="#如何注册module" class="headerlink" title="如何注册module"></a>如何注册module</h2><p><code>installModule</code>会初始化root模块，也会初始化所有子模块</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">installModule</span> (<span class="params">store, rootState, path, <span class="built_in">module</span>, hot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isRoot = !path.length</span><br><span class="line">  <span class="keyword">const</span> namespace = store._modules.getNamespace(path)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// register in namespace map</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">module</span>.namespaced) &#123;</span><br><span class="line">    store._modulesNamespaceMap[namespace] = <span class="built_in">module</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set state</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot &amp;&amp; !hot) &#123;</span><br><span class="line">    <span class="keyword">const</span> parentState = getNestedState(rootState, path.slice(<span class="number">0</span>, -<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">const</span> moduleName = path[path.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> local = <span class="built_in">module</span>.context = makeLocalContext(store, namespace, path)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册所有mutation</span></span><br><span class="line">  <span class="built_in">module</span>.forEachMutation(<span class="function">(<span class="params">mutation, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    registerMutation(store, namespacedType, mutation, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册所有action</span></span><br><span class="line">  <span class="built_in">module</span>.forEachAction(<span class="function">(<span class="params">action, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> type = action.root ? key : namespace + key</span><br><span class="line">    <span class="keyword">const</span> handler = action.handler || action</span><br><span class="line">    registerAction(store, type, handler, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册所有getter</span></span><br><span class="line">  <span class="built_in">module</span>.forEachGetter(<span class="function">(<span class="params">getter, key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> namespacedType = namespace + key</span><br><span class="line">    registerGetter(store, namespacedType, getter, local)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注册所有子模块</span></span><br><span class="line">  <span class="built_in">module</span>.forEachChild(<span class="function">(<span class="params">child, key</span>) =&gt;</span> &#123;</span><br><span class="line">    installModule(store, rootState, path.concat(key), child, hot)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册getters"><a href="#注册getters" class="headerlink" title="注册getters"></a>注册getters</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerGetter</span> (<span class="params">store, type, rawGetter, local</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (store._wrappedGetters[type]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">`[vuex] duplicate getter key: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把所有getter 注册到 _wrappedGetters对象上</span></span><br><span class="line">  store._wrappedGetters[type] = <span class="function"><span class="keyword">function</span> <span class="title">wrappedGetter</span> (<span class="params">store</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// rawGetter就是开发者提供的getter</span></span><br><span class="line">    <span class="keyword">return</span> rawGetter(</span><br><span class="line">      local.state, <span class="comment">// local state</span></span><br><span class="line">      local.getters, <span class="comment">// local getters</span></span><br><span class="line">      store.state, <span class="comment">// root state</span></span><br><span class="line">      store.getters <span class="comment">// root getters</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册actions"><a href="#注册actions" class="headerlink" title="注册actions"></a>注册actions</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerAction</span> (<span class="params">store, type, handler, local</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> entry = store._actions[type] || (store._actions[type] = [])</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 利用闭包实现柯里化</span></span><br><span class="line">  <span class="comment">// 下次执行函数就不需要传参数了</span></span><br><span class="line">  entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedActionHandler</span> (<span class="params">payload</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = handler.call(store, &#123;</span><br><span class="line">      dispatch: local.dispatch,</span><br><span class="line">      commit: local.commit,</span><br><span class="line">      getters: local.getters,</span><br><span class="line">      state: local.state,</span><br><span class="line">      rootGetters: store.getters,</span><br><span class="line">      rootState: store.state</span><br><span class="line">    &#125;, payload)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 会用Promise包一层 action</span></span><br><span class="line">    <span class="keyword">if</span> (!isPromise(res)) &#123;</span><br><span class="line">      res = <span class="built_in">Promise</span>.resolve(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (store._devtoolHook) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        store._devtoolHook.emit(<span class="string">&#x27;vuex:error&#x27;</span>, err)</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册mutations"><a href="#注册mutations" class="headerlink" title="注册mutations"></a>注册mutations</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">registerMutation</span> (<span class="params">store, type, handler, local</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> entry = store._mutations[type] || (store._mutations[type] = [])</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对各个模块 注册mutation</span></span><br><span class="line">  entry.push(<span class="function"><span class="keyword">function</span> <span class="title">wrappedMutationHandler</span> (<span class="params">payload</span>) </span>&#123;</span><br><span class="line">    handler.call(store, local.state, payload)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何初始化store中的数据"><a href="#如何初始化store中的数据" class="headerlink" title="如何初始化store中的数据"></a>如何初始化store中的数据</h2><p>需要响应式的数据有getters和state</p><p>state的响应式是通过<code>reactive</code>对象来实现的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetStoreState</span> (<span class="params">store, state, hot</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldState = store._state</span><br><span class="line"></span><br><span class="line">  <span class="comment">// bind store public getters</span></span><br><span class="line">  store.getters = &#123;&#125;</span><br><span class="line">  <span class="comment">// reset local getters cache</span></span><br><span class="line">  store._makeLocalGettersCache = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="keyword">const</span> wrappedGetters = store._wrappedGetters</span><br><span class="line">  <span class="keyword">const</span> computedObj = &#123;&#125;</span><br><span class="line">  forEachValue(wrappedGetters, <span class="function">(<span class="params">fn, key</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    computedObj[key] = partial(fn, store)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(store.getters, key, &#123;</span><br><span class="line">      get: <span class="function">() =&gt;</span> computedObj[key](),</span><br><span class="line">      enumerable: <span class="literal">true</span> <span class="comment">// for local getters</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用reactive响应式state</span></span><br><span class="line">  store._state = reactive(&#123;</span><br><span class="line">    data: state</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// enable strict mode for new state</span></span><br><span class="line">  <span class="keyword">if</span> (store.strict) &#123;</span><br><span class="line">    enableStrictMode(store)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hot) &#123;</span><br><span class="line">      <span class="comment">// dispatch changes in all subscribed watchers</span></span><br><span class="line">      <span class="comment">// to force getter re-evaluation for hot reloading.</span></span><br><span class="line">      store._withCommit(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        oldState.data = <span class="literal">null</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何实现只有mutation才能修改state"><a href="#如何实现只有mutation才能修改state" class="headerlink" title="如何实现只有mutation才能修改state"></a>如何实现只有mutation才能修改state</h2><p>说明：只有<strong>严格模式</strong>且<strong>开发模式</strong>下，vuex才会阻止非mutation修改state</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格模式会调用 enableStrictMode</span></span><br><span class="line"><span class="keyword">if</span> (store.strict) &#123;</span><br><span class="line">  enableStrictMode(store)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用watch监听state，如果state发生变化</span></span><br><span class="line"><span class="comment">// 提示</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enableStrictMode</span> (<span class="params">store</span>) </span>&#123;</span><br><span class="line">  watch(<span class="function">() =&gt;</span> store._state.data, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// assert如果条件为 false会抛一场</span></span><br><span class="line">      <span class="comment">// 由于是sync</span></span><br><span class="line">      <span class="comment">// 所以会阻止修改</span></span><br><span class="line">      assert(store._committing, <span class="string">`do not mutate vuex store state outside mutation handlers.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123; <span class="attr">deep</span>: <span class="literal">true</span>, <span class="attr">flush</span>: <span class="string">&#x27;sync&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这个<code>store._committing</code>只要是<code>false</code>就会阻止修改state。</p><p>那什么时候这个值为true呢，那肯定是commit的时候</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>._withCommit(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  entry.forEach(<span class="function"><span class="keyword">function</span> <span class="title">commitIterator</span> (<span class="params">handler</span>) </span>&#123;</span><br><span class="line">    handler(payload)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// _withCommit方法会修改_committing的状态</span></span><br><span class="line"><span class="comment">// 执行完mutation又会 改回来</span></span><br><span class="line">_withCommit (fn) &#123;</span><br><span class="line">  <span class="keyword">const</span> committing = <span class="built_in">this</span>._committing</span><br><span class="line">  <span class="built_in">this</span>._committing = <span class="literal">true</span></span><br><span class="line">  fn()</span><br><span class="line">  <span class="built_in">this</span>._committing = committing</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vuex注册流程&quot;&gt;&lt;a href=&quot;#Vuex注册流程&quot; class=&quot;headerlink&quot; title=&quot;Vuex注册流程&quot;&gt;&lt;/a&gt;Vuex注册流程&lt;/h2&gt;&lt;p&gt;首先通过&lt;code&gt;createStore&lt;/code&gt;方法创建一个store对象。然后使用</summary>
      
    
    
    
    <category term="源码" scheme="https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="vue" scheme="https://zxffan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Electron的隔离上下文</title>
    <link href="https://zxffan.github.io/posts/b9b99d96.html"/>
    <id>https://zxffan.github.io/posts/b9b99d96.html</id>
    <published>2021-05-04T16:00:00.000Z</published>
    <updated>2021-06-29T14:04:31.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ContextIsolation"><a href="#ContextIsolation" class="headerlink" title="ContextIsolation"></a>ContextIsolation</h2><p>处于安全考虑，<code>Electron12</code>默认开启了上下文隔离（context isolation），它会将<strong>上下文环境</strong>划分两个运行环境——<strong>主环境</strong>和<strong>隔离环境</strong></p><p>主环境：渲染进程所运行的环境，无法访问到Electron API</p><p>隔离环境：preload脚本所运行的环境，能够访问到Electron API</p><p><code>ContextIsolation</code>是默认开启的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">  webPreference: &#123;</span><br><span class="line">    contextIsolation: <span class="literal">true</span> <span class="comment">// 默认就是true</span></span><br><span class="line">    preload: <span class="string">&#x27;path to your preload js file&#x27;</span>, <span class="comment">// 设置preload脚本</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="ContextBridge"><a href="#ContextBridge" class="headerlink" title="ContextBridge"></a>ContextBridge</h2><p>通过使用<a href="https://www.electronjs.org/docs/api/context-bridge#contextbridgeexposeinmainworldapikey-api-experimental">ContextBridge</a>，可以通过隔离环境将<code>Electron API</code>暴露给主环境</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 隔离环境</span></span><br><span class="line"><span class="keyword">const</span> &#123; contextBridge, ipcRenderer &#125; = <span class="built_in">require</span>(<span class="string">&#x27;electron&#x27;</span>)</span><br><span class="line"></span><br><span class="line">contextBridge.exposeInMainWorld(</span><br><span class="line">  <span class="string">&#x27;electron&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    doThing: <span class="function">() =&gt;</span> ipcRenderer.send(<span class="string">&#x27;do-a-thing&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>主环境直接在window对象上使用<code>window.electron.doThing()</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ContextIsolation&quot;&gt;&lt;a href=&quot;#ContextIsolation&quot; class=&quot;headerlink&quot; title=&quot;ContextIsolation&quot;&gt;&lt;/a&gt;ContextIsolation&lt;/h2&gt;&lt;p&gt;处于安全考虑，&lt;code&gt;E</summary>
      
    
    
    
    <category term="Electron" scheme="https://zxffan.github.io/categories/Electron/"/>
    
    
    <category term="javascript" scheme="https://zxffan.github.io/tags/javascript/"/>
    
    <category term="Electron" scheme="https://zxffan.github.io/tags/Electron/"/>
    
    <category term="桌面端软件" scheme="https://zxffan.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>vue-router@4.x</title>
    <link href="https://zxffan.github.io/posts/22412f62.html"/>
    <id>https://zxffan.github.io/posts/22412f62.html</id>
    <published>2021-04-30T16:00:00.000Z</published>
    <updated>2021-06-29T14:07:20.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="vue-router是如何实现修改url而不会使页面刷新？"><a href="#vue-router是如何实现修改url而不会使页面刷新？" class="headerlink" title="vue-router是如何实现修改url而不会使页面刷新？"></a>vue-router是如何实现修改url而不会使页面刷新？</h3><p><code>vue-router</code>通过<code>history</code>这个<code>BOM</code>对象来修改url的</p><ul><li><code>history.pushState</code>：向当前浏览器会话的历史堆栈中添加一个state</li><li><code>history.replaceState</code>：替换历史堆栈栈顶的state</li></ul><p>这两个API不会导致页面刷新</p><h3 id="vue-router如何监听url变化？"><a href="#vue-router如何监听url变化？" class="headerlink" title="vue-router如何监听url变化？"></a>vue-router如何监听url变化？</h3><p><code>history.pushState</code>和<code>history.replaceState</code>是手动执行的，不需要监听</p><p>需要监听浏览器后退——<code>window.addEventListener(&quot;popstate&quot;, () =&gt; &#123;&#125;)</code></p><blockquote><p>旧版本的<code>vue-router</code>。对hash路由做了一层兼容性判断：如果浏览器支持<code>history.pushState</code>就监听<code>popstate</code>事件，否则监听<code>hashchange</code></p></blockquote><h3 id="vue-router的路由组件如何响应url变化"><a href="#vue-router的路由组件如何响应url变化" class="headerlink" title="vue-router的路由组件如何响应url变化"></a>vue-router的路由组件如何响应url变化</h3><p>在执行<code>vue-router</code>的<code>install</code>方法时，将<code>currentRoute</code>全局注入（provide），然后在<code>router-view</code>组件内<code>inject</code>。</p><p>在创建router时传入了<code>routes</code>参数，以定义应用的路由列表。<code>routes</code>是一个树结构。每一次路由变化时，都会在routes中寻找一个匹配当前跳转url的路由列表（数组）并赋值给<code>currentRoute.matched</code>。</p><p>在<code>router-view</code>中时这样获取的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> matchedRouteRef = computed&lt;RouteLocationMatched | <span class="literal">undefined</span>&gt;(</span><br><span class="line">  () =&gt; routeToDisplay.value.matched[depth]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>router-view</code>是一个嵌套结构，<code>depth</code>表示深度。<code>depth</code>是这样来的：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> depth = inject(viewDepthKey, <span class="number">0</span>) <span class="comment">// 初始默认为0</span></span><br><span class="line">provide(viewDepthKey, depth + <span class="number">1</span>) <span class="comment">// +1 provide给子组件</span></span><br></pre></td></tr></table></figure><p>这样就可以获取匹配到的路由，然后就是获取路由对应的组件，并渲染。</p><h3 id="导航守卫原理"><a href="#导航守卫原理" class="headerlink" title="导航守卫原理"></a>导航守卫原理</h3><p>每次发生路由跳转时，回去执行导航守卫，源码位于<code>vue-router-next/src/router.ts</code>下的<code>navigate</code>方法。该方法主要做了：</p><ol><li>收集<code>beforeRouteLeave</code>导航守卫</li><li>执行所有收集到的导航</li><li>收集并执行全局守卫<code>beforeEach</code></li><li>收集并执行<code>beforeRouteUpdate</code></li><li>收集并执行<code>beforeEnter</code></li><li>收集并执行<code>beforeRouteEnter</code></li><li>收集并执行<code>beforeResolve</code></li><li>最后执行<code>afterEach</code></li></ol><blockquote><p>整个过程是Promise链式调用。若其中一步reject，后面就不会执行了。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;h3 id=&quot;vue-router是如何实现修改url而不会使页面刷新？&quot;&gt;&lt;a href=&quot;#vue-router是如何实现修改url而不会使</summary>
      
    
    
    
    <category term="源码" scheme="https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="vue" scheme="https://zxffan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>网络知识梳理</title>
    <link href="https://zxffan.github.io/posts/8c9e2fd.html"/>
    <id>https://zxffan.github.io/posts/8c9e2fd.html</id>
    <published>2021-04-29T16:00:00.000Z</published>
    <updated>2021-06-29T14:06:15.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP演进"><a href="#HTTP演进" class="headerlink" title="HTTP演进"></a>HTTP演进</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><p>第一版HTTP协议，只能传输文本，请求报文内容只有 1 行。</p><ul><li>客户端：请求报文：<code>GET/index.html</code></li><li>服务端：返回一个以 ASCII 字符流编码的 HTML 文档。</li></ul><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>HTTP 可以用来传输脚本、样式、图片、音频和视频等不同类型的文件</p><p>增加了头部的设定，<code>Accept</code>和<code>Content-Type</code></p><h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>解决了<code>HTTP/1.0</code>的连接问题，支持TCP连接复用</p><ul><li><code>HTTP/1.0</code>：每次请求都会建立连接、传输数据和断开连接三个阶段</li><li><code>HTTP/1.1</code>：第二次请求会复用第一次请求的TCP连接</li></ul><p>长连接可以在请求头中加上<code>Connection: keep-alive</code>。<code>HTTP/1.1</code>默认开启<code>keep-alive</code>，不加这个请求头也可以使用长连接的。</p><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p><code>HTTP/2</code>增强了并发能力</p><ul><li><strong>二进制传输</strong>：<code>http/1.1</code>传输的是文本，<code>http/2</code>传输的是二进制流</li><li><strong>多路复用</strong>：<code>http/2</code>有两个概念——<strong>帧</strong>和<strong>流</strong>。<code>http/2</code>将数据报文分成一个个二进制<strong>帧（Frame）</strong>，在一个TCP连接中，不同的帧组合在一起发送（<strong>二进制分帧</strong>）形成<strong>流（Stream）</strong>。在接收方根据帧首部信息在组合起来。<code>HTTP/1.1</code>只能一个个请求报文排队发送（容易发生<strong>队头阻塞</strong>）。</li><li><strong>header压缩</strong>：http请求有这繁多冗长的首部，<code>http/2</code>会对首部进行压缩</li><li><strong>服务端推送</strong>：能够主动给客户端推送资源<ul><li><code>http/1.1</code>加载网页的顺序：请求html，解析html，再请求js、css等文件</li><li><code>http/2</code>：当服务端收到html请求时，服务端就主动吧html、css、js以及图片等资源发送给客户端</li></ul></li></ul><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p><code>HTTP/1.x</code>、<code>HTTPS</code>以及<code>HTTP/2.0</code>都离不开底层的<code>TCP</code>协议。</p><p><code>HTTP/2.0</code>采用多路复用，多个数据包使用一个<code>TCP</code>连接。<code>TCP</code>是可靠连接，但发生丢包时，会进行重传。所以网络状态差的情况下，某些数据包频繁重传，从而导致拥塞，后面的HTTP包都穿不出去。这叫做<strong>头部阻塞（Head of line Blocking）</strong></p><p><code>HTTP/3.0</code>就开始考虑放弃<code>TCP</code>转向<code>UDP</code>协议。起初<code>Google</code>搞出来个<code>QUIC</code>协议，后来<code>IETF</code>标准化了<code>QUIC</code>协议形成<code>HTTP/3</code>。其底层采用<code>UDP</code>，基于<code>UDP</code>实现做了众多增强：</p><ul><li>0RTT：<code>TPC</code>建立连接每次都需要三次握手，就存在数据包的三次往返即<strong>3RTT</strong>。而<code>QUIC</code>首次建立连接只需要<code>1RTT</code>。其后的连接可以直接复用，只需要<strong>0RTT</strong></li><li>连接迁移：当<code>源IP</code>、<code>源端口</code>、<code>目的IP</code>、<code>目的端口</code>其中一个发生变化就需要重新建立TCP连接。只要<strong>Connection ID</strong>没有变化。<code>HTTP/3</code>可以继续复用连接</li><li>头部阻塞：由于使用<code>UDP</code>，发生丢包时，也不会立即重传，阻塞连接。</li><li>拥塞控制</li><li>前向纠错</li><li>更多特性 请参考<a href="https://zhuanlan.zhihu.com/p/143464334">文章</a></li></ul><p>chrome只支持 <code>Google QUIC</code>。对<code>IETF QUIC</code>的支持处于<code>WIP</code>状态</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTP(超文本传输协议)，有着一个致命的缺陷，那就是内容是<strong>明文传输</strong>的，没有经过任何加密，而这些明文数据会经过<strong>WiFi、路由器、运营商、机房</strong>等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露，这一攻击手法叫做MITM（Man In The Middle）<strong>中间人攻击</strong>。</p><p>HTTPS = HTTP + TLS/SSL。HTTPS就是在HTTP（应用层）与TCP（传输层）之间加上了一层<code>TLS/SSL</code>协议</p><h3 id="对称加密和非对称加密"><a href="#对称加密和非对称加密" class="headerlink" title="对称加密和非对称加密"></a>对称加密和非对称加密</h3><p>区别：</p><ul><li>加解密方式不同：<ul><li>对称加密使用同一个密钥加解密</li><li>非对称加密使用不同的密钥加解密</li></ul></li><li>性能：对称加密比非对称加密快</li></ul><h3 id="CA-Certification-Authority"><a href="#CA-Certification-Authority" class="headerlink" title="CA(Certification Authority)"></a>CA(Certification Authority)</h3><p>CA是为了保证密钥的正确性。具体来说就是把密钥放入一个证书中，该证书包含服务端的信息，比如颁发者、域名、有效期，为了保证证书是可信的，需要由一个可信的第三方来对证书进行签名。这个第三方一般是证书的颁发机构，也称 CA（Certification Authority，认证中心）。</p><h3 id="HTTPS工作流程"><a href="#HTTPS工作流程" class="headerlink" title="HTTPS工作流程"></a>HTTPS工作流程</h3><p><img src="../../images/network/HTTP-process.webp" alt="https"></p><ol><li>客户端发送HTTPS请求（默认端口443）</li><li>服务端有一套<code>CA数字证书</code>，证书含有一个<code>公钥public</code>。服务端接收到请求，会将这个证书发送给客户端。服务端还有一个<code>私钥private</code>，私钥是一直保存再服务端不公开的。</li><li>客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续。</li><li>客户端先生成一段<code>随机key</code>，再利用证书中的<code>公钥public</code>加密这段<code>随机key</code>，并将这个<code>随机key密文</code>发送给服务端。</li><li>服务端收到这个<code>随机key密文</code>文后，通过<code>私钥private</code>来解密，获取客户端真正的<code>随机key</code></li><li>服务端使用<code>随机key</code>来加密需要传输的HTTP数据，并发送给客户端</li><li>客户端再用<code>随机key</code>来解密服务端传输过来的密文，获取真正的数据</li><li>后续HTTPS请求使用之前交换好的<code>随机Key</code>进行对称加解密。</li></ol><blockquote><p> 由于随机key明文没有再网络上传输，所以”中间人”并不知道用于加密和解密的随机key，因此是安全的</p></blockquote><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><code>SYN</code>报文：请求连接</p><p><code>ACK</code>报文：应答</p><p><code>FIN</code>报文：断开连接</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>三次握手就是建立TCP连接的过程，流程如下图：</p><p><img src="../../images/network/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手"></p><p>一共分三步：</p><ol><li>客户端发送SYN消息给服务端（告知服务端要建立连接）</li><li>服务端同时发送两个消息（SYN和ACK）给客户端<ul><li>ACK表示收到了客户端的SYN</li><li>SYN表示服务端也要连接客户端</li></ul></li><li>客户端发送ACK给服务端（表示接受服务端的SYN）</li></ol><blockquote><p> <strong>为什么要三次握手？</strong></p><p>TCP是可靠传输，三次握手目的是确认双方的接收和发送能力。经过三次握手，服务端和客户端都确认了双方的接收和发送能力。</p></blockquote><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>四次挥手是TCP断开连接的过程，流程如下图</p><p><img src="../../images/network/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="四次挥手.png"></p><p>一共分为四步：（客户端和服务端都可以断开请求，以服务端为例）</p><ol><li>服务端发送FIN请求，表示服务端要断开连接</li><li>客户端发送ACK请求，表示收到了服务端的请求</li><li>客户单发送FIN请求，表示客户端也要断开连接</li><li>服务端发送ACK请求，表示收到了客户端的请求</li></ol><blockquote><p>为什么2，3步骤不能一起发送</p><p>ACK只是对FIN的应答，断开连接要处理的问题比较多，比如说服务端/客户端可能还有发送出去的消息没有得到 ACK；也有可能服务端自己有资源要释放。</p></blockquote><h2 id="webscoket"><a href="#webscoket" class="headerlink" title="webscoket"></a>webscoket</h2><p><code>websocket</code>的建立也是通过<code>http</code>实现的</p><p>首先，客户端先发送一个HTTP请求，请求头携带以下信息</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">ws://websocket.example.com/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>websocket.example.com</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://example.com</span><br><span class="line">Sec-WebSocket-Key:pAloKxsGSHtpIHrJdWLvzQ==</span><br><span class="line">Sec-WebSocket-Version:13</span><br></pre></td></tr></table></figure><ul><li><code>Connection: Upgrade</code>告知服务端，浏览器想要升级协议</li><li><code>Upgrade: websocket</code>：升级到websocket协议</li><li><code>Sec-WebSocket-Key</code>浏览器的随机key，用于娇艳</li><li><code>Sec-WebSocket-Version</code>：websocket版本</li></ul><p>服务端收到请求，就开始升级协议，返回101。服务端收到。响应大概是这样的</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span><span class="punctuation">: </span>websocket</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Accept</span><span class="punctuation">: </span>nRu4KAPUPjjWYrnzxDVeqOxCvlM=</span><br></pre></td></tr></table></figure><p><code>Sec-WebSocket-Accept</code>是根据响应头中的key进行加密而来的</p><p>客户端收到这个响应后，会校验这个<code>accept</code>。就是以同样的方式加密key，看key和accept是否相同。</p><p>到这里，websocket的连接就建立完成了。随后的请求都是以websocket协议发送。</p><h2 id="网络分层结构"><a href="#网络分层结构" class="headerlink" title="网络分层结构"></a>网络分层结构</h2><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3><p><code>TCP/IP</code>是互联网相关的各类协议族的总称<br><code>TCP/IP</code>具有分层结构，分为：应用层、传输层、网络层和数据链路层</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>应用层决定了向用户提供应用服务时通信的活动。<br>相关协议：<code>FTP</code>、<code>DNS</code>以及<code>HTTP</code></p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>传输层提供处于网络连接中的两台计算机之间的数据传输<br>相关协议：<code>TCP</code>和<code>UDP</code></p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>网络层规定了数据包通过怎样的传输线路到达对方计算机<br>相关协议：<code>IP</code></p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>数据链路是用来处理连接网络的<strong>硬件部分</strong><br>例如：<code>NIC(网卡)</code>、<code>光纤</code>等物理可见部分</p><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><ul><li>应用层</li><li>表示层：负责数据格式的转换</li><li>会话层：负责建立和断开通信连接</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul><p><img src="../../images/network/%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84.webp" alt="网络分层结构"></p><h4 id="数据链路层-1"><a href="#数据链路层-1" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>数据链路层主要有3种功能：</p><ul><li>封装成帧：将物理层上交的比特流封装成帧</li><li>透明传输：封装成帧的时候，会给每个帧加上帧开始符（SOH）和帧结束符（EOT）。是指该层上传输的数据的内容、格式及编码没有限制，也没有必要解释信息结构的意义</li><li>差错检测<ul><li>比特差错</li><li>帧 丢失/重复/失序</li></ul></li></ul><p>对于网络层，由于链路层的存在，而不需要关心物理层具体采用了那种传输介质和通信设备。</p><blockquote><p>网络层、数据链路层和物理层要关联理解。</p><p>假如A与B通信（在不同的网段中），实际上AB之间还有很多的物理设备（交换机、路由器）。物理设备之间是通过传输介质相连接，比如光纤、同轴电缆（这属于物理层）。</p><p>消息从A到B，需要经过一个个的网段，每个网段内都是通过mac地址来寻找下一个站点（数据链路层）。在公网上使用IP来寻找目的主机（网络层）</p></blockquote><h4 id="传输单元"><a href="#传输单元" class="headerlink" title="传输单元"></a>传输单元</h4><p>物理层的 数据传输单元是数据位（bit）<br>数据链路层的数据传输单元是数据帧（frame）<br>网络层的数据传输单元是数据包（packet）<br>传输层的 数据传输单元是数据段（segment）<br>其他更高层次的数据传输单元是数据（data）</p><h3 id="TCP和UDP"><a href="#TCP和UDP" class="headerlink" title="TCP和UDP"></a>TCP和UDP</h3><table><thead><tr><th align="left"></th><th align="left">UDP</th><th>TCP</th></tr></thead><tbody><tr><td align="left">是否连接</td><td align="left">无连接</td><td>面向连接</td></tr><tr><td align="left">是否可靠</td><td align="left">不可靠传输，不使用流量控制和拥塞控制</td><td>可靠传输，使用流量控制和拥塞控制</td></tr><tr><td align="left">连接对象个数</td><td align="left">支持一对一，一对多，多对一和多对多交互通信</td><td>只能是一对一通信</td></tr><tr><td align="left">传输方式</td><td align="left">面向报文</td><td>面向字节流</td></tr><tr><td align="left">首部开销</td><td align="left">首部开销小，仅8字节</td><td>首部最小20字节，最大60字节</td></tr><tr><td align="left">适用场景</td><td align="left">适用于实时应用（IP电话、视频会议、直播等）</td><td>适用于要求可靠传输的应用，例如文件传输</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HTTP演进&quot;&gt;&lt;a href=&quot;#HTTP演进&quot; class=&quot;headerlink&quot; title=&quot;HTTP演进&quot;&gt;&lt;/a&gt;HTTP演进&lt;/h2&gt;&lt;h3 id=&quot;HTTP-0-9&quot;&gt;&lt;a href=&quot;#HTTP-0-9&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="NetWork" scheme="https://zxffan.github.io/categories/NetWork/"/>
    
    
    <category term="NetWork" scheme="https://zxffan.github.io/tags/NetWork/"/>
    
    <category term="HTTP" scheme="https://zxffan.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript原型污染</title>
    <link href="https://zxffan.github.io/posts/54b3fc67.html"/>
    <id>https://zxffan.github.io/posts/54b3fc67.html</id>
    <published>2021-04-28T16:00:00.000Z</published>
    <updated>2021-06-29T14:05:32.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="原型污染"><a href="#原型污染" class="headerlink" title="原型污染"></a>原型污染</h2><blockquote><p>原型污染就是，通过某种手段达到修改JavaScript原型的目的</p></blockquote><p>比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br></pre></td></tr></table></figure><p>定义了一个对象a，a有一个<code>constructor</code>属性指向a的构造器（<code>Object</code>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.constructor === <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>Object很常用，比如：<code>Object.prototype.toString</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(a) <span class="comment">// &quot;[object Object]&quot; 获取类型</span></span><br></pre></td></tr></table></figure><p>但是问题来了，通过a对象可以访问并修改Object对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.constructor.prototype.toString = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;attack&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 再使用 toString</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(a) <span class="comment">// &quot;attack&quot;</span></span><br></pre></td></tr></table></figure><p>这就发生了<strong>原型污染</strong></p><blockquote><p>lodash发生过一次严重的原型污染bug，场景是两个对象合并<code>merge(a, b)</code>， </p></blockquote><h2 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h2><h3 id="过滤危险属性"><a href="#过滤危险属性" class="headerlink" title="过滤危险属性"></a>过滤危险属性</h3><p>两个对象合并，把<code>constructor</code>属性和<code>__proto__</code>这样的敏感过滤掉。</p><h3 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze"></a>Object.freeze</h3><p><code>Object.freeze</code>可以冻结一个对象，这个对象不能被修改。</p><p>原理就是修改对象的<code>descriptor</code>中的<code>writable:false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.freeze(<span class="built_in">Object</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString = <span class="string">&quot;attack&quot;</span></span><br><span class="line"></span><br><span class="line">consoel.log(<span class="built_in">Object</span>.prototype.toString) <span class="comment">// ƒ toString() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure><h3 id="Object-create-null"><a href="#Object-create-null" class="headerlink" title="Object.create(null)"></a>Object.create(null)</h3><p>创建一个原型对象为null的对象，这样就不存在污染原型的情况</p><h3 id="Map代替对象字面量"><a href="#Map代替对象字面量" class="headerlink" title="Map代替对象字面量"></a>Map代替对象字面量</h3><p><code>map.set(&quot;__proto__&quot;, xx)</code>并不会修改原型对象</p><h2 id="提醒"><a href="#提醒" class="headerlink" title="提醒"></a>提醒</h2><p>深合并和深拷贝算法注意<strong>原型污染</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;原型污染&quot;&gt;&lt;a href=&quot;#原型污染&quot; class=&quot;headerlink&quot; title=&quot;原型污染&quot;&gt;&lt;/a&gt;原型污染&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;原型污染就是，通过某种手段达到修改JavaScript原型的目的&lt;/p&gt;
&lt;/blockquote</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://zxffan.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://zxffan.github.io/tags/JavaScript/"/>
    
    <category term="Promise" scheme="https://zxffan.github.io/tags/Promise/"/>
    
  </entry>
  
  <entry>
    <title>Webpack构建流程源码解析</title>
    <link href="https://zxffan.github.io/posts/aef11e42.html"/>
    <id>https://zxffan.github.io/posts/aef11e42.html</id>
    <published>2021-04-27T16:00:00.000Z</published>
    <updated>2021-06-29T14:04:51.123Z</updated>
    
    <content type="html"><![CDATA[<p>webpack的构建分为3个阶段：</p><ul><li>准备阶段：生成 <code>compiler</code>和<code>compilation</code>对象</li><li>编译阶段：递归生成模块依赖图</li><li>产出阶段：优化modules，生成chunks。最终输出文件</li></ul><p>本文讨论的是<code>webpack@5.34.0</code></p><h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><h3 id="创建compiler"><a href="#创建compiler" class="headerlink" title="创建compiler"></a>创建compiler</h3><p>对于每一个wepback的构建配置，都会创建一个<code>compiler</code>对象，记录着整个 Webpack 的生命周期</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> webpack <span class="keyword">from</span> <span class="string">&quot;webpack&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(options)</span><br><span class="line"><span class="comment">// webpack(options, () =&gt; &#123;&#125;)</span></span><br></pre></td></tr></table></figure><p>调用webpack函数会返回<code>compiler</code>对象，其内部大致逻辑如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="function">(<span class="params">options, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 创建compiler</span></span><br><span class="line">  <span class="keyword">let</span> compiler;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(options)) compiler = createMultiCompiler(options, options);</span><br><span class="line">  <span class="keyword">else</span> compiler = createCompiler(options);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2.</span></span><br><span class="line">  <span class="comment">// 有callback参数就会自动执行compiler.run</span></span><br><span class="line">  <span class="comment">// options中watch为true就会自动调用compiler.watch</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 返回compiler</span></span><br><span class="line">  <span class="keyword">return</span> compiler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>示例代码并非是webpack中的源码。只是将源码中的核心逻辑提炼出来的伪代码，这样更方便理解webpack的主流程。下同。</p></blockquote><p><code>createCompiler</code>和<code>createMultiCompiler</code>才是真正创建<code>compiler</code>的逻辑</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createCompiler = <span class="function"><span class="params">rawOptions</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 1. normalize options</span></span><br><span class="line">  <span class="comment">// 就是对传入的options做些初始化，添加默认参数之类的工作</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 他来了，创建compiler对象</span></span><br><span class="line"><span class="keyword">const</span> compiler = <span class="keyword">new</span> Compiler(options.context);</span><br><span class="line">compiler.options = options;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2. 新建NodeEvniromentPlugin，这是wepback启用的第一个plugin</span></span><br><span class="line">  <span class="comment">// 主要作用是 </span></span><br><span class="line">  <span class="comment">// - 创建日志（方便webpack输出构建日志）</span></span><br><span class="line">  <span class="comment">// - 设置compiler的文件系统 inputFileSystem...</span></span><br><span class="line"><span class="keyword">new</span> NodeEnvironmentPlugin(&#123;</span><br><span class="line">infrastructureLogging: options.infrastructureLogging</span><br><span class="line">&#125;).apply(compiler);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3. 执行所有plugin</span></span><br><span class="line">  <span class="comment">// - 函数plugin，执行函数</span></span><br><span class="line">  <span class="comment">// - class plugin，执行其apply方法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(options.plugins)) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> options.plugins) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">plugin.call(compiler, compiler);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">plugin.apply(compiler);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  applyWebpackOptionsDefaults(options);</span><br><span class="line">compiler.hooks.environment.call(); <span class="comment">// hook</span></span><br><span class="line">compiler.hooks.afterEnvironment.call(); <span class="comment">// hook</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 5.添加默认内置plugin</span></span><br><span class="line">  <span class="comment">// 根据options的设置来配置响应内置plugin</span></span><br><span class="line"><span class="keyword">new</span> WebpackOptionsApply().process(options, compiler); </span><br><span class="line">compiler.hooks.initialize.call();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> compiler</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> createMultiCompiler = <span class="function">(<span class="params">childOptions, options</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 给每一个option创建一个compiler</span></span><br><span class="line"><span class="keyword">const</span> compilers = childOptions.map(<span class="function"><span class="params">options</span> =&gt;</span> createCompiler(options));</span><br><span class="line">  <span class="comment">// 创建MultiCompiler对象</span></span><br><span class="line"><span class="keyword">const</span> compiler = <span class="keyword">new</span> MultiCompiler(compilers, options);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> compiler;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里注意一点：在<code>compiler</code>对象创建后：</p><ol><li>逐一执行<code>options.plugins</code>中所有的plugin。</li><li>根据options的内容，添加webpack内置的plugin。比如<code>EntryOptionPlugin</code>。针对不同环境(node electron browser)会设置不同的plugin。</li></ol><blockquote><p>webpack有大量的内置plugin，这都是在<code>WebpackOptionsApply</code>中的<code>process</code>来设置的。可以说webpack的所有功能(resolve optimization module解析…)都是由相应的plugin完成的。</p></blockquote><p>获得<code>compiler</code>对象后，下一步就时进行构建，这是通过<code>compiler.run</code>方法实现的。</p><p><code>run</code>方法主要做了2件事：</p><ul><li>执行compiler的hook <code>beforeRun</code> <code>run</code> <code>readRecords</code>。在创建compiler对象时会执行所有plugin。如果在这三个hook绑定的了事件，在此时会被执行。（这三个hook时串行执行的，代码是嵌套的）</li><li>执行<code>compiler.compile</code>方法进行构建</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.beforeRun.callAsync(<span class="built_in">this</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> finalCallback(err);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.hooks.run.callAsync(<span class="built_in">this</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> finalCallback(err);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.readRecords(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> finalCallback(err);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">this</span>.compile(onCompiled);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="创建Compilation"><a href="#创建Compilation" class="headerlink" title="创建Compilation"></a>创建Compilation</h3><p><code>compilation</code>对象属于<code>compiler</code>。每一次构建，<code>compiler</code>都会创建一个<code>compilation</code>对象</p><p><code>compiler.compile</code>方法会真正地创建<code>compilation</code>对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./lib/Compiler.js</span></span><br><span class="line"><span class="comment">// compile</span></span><br><span class="line"><span class="keyword">const</span> params = <span class="built_in">this</span>.newCompilationParams();</span><br><span class="line"><span class="built_in">this</span>.hooks.beforeCompile.callAsync(params, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.hooks.compile.call(params);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建compilation对象</span></span><br><span class="line">  <span class="keyword">const</span> compilation = <span class="built_in">this</span>.newCompilation(params);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 执行compiler的各种hook</span></span><br><span class="line">  <span class="comment">// 以及执行compilation的 finish 和 seal方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代码很长，主要流程如下:</p><ol><li><code>compiler.hooks.beforeCompile</code> </li><li>创建<code>compilation</code>对象。这里调用了<code>compiler.newCompilation</code>方法，该方法做了以下几件事<ol><li>创建<code>compilation</code>，会先清理上一次构建的<code>compilation</code>对象</li><li><code>compiler.hooks.thisCompilation</code></li><li><code>compiler.hooks.compilation</code></li></ol></li><li><code>compiler.hooks.make</code> </li><li> <code>compiler.hooks.finishMake</code></li><li><code>compilation.finish</code></li><li><code>compilation.seal</code></li><li><code>compiler.hooks.afterCompile</code></li></ol><p>这些hooks都是串行执行的。<code>afterCompile</code>这个hook的执行表示一次构建已经完成。那么从compilation对象创建完成到<code>afterCompile</code>触发之前，包含了<strong>编译阶段</strong>和<strong>产出阶段</strong></p><h2 id="编译阶段"><a href="#编译阶段" class="headerlink" title="编译阶段"></a>编译阶段</h2><p><code>compiler.hooks.make</code>这个hook被触发执行，就代表了编译开始。</p><p>在<code>compiler</code>创建时(<code>new WebpackOptionsApply().process(options, compiler); </code>)，这里给compiler添加了许多并绑定了许多内置plugin。其中有一个<code>EntryOptionsPlugin</code>，他是用于解析入口(entry)配置。根据entry字段类型再选择不同的plugin</p><ul><li>entry为function：<code>DynamicEntryPlugin</code></li><li>entry不为function：<code>EntryPlugin</code></li></ul><p>编译阶段的开始就是从<code>entry</code>文件开始解析<code>module</code>。</p><p>以<code>EntryPlugin</code>为例，其apply方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">compiler.hooks.make.tapAsync(<span class="string">&quot;EntryPlugin&quot;</span>, <span class="function">(<span class="params">compilation, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; entry, options, context &#125; = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dep = EntryPlugin.createDependency(entry, options);</span><br><span class="line">  compilation.addEntry(context, dep, options, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    callback(err);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>EntryPlugin</code>在<code>compile.make</code>这个hook上注册了一个事件。<code>compiler.hooks.make</code>这个hook被触发执行时，hook上注册的事件全都会被执行。</p><p><code>EntryPlugin</code>会调用<code>compilation.addEntry</code>方法。</p><p>接下看就看<code>compilation</code>的表演：</p><ol><li>addEntry添加入口文件</li><li>将资源文件转成<code>NormalModule</code>对象（简称module对象），一个文件(js css img)都是一个module</li><li>调用<code>module.build</code>方法</li><li>调用<code>runLoaders</code>，找到相应的loader处理该module</li><li>对于js module，会通过<code>acorn</code>转成<code>AST</code>。分析模块依赖关系，如果有依赖模块 调用<code>compilation.addEntry</code>（第1步）</li><li>最终获取所有module</li></ol><blockquote><p>编译阶段是一个递归的过程</p><p>每一个module build完成都会触发<code>compilation.hooks.succeedModule</code>，并传入当前module对象</p></blockquote><h2 id="产出阶段"><a href="#产出阶段" class="headerlink" title="产出阶段"></a>产出阶段</h2><p>调用<code>compilation.seal</code>方法，封存文件就是处理文件生成chunk。</p><h3 id="Seal"><a href="#Seal" class="headerlink" title="Seal"></a>Seal</h3><p>首先触发<code>compilation.hooks.optimizeDependencies</code>这个hook上的所有事件。对module做一些优化操作（比如<code>tree-shaking</code>）</p><p>根据入口生成chunk，有几个入口就会有几个chunk。</p><p>然后就是递归分析chunk，如果有动态导入(<code>import()</code>)就会单独拆分出chunk</p><blockquote><p>这个过程还有一堆hooks，这些可以在这些hooks上做些优化操作。比如<code>optimizeModules</code>和<code>optimizeChunks</code></p></blockquote><p>生成chunck的<code>hash</code></p><p>生成chunk的<code>sourceMap</code></p><h3 id="Assets"><a href="#Assets" class="headerlink" title="Assets"></a>Assets</h3><p><code>createChunkAssets</code>生成assets ，会将生成的Assets存放到<code>compilation.assets</code>数组中</p><p><code>emitAsset</code>将文件输出</p><h2 id="Watch模式"><a href="#Watch模式" class="headerlink" title="Watch模式"></a>Watch模式</h2><p>当调用<code>compiler.watch</code>，会启用watch模式。当文件发生更改是，会自动重新构建.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">watch</span>(<span class="params">watchOptions, handler</span>)</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="built_in">this</span>.watching = <span class="keyword">new</span> Watching(<span class="built_in">this</span>, watchOptions, handler);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.watching;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>watch方法创建了一个<code>Watching</code>实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watch</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">contstructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">this</span>._invalidate()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_invalidate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 防止重复构建</span></span><br><span class="line">    <span class="built_in">this</span>._go()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_go</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建逻辑</span></span><br><span class="line">    compiler.compile() <span class="comment">// 调用compiler的compile方法进行构建</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_done</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 构建完成了</span></span><br><span class="line">    <span class="comment">// 获取构建完后的依赖</span></span><br><span class="line">    <span class="built_in">this</span>.watch() <span class="comment">// 监听这些依赖</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">watch</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 监听文件变化</span></span><br><span class="line">    <span class="built_in">this</span>.compiler.watchFileSystem.watch()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 文件发生变化 监听的回调会被调用</span></span><br><span class="line">    <span class="built_in">this</span>._invalidate() <span class="comment">// 进行下一轮构建</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听文件是通过<code>this.compiler.watchFileSystem.watch()</code>方法来实现的。这个<code>watchFileSystem</code>是在创建<code>compiler</code>对象时，初始化的。</p><p>创建<code>compiler</code>时，执行了<code>NodeEvniromentPlugin</code>。这个plugin会设置文件系统。将<code>watchFleSystem</code>设置成<code>NodeWatchFileSystem</code>，而其内部又会创建一个<code>watchpack</code>对象来监听文件变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeEnvironmentPlugin</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">apply</span>(<span class="params">compiler</span>)</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">compiler.inputFileSystem = <span class="keyword">new</span> CachedInputFileSystem(fs, <span class="number">60000</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">compiler.watchFileSystem = <span class="keyword">new</span> NodeWatchFileSystem(</span><br><span class="line">compiler.inputFileSystem</span><br><span class="line">);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>值得一提的是，当文件短时间变化多次，会触发多次构建吗？</p><p>其实是不会的，<code>watchpack</code>添加了防抖机制。只会触发最后一次。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一张图总结流程</p><p><img src="../../images/framework/webpack%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B.svg" alt="webpack构建流程"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;webpack的构建分为3个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;准备阶段：生成 &lt;code&gt;compiler&lt;/code&gt;和&lt;code&gt;compilation&lt;/code&gt;对象&lt;/li&gt;
&lt;li&gt;编译阶段：递归生成模块依赖图&lt;/li&gt;
&lt;li&gt;产出阶段：优化modules，生</summary>
      
    
    
    
    <category term="工程化" scheme="https://zxffan.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="javascript" scheme="https://zxffan.github.io/tags/javascript/"/>
    
    <category term="webpack" scheme="https://zxffan.github.io/tags/webpack/"/>
    
    <category term="架构" scheme="https://zxffan.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>vue2-生命周期</title>
    <link href="https://zxffan.github.io/posts/bdeefbce.html"/>
    <id>https://zxffan.github.io/posts/bdeefbce.html</id>
    <published>2021-04-26T16:00:00.000Z</published>
    <updated>2021-06-29T14:07:23.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue2生命周期图"><a href="#Vue2生命周期图" class="headerlink" title="Vue2生命周期图"></a>Vue2生命周期图</h2><p><img src="../../images/Vue/vue2%E4%BB%8E%E5%88%9B%E5%BB%BA%E5%88%B0%E6%B8%B2%E6%9F%93.svg" alt="生命周期"></p><h2 id="组件创建到页面渲染"><a href="#组件创建到页面渲染" class="headerlink" title="组件创建到页面渲染"></a>组件创建到页面渲染</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>new Vue()</code>的执行，会创建一个组件实例（根组件）<code>vm</code>，然后进行各种初始化工作</p><ol><li>合并 options，也就是初始化组件的options选项</li><li>初始化vm（组件实例）上的各个属性</li><li>初始化绑定在当前组件上的listener(v-on)</li><li>初始化render函数，在vm上绑定createElement方法</li><li>**<code>beforeCreated</code>**钩子调用</li><li>将inject定义为响应式</li><li>.初始化, 定义响应式数据 <code>props</code>  <code>methods</code> <code>data</code> <code> computed</code> <code>watch</code></li><li>初始化vm._provide属性</li><li>**<code>creted</code>**钩子调用</li></ol><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>如果<code>new Vue</code>传入了<code>el</code>属性，就会自动调用<code>vm.$mount</code>方法，渲染实例</p><ol><li>调用<code>mountComponent</code></li><li>新建Watcher，传入<code>updateComponent</code>逻辑</li><li>Watcher调用<code>updateComponent</code>逻辑</li><li>进入<code>patch</code>逻辑</li></ol><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><p>vue2的响应式涉及到三种角色——<code>reactiveObj(响应式对象)</code> <code>Watcher</code>  <code>Dep</code></p><ul><li>响应式对象通过<code>Object.defineProperty</code>拦截getter和setter</li><li>Watcher用于触发组件更新</li><li>每个响应式对象都有一个dep对象，它有一个subs的Watcher数组，用于记录依赖该响应式对象的所有watcher</li></ul><p>当组件开始渲染时：</p><ul><li>会创建一个<code>Watcher</code>对象。将组件更新的逻辑（<code>updateComponent</code>）记录到Watcher</li><li>将Dep.target设置为 创建的 <code>Watcher</code>对象</li></ul><p>随即执行render方法，会触发响应式对象的getter。将<code>Dep.target</code>添加到<code>dep.subs</code>中，即依赖收集</p><p>在修改响应式对象，会触发setter。</p><ul><li>执行<code>dep.notify</code>，触发<code>dpe.subs</code>中所有<code>watcher</code>的<code>update</code>方法</li><li><code>watcher.update()</code>会触发<code>updateComponent</code>，从而使得组件更新</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Vue2生命周期图&quot;&gt;&lt;a href=&quot;#Vue2生命周期图&quot; class=&quot;headerlink&quot; title=&quot;Vue2生命周期图&quot;&gt;&lt;/a&gt;Vue2生命周期图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;../../images/Vue/vue2%E4%BB%8E%E</summary>
      
    
    
    
    <category term="源码" scheme="https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="vue" scheme="https://zxffan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Webpack之SplitChunks</title>
    <link href="https://zxffan.github.io/posts/110bf707.html"/>
    <id>https://zxffan.github.io/posts/110bf707.html</id>
    <published>2021-04-25T16:00:00.000Z</published>
    <updated>2021-06-29T14:04:56.114Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SplitChunks"><a href="#SplitChunks" class="headerlink" title="SplitChunks"></a>SplitChunks</h2><p><code>splitChunks</code>可以指定<code>webpack</code>打包的拆分规则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      chunks: <span class="string">&quot;async&quot;</span>, <span class="comment">// 三选一： &quot;initial&quot; | &quot;all&quot; | &quot;async&quot; (默认)</span></span><br><span class="line">      minSize: <span class="number">30000</span>, <span class="comment">// 最小尺寸，30K，development 下是10k，越大那么单个文件越大，chunk 数就会变少（针对于提取公共 chunk的时候，不管再大也不会把动态加载的模块合并到初始化模块中）当这个值很大的时候就不会做公共部分的抽取了</span></span><br><span class="line">      maxSize: <span class="number">0</span>, <span class="comment">// 文件的最大尺寸，0为不限制，优先级：maxInitialRequest/maxAsyncRequests &lt; maxSize &lt; minSize</span></span><br><span class="line">      minChunks: <span class="number">1</span>, <span class="comment">// 默认1，被提取的一个模块至少需要在几个 chunk 中被引用，这个值越大，抽取出来的文件就越小</span></span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>, <span class="comment">// 在做一次按需加载的时候最多有多少个异步请求，为 1 的时候就不会抽取公共 chunk 了</span></span><br><span class="line">      maxInitialRequests: <span class="number">3</span>, <span class="comment">// 针对一个 entry 做初始化模块分隔的时候的最大文件数，优先级高于 cacheGroup，所以为 1 的时候就不会抽取 initial common 了</span></span><br><span class="line">      automaticNameDelimiter: <span class="string">&quot;~&quot;</span>, <span class="comment">// 打包文件名分隔符</span></span><br><span class="line">      name: <span class="literal">true</span>, <span class="comment">// 拆分出来文件的名字，默认为 true，表示自动生成文件名，如果设置为固定的字符串那么所有的 chunk 都会被合并成一个</span></span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>, <span class="comment">// 正则规则，如果符合就提取 chunk</span></span><br><span class="line">          priority: -<span class="number">10</span>, <span class="comment">// 缓存组优先级，当一个模块可能属于多个 chunkGroup，这里是优先级</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: -<span class="number">20</span>, <span class="comment">// 优先级</span></span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>, <span class="comment">// 如果该chunk包含的modules都已经另一个被分割的chunk中存在，那么直接引用已存在的chunk，不会再重新产生一个</span></span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用动态导入<code>import()</code>或者<code>requre.ensure()</code>，就会根据</p><h2 id="SplitChunks参数"><a href="#SplitChunks参数" class="headerlink" title="SplitChunks参数"></a>SplitChunks参数</h2><h3 id="chunks"><a href="#chunks" class="headerlink" title="chunks"></a>chunks</h3><p>有三个值——<code>async</code> <code>all</code> <code>initial</code></p><h4 id="async-默认"><a href="#async-默认" class="headerlink" title="async(默认)"></a>async(默认)</h4><p>只会将异步模块（<code>import()</code>导入的模块）提出出来</p><h4 id="initial"><a href="#initial" class="headerlink" title="initial"></a>initial</h4><p>提取同步模块和异步模块。如果一个模块在moduleA中是同步导入，在moduleB中是异步导入。那么由于导入方式不同，这个模块会被抽离出不同的文件。</p><h4 id="all"><a href="#all" class="headerlink" title="all"></a>all</h4><p>提取同步模块和异步模块，无论是同步import还是异步import。都会抽离到一个文件中。<code>all</code>会最大程度复用文件。</p><h3 id="maxInitialRequests和maxAsyncRequests"><a href="#maxInitialRequests和maxAsyncRequests" class="headerlink" title="maxInitialRequests和maxAsyncRequests"></a>maxInitialRequests和maxAsyncRequests</h3><p>浏览器对相同域名的并法请求是有限制的。比如chrome 限制6个相同域名的请求。如果同一时间发送10个请求。则另外4个就会被阻塞</p><p>所以，<code>splitChunks</code>把文件拆得太碎，反而会影响加载时间。</p><p><code>maxInitialRequests</code>设置为<code>3</code>，表示浏览器初始最多发送3个请求。它会将入口文件拆成&lt;3份。</p><p><code>maxAsyncRequests</code>是用来限制异步模块并行最大请求数的。</p><blockquote><p>前者是限定入口的文件的拆分，后者是限定异步模块的拆分</p></blockquote><h3 id="minSize和maxSize"><a href="#minSize和maxSize" class="headerlink" title="minSize和maxSize"></a>minSize和maxSize</h3><p><code>minSize</code>：满足拆分的最小体积（单位字节）。大于这个大小并满足拆分规则就会被拆分</p><p><code>maxSize</code>：默认为0表示不作限制。如果非0。待拆分模块大小大于<code>maxSize</code>时就会拆分</p><blockquote><p>规则优先级：maxInitialRequest/maxAsyncRequests &lt; maxSize &lt; minSize</p></blockquote><h3 id="cacheGroups"><a href="#cacheGroups" class="headerlink" title="cacheGroups"></a>cacheGroups</h3><p>这是<code>splitChunks</code>最重要的部分。它定义了拆分规则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cacheGroups: &#123;</span><br><span class="line">  vendors: &#123;</span><br><span class="line">    test: <span class="regexp">/[\\/]node_modules[\\/]/</span>, <span class="comment">// 正则规则，如果符合就提取 chunk</span></span><br><span class="line">    priority: -<span class="number">10</span>, <span class="comment">// 缓存组优先级，当一个模块可能属于多个 chunkGroup，这里是优先级</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>test</code>表示匹配规则，可以是一个正则。<code>/[\\/]node_modules[\\/]</code>表示匹配<code>/node_modules/</code>或着<code>\node_modules\</code></p><p><code>priority</code>：缓存组优先级，当一个模块可能属于多个 chunkGroup时，取优先级高的</p><p><code>reuseExistingChunk</code>: true表示复用其他chunk内已拥有的模块 当chunks引用了已经存在的被抽离的chunks时不会新创建一个chunk而是复用chunk。</p><p>其它属性：<code>chunks</code> <code>maxInitialRequests</code> <code>maxAsyncRequests</code> <code>minSize</code>…….</p><blockquote><p>cacheGroups下找不到<code>chunks</code>等属性，就会去splitChunks中的配置。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;SplitChunks&quot;&gt;&lt;a href=&quot;#SplitChunks&quot; class=&quot;headerlink&quot; title=&quot;SplitChunks&quot;&gt;&lt;/a&gt;SplitChunks&lt;/h2&gt;&lt;p&gt;&lt;code&gt;splitChunks&lt;/code&gt;可以指定&lt;code&gt;</summary>
      
    
    
    
    <category term="工程化" scheme="https://zxffan.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
    <category term="javascript" scheme="https://zxffan.github.io/tags/javascript/"/>
    
    <category term="webpack" scheme="https://zxffan.github.io/tags/webpack/"/>
    
    <category term="架构" scheme="https://zxffan.github.io/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>web-vitals源码解读</title>
    <link href="https://zxffan.github.io/posts/473044000000.html"/>
    <id>https://zxffan.github.io/posts/473044000000.html</id>
    <published>2021-04-25T16:00:00.000Z</published>
    <updated>2021-06-29T14:07:46.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web-vitals简介"><a href="#web-vitals简介" class="headerlink" title="web-vitals简介"></a>web-vitals简介</h2><p><a href="https://www.npmjs.com/package/web-vitals#overview">web-vitals</a>是<code>google</code>开源的一个测量web性能指标的工具。体积才<strong>1KB</strong>，它可以用来测量<code>CLS</code>、<code>FID</code>、<code>LCP</code>、<code>FCP</code>、<code>TTFB</code>。</p><p>可通过npm来安装<code>npm install web-vitals</code></p><p>使用也十分简单</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;getLCP, getFID, getCLS&#125; <span class="keyword">from</span> <span class="string">&#x27;web-vitals&#x27;</span>;</span><br><span class="line"></span><br><span class="line">getCLS(<span class="built_in">console</span>.log);</span><br><span class="line">getFID(<span class="built_in">console</span>.log);</span><br><span class="line">getLCP(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><code>web-vitals</code>整个项目不是很复杂，目录结构如下</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">├─.git</span><br><span class="line">├─docs</span><br><span class="line">├─src # 源码</span><br><span class="line">├─test # 测试代码</span><br><span class="line">├─.eslintrc </span><br><span class="line">├─.gitignore</span><br><span class="line">├─base.d.ts</span><br><span class="line">├─base.js</span><br><span class="line">├─CHANGELOG.md</span><br><span class="line">├─LICENSE # 开源协议</span><br><span class="line">├─package-lock.json</span><br><span class="line">├─package.json</span><br><span class="line">├─README.md</span><br><span class="line">├─rollup.config.js # rollup构建配置</span><br><span class="line">├─tsconfig.json # ts配置</span><br><span class="line">├─wdio.conf.js # e2e测试配置</span><br></pre></td></tr></table></figure><h2 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h2><h3 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h3><p><code>web-vitals</code>通过配置eslint来约定代码规范。通常，<code>eslint</code>配置文件位于根目录下。这样对于整个项目都通用一套<code>eslint</code>配置。这往往是不满足需求的。可能src目录需要一套eslint配置，而test目录有需要另一套eslint配置。<code>web-vitals</code>是通过<code>eslintrc</code>下的<strong>overrides</strong>字段配置的</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;parser&quot;</span>: <span class="string">&quot;babel-eslint&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;env&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;browser&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;es6&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;node&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;mocha&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;overrides&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;files&quot;</span>: <span class="string">&quot;wdio.conf.js&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;extends&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;eslint:recommended&quot;</span>, <span class="string">&quot;google&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;max-len&quot;</span>: <span class="string">&quot;off&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;files&quot;</span>: [<span class="string">&quot;test/e2e/*.js&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;globals&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;$&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">&quot;browser&quot;</span>: <span class="literal">false</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;extends&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;eslint:recommended&quot;</span>, <span class="string">&quot;google&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;no-invalid-this&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;max-len&quot;</span>: [<span class="number">2</span>, &#123;</span><br><span class="line">          <span class="attr">&quot;ignorePattern&quot;</span>: <span class="string">&quot;^\\s*import|= require\\(|^\\s*it\\(|^\\s*describe\\(&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;ignoreUrls&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;],</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;files&quot;</span>: <span class="string">&quot;src/**/*.ts&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;parser&quot;</span>: <span class="string">&quot;@typescript-eslint/parser&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;extends&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;plugin:@typescript-eslint/recommended&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">&quot;rules&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;@typescript-eslint/no-non-null-assertion&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@typescript-eslint/no-use-before-define&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@typescript-eslint/explicit-function-return-type&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@typescript-eslint/explicit-module-boundary-types&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@typescript-eslint/ban-ts-comment&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;@typescript-eslint/camelcase&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;node/no-missing-import&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;node/no-unsupported-features/es-syntax&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;node/no-missing-require&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;node/shebang&quot;</span>: <span class="string">&quot;off&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;no-dupe-class-members&quot;</span>: <span class="string">&quot;off&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;parserOptions&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;ecmaVersion&quot;</span>: <span class="number">2018</span>,</span><br><span class="line">        <span class="attr">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>overrides</code>字段对应的值是一个数组，该数组中的每个元素都是一条新的eslint规则，并覆盖全局配置</p><h3 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h3><p><a href="https://typicode.github.io/husky/"><code>husky</code></a>是一个<code>git</code>钩子工具，<code>package.json</code>文件下有个<code>husky</code>字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;eslint \&quot;*.js\&quot; \&quot;src/**/*.ts\&quot; \&quot;test/**/*.js\&quot;&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;lint:fix&quot;</span>: <span class="string">&quot;eslint --fix \&quot;*.js\&quot; \&quot;src/**/*.ts\&quot; \&quot;test/**/*.js\&quot;&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;husky&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;pre-commit&quot;</span>: <span class="string">&quot;npm run lint&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它的作用是，在每次<code>git commit</code>时，触发钩子并执行<code>npm run lint</code>，也就是进行Eslint检查。如果没有通过eslint，就会commit失败。</p><h3 id="rollup-plugin-eslint"><a href="#rollup-plugin-eslint" class="headerlink" title="@rollup/plugin-eslint"></a>@rollup/plugin-eslint</h3><p><code>web-vitals</code>的<code>rollup</code>并没有配置<a href="https://github.com/rollup/plugins/tree/master/packages/eslint">@rollup/plugin-eslint</a>。如果加上这个插件，会在构建时进行eslint检查，如果没有通过eslint，就会构建失败并给出相应的修复提示。</p><h2 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h2><p><code>web-vitals</code>是通过<code>rollup</code>进行构建打包的。其配置也十分简单</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rollup.config.js</span></span><br><span class="line"><span class="keyword">import</span> replace <span class="keyword">from</span> <span class="string">&#x27;@rollup/plugin-replace&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;terser&#125; <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-terser&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> babel <span class="keyword">from</span> <span class="string">&#x27;rollup-plugin-babel&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> configurePlugins = <span class="function">(<span class="params">&#123;<span class="built_in">module</span>, polyfill = <span class="literal">false</span>&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    babel(&#123;</span><br><span class="line">      presets: [[<span class="string">&#x27;@babel/preset-env&#x27;</span>, &#123;</span><br><span class="line">        targets: &#123;</span><br><span class="line">          browsers: [<span class="string">&#x27;ie 11&#x27;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;]],</span><br><span class="line">    &#125;),</span><br><span class="line">    terser(&#123;</span><br><span class="line">      <span class="built_in">module</span>,</span><br><span class="line">      mangle: <span class="literal">true</span>,</span><br><span class="line">      compress: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    replace(&#123;</span><br><span class="line">      <span class="string">&#x27;self.__WEB_VITALS_POLYFILL__&#x27;</span>: polyfill,</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> configs = [</span><br><span class="line">  &#123;</span><br><span class="line">    input: <span class="string">&#x27;dist/modules/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">      format: <span class="string">&#x27;esm&#x27;</span>,</span><br><span class="line">      file: <span class="string">&#x27;./dist/web-vitals.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: configurePlugins(&#123;<span class="attr">module</span>: <span class="literal">true</span>, <span class="attr">polyfill</span>: <span class="literal">false</span>&#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    input: <span class="string">&#x27;dist/modules/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">      format: <span class="string">&#x27;umd&#x27;</span>,</span><br><span class="line">      file: <span class="string">`./dist/web-vitals.umd.js`</span>,</span><br><span class="line">      name: <span class="string">&#x27;webVitals&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: configurePlugins(&#123;<span class="attr">module</span>: <span class="literal">false</span>, <span class="attr">polyfill</span>: <span class="literal">false</span>&#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    input: <span class="string">&#x27;dist/modules/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">      format: <span class="string">&#x27;esm&#x27;</span>,</span><br><span class="line">      file: <span class="string">&#x27;./dist/web-vitals.base.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: configurePlugins(&#123;<span class="attr">module</span>: <span class="literal">true</span>, <span class="attr">polyfill</span>: <span class="literal">true</span>&#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    input: <span class="string">&#x27;dist/modules/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">      format: <span class="string">&#x27;umd&#x27;</span>,</span><br><span class="line">      file: <span class="string">`./dist/web-vitals.base.umd.js`</span>,</span><br><span class="line">      name: <span class="string">&#x27;webVitals&#x27;</span>,</span><br><span class="line">      extend: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: configurePlugins(&#123;<span class="attr">module</span>: <span class="literal">false</span>, <span class="attr">polyfill</span>: <span class="literal">true</span>&#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    input: <span class="string">&#x27;dist/modules/polyfill.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">      format: <span class="string">&#x27;iife&#x27;</span>,</span><br><span class="line">      file: <span class="string">&#x27;./dist/polyfill.js&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;webVitals&#x27;</span>,</span><br><span class="line">      strict: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: configurePlugins(&#123;<span class="attr">module</span>: <span class="literal">false</span>&#125;),</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> configs;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="不同的产出文件"><a href="#不同的产出文件" class="headerlink" title="不同的产出文件"></a>不同的产出文件</h3><p>导出的<code>config</code>是一个数组。每个数组元素是一份rollup配置</p><table><thead><tr><th>产出文件名</th><th>module</th><th>polyfill</th></tr></thead><tbody><tr><td>web-vitals.js</td><td>esm</td><td>不含</td></tr><tr><td>web-vitals.umd.js</td><td>umd</td><td>不含</td></tr><tr><td>web-vitals.base.js</td><td>esm</td><td>含</td></tr><tr><td>web-vitals.base.umd.js</td><td>umd</td><td>含</td></tr><tr><td>polyfill.js</td><td>iife</td><td>-</td></tr></tbody></table><ul><li><p><code>esm</code>：即 ES Module，在代码中直接<code>import</code>使用</p></li><li><p><code>iife</code>：立即执行函数，就是<code>(function() &#123;&#125;)(window)</code>这种形式</p></li><li><p><code>umd</code>：本质上也是iife，但是它将待执行的函数作为iife的参数传入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">IIFE</span>(<span class="params"> def </span>) </span>&#123;</span><br><span class="line">  def( <span class="built_in">window</span> );</span><br><span class="line">&#125;)(<span class="function"><span class="keyword">function</span> <span class="title">def</span>(<span class="params"> <span class="built_in">global</span> </span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log( a ); <span class="comment">// 3 </span></span><br><span class="line">  <span class="built_in">console</span>.log( <span class="built_in">global</span>.a ); <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p><code>iife</code>和<code>umd</code>都是直接在浏览器中使用了</p><h3 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h3><p>rolup使用了<code>@rollup/plugin-replace</code>，用于替换一些常量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">replace(&#123;</span><br><span class="line">    <span class="string">&#x27;self.__WEB_VITALS_POLYFILL__&#x27;</span>: polyfill,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这会将代码中所有出现的<code>self.__WEB_VITALS_POLYFILL__</code>的地方替换成<code>polyfill</code>变量的对应的值（<code>true</code>或<code>false</code>）。在代码中出现大量的<code>self.__WEB_VITALS_POLYFILL__</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib/getFirstHidden.ts </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// function getFirstHidden</span></span><br><span class="line"><span class="keyword">if</span> (self.__WEB_VITALS_POLYFILL__) &#123;</span><br><span class="line">    firstHiddenTime = self.webVitals.firstHiddenTime;</span><br><span class="line">    <span class="keyword">if</span> (firstHiddenTime === <span class="literal">Infinity</span>) &#123;</span><br><span class="line">        trackChanges();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    firstHiddenTime = initHiddenTime();</span><br><span class="line">    trackChanges();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>self.__WEB_VITALS_POLYFILL__</code>是true，rollup在构建时，就会吧else的逻辑删掉。反之，会把if的逻辑给删掉。这样就实现了Tree Shaking——删除多余代码。</p><h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p><code>web-vitals</code>的源码是使用TS编写的，最终需要生成js文件。</p><p><code>web-vitals</code>的构建过程：</p><ul><li>先通过tsc生成<strong>js文件</strong>和<strong>类型声明文件</strong>。</li><li>再通过<strong>rollup</strong>进行对<strong>js文件</strong>打包构建</li></ul><p>类型声明需要再<code>package.json</code>中<code>typings</code>字段指定声明文件的位置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;dist/web-vitals.umd.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;dist/web-vitals.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;typings&quot;</span>: <span class="string">&quot;dist/modules/index.d.ts&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;files&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;base.js&quot;</span>,</span><br><span class="line">        <span class="string">&quot;base.d.ts&quot;</span>,</span><br><span class="line">        <span class="string">&quot;dist&quot;</span>,</span><br><span class="line">        <span class="string">&quot;src&quot;</span></span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>main</code>:  定义了 npm 包的入口文件，browser 环境和 node 环境均可使用</p></li><li><p><code>module</code>:  定义 npm 包的 ESM 规范的入口文件，browser 环境和 node 环境均可使用</p></li><li><p>好有个<code>browser</code> : 定义 npm 包在 browser 环境下的入口文件</p></li><li><p><code>files</code>：当<code>npm publish</code>是，指定需要上传的文件。</p></li></ul><h2 id="开源协议"><a href="#开源协议" class="headerlink" title="开源协议"></a>开源协议</h2><p><code>web-vitals</code>采用<code>Apache-2.0</code>开源协议。该协议允许开发者修改代码，并且商业发布。但是对于改动部分必须提供一份声明。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><code>web-vitals</code>的测试需要真实的浏览器环境，即需要<strong>端到端测试（e2e test）</strong>。项目通过[wdio（webDriver.IO）](<a href="https://webdriver.io/docs/gettingstarted">Getting Started | WebdriverIO</a>)来实现的。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;npm-run-all build -p -r test:*&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;test:e2e&quot;</span>: <span class="string">&quot;wdio wdio.conf.js&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;test:server&quot;</span>: <span class="string">&quot;node test/server.js&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试流程"><a href="#测试流程" class="headerlink" title="测试流程"></a>测试流程</h3><p>当执行<code>npm run test</code>时</p><ul><li>先构建打包项目</li><li>启动一个HTTP服务，用于处理浏览器的资源请求</li><li>启动wdio测试</li></ul><p>当执行test/e2e目录下的测试用例时，例如<code>getLCP-test.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;reports the correct value on hidden (reportAllChanges === false)&#x27;</span>, <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 浏览器不支持就跳过这条用例</span></span><br><span class="line">    <span class="keyword">if</span> (!browserSupportsLCP) <span class="built_in">this</span>.skip();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开 /test/lcp这个网页，这是测试网页</span></span><br><span class="line">    <span class="keyword">await</span> browser.url(<span class="string">&#x27;/test/lcp&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有图片加载完成</span></span><br><span class="line">    <span class="keyword">await</span> imagesPainted();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳转到空白页，触发上一个页面的 hide状态</span></span><br><span class="line">    <span class="keyword">await</span> browser.url(<span class="string">&#x27;about:blank&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测是beacon.log中是否有数据，参数为数据条数</span></span><br><span class="line">    <span class="keyword">await</span> beaconCountIs(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对 beacon数据进行断言</span></span><br><span class="line">    assertStandardReportsAreCorrect(<span class="keyword">await</span> getBeacons());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当输入<code>browser.url(&#39;/test/lcp&#39;)</code>其实访问的地址是<code>http://localhost:9090/test/lcp</code>(在wdio.config.js中配置的)。这条请求会发送给本地的HTTP服务上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/test/server.js</span></span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/test/:view&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    ...req.query,</span><br><span class="line">    modulePath: <span class="string">`/dist/web-vitals<span class="subst">$&#123;</span></span></span><br><span class="line"><span class="string"><span class="subst">        req.query.polyfill ? <span class="string">`.base`</span> : <span class="string">``</span>&#125;</span>.js`</span>,</span><br><span class="line">    webVitalsPolyfill: fs.readFileSync(<span class="string">&#x27;./dist/polyfill.js&#x27;</span>, <span class="string">&#x27;utf-8&#x27;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">  res.send(nunjucks.render(<span class="string">`<span class="subst">$&#123;req.params.view&#125;</span>.njk`</span>, data));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>nunjucks</code>是一个模板引擎。data数据会插入到模板引擎内。当访问<code>/test/lcp</code>时，会将解析<code>lcp.njk</code>并将html返回给浏览器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- src/test/view/lcp.njk --&gt;</span></span><br><span class="line">&#123;% extends &#x27;layout.njk&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% block content %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>LCP Test<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    &#123;% if not imgDelay %&#125;</span><br><span class="line">      &#123;% set imgDelay = 500 %&#125;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> &#123;% <span class="attr">if</span> <span class="attr">imgHidden</span> %&#125;<span class="attr">hidden</span>&#123;% <span class="attr">endif</span> %&#125; <span class="attr">src</span>=<span class="string">&quot;/test/img/square.png?delay=&#123;&#123; imgDelay &#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Text below the image<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;navigate-away&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://example.com&quot;</span>&gt;</span>Navigate away<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- Include a tall element to ensure scrolling is possible. --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 100vh&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">footer</span>&gt;</span>Text below the full-height element.<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> &#123;getLCP&#125; <span class="keyword">from</span> <span class="string">&#x27;&#123;&#123; modulePath &#125;&#125;&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    getLCP(<span class="function">(<span class="params">lcp</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// Log for easier manual testing.</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(lcp);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// Elements can&#x27;t be serialized, so we convert first.</span></span></span><br><span class="line">      lcp = &#123;</span><br><span class="line">        ...lcp,</span><br><span class="line"><span class="javascript">        entries: lcp.entries.map(<span class="function">(<span class="params">e</span>) =&gt;</span> (&#123;</span></span><br><span class="line">          element: e.element.nodeName.toLowerCase(),</span><br><span class="line">          size: e.size,</span><br><span class="line">          startTime: e.startTime,</span><br><span class="line">        &#125;)),</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 发送统计数据</span></span></span><br><span class="line"><span class="javascript">      navigator.sendBeacon(<span class="string">`/collect`</span>, <span class="built_in">JSON</span>.stringify(lcp));</span></span><br><span class="line">    &#125;, self.__reportAllChanges);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&#123;% endblock %&#125;</span><br></pre></td></tr></table></figure><p>html中的最后一步调用了<code> navigator.sendBeacon(&quot;/collect&quot;, JSON.stringify(lcp));</code>，<code>/collect</code>这个请求也是发到本地的HTTP服务。服务端会将数据写入到<code>src/test/beacons.log</code>中。</p><h3 id="sendBeacon"><a href="#sendBeacon" class="headerlink" title="sendBeacon"></a>sendBeacon</h3><p><code>navigator.sendBeacon</code>是专门用来发送异步统计数据的API。</p><p>有一种需求：当页面跳转或关闭时，我们需要将当前页面的一些统计数据发送到服务端。往往这些数据不能提前发送。如果使用异步<code>XMLHttpRequest</code>的话，浏览器可能会忽略这个请求。如果使用同步<code>XMLHttpRequest</code>的话，会影响下个页面的加载速度。</p><p>使用<code>navigator.sendBeacon</code>，会发送一个异步请求，并且不会被浏览器忽略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;visibilitychange&#x27;</span>, <span class="function"><span class="keyword">function</span> <span class="title">logData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">document</span>.visibilityState === <span class="string">&#x27;hidden&#x27;</span>) &#123;</span><br><span class="line">    navigator.sendBeacon(<span class="string">&#x27;/log&#x27;</span>, analyticsData);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>判断页面关闭与否，建议使用<code>visibilitychange</code>事件</p><p>safari需要使用<code>pagehide</code>事件</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="PerformanceObserver"><a href="#PerformanceObserver" class="headerlink" title="PerformanceObserver"></a>PerformanceObserver</h3><p>性能观察者(PerformanceObserver)用于获取性能数据。</p><p><code>new PerformanceObserver(callback);</code> 接受一个callback作为参数</p><p><code>observer</code>方法用于注册性能条目类型，type指所要观测的性能条目类型，取值情况通过<code>PerformanceObserver.supportedEntryTypes</code>属性查看。</p><p><code>[&quot;element&quot;, &quot;event&quot;, &quot;first-input&quot;, &quot;largest-contentful-paint&quot;, &quot;layout-shift&quot;, &quot;longtask&quot;, &quot;mark&quot;, &quot;measure&quot;, &quot;navigation&quot;, &quot;paint&quot;, &quot;resource&quot;]</code></p><p>其中:</p><ul><li><code>largest-contentful-paint</code>：LCP</li><li><code>layout-shift</code>：CLS</li><li><code>first-input</code>：FID</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取lcp时间</span></span><br><span class="line"><span class="keyword">const</span> callback = <span class="function">(<span class="params">entryList</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> entry <span class="keyword">of</span> entryList.getEntries()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;LCP candidate:&#x27;</span>, entry.startTime, entry);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> observer = <span class="keyword">new</span> PerformanceObserver(callback)</span><br><span class="line"></span><br><span class="line">observer.observe(&#123;<span class="attr">type</span>: <span class="string">&#x27;largest-contentful-paint&#x27;</span>, <span class="attr">buffered</span>: <span class="literal">true</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="LCP、FID、CLS"><a href="#LCP、FID、CLS" class="headerlink" title="LCP、FID、CLS"></a>LCP、FID、CLS</h3><p><code>web-vitals</code>中的<code>LCP</code>、<code>FID</code>和<code>CLS</code>都是通过<code>PerformanceObserver</code>来实现的。</p><p>以LCP为例：</p><p><code>getLCP</code>函数位于<code>src/getLCP.ts</code>文件中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getLCP = <span class="function">(<span class="params">onReport: ReportHandler, reportAllChanges?: <span class="built_in">boolean</span></span>) =&gt;</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1 获取 第一次页面处于hidden状态的时间</span></span><br><span class="line">  <span class="keyword">const</span> firstHidden = getFirstHidden();</span><br><span class="line">  <span class="keyword">let</span> metric = initMetric(<span class="string">&#x27;LCP&#x27;</span>);</span><br><span class="line">  <span class="keyword">let</span> report: ReturnType&lt;<span class="keyword">typeof</span> bindReporter&gt;;</span><br><span class="line"></span><br><span class="line">                         </span><br><span class="line">  <span class="comment">// 2. PerformanceObserver</span></span><br><span class="line">  <span class="keyword">const</span> entryHandler = <span class="function">(<span class="params">entry: PerformanceEntry</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = entry.startTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤掉切换pagehide后的 性能数据</span></span><br><span class="line">    <span class="keyword">if</span> (value &lt; firstHidden.timeStamp) &#123;</span><br><span class="line">      metric.value = value;</span><br><span class="line">      metric.entries.push(entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    report();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> po = observe(<span class="string">&#x27;largest-contentful-paint&#x27;</span>, entryHandler);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (po) &#123;</span><br><span class="line">    report = bindReporter(onReport, metric, reportAllChanges);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> stopListening = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!finalMetrics.has(metric)) &#123;</span><br><span class="line">        po.takeRecords().map(entryHandler <span class="keyword">as</span> PerformanceEntryHandler);</span><br><span class="line">        po.disconnect();</span><br><span class="line">        finalMetrics.add(metric);</span><br><span class="line">        report();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当用户点击页面时，立即触发 report</span></span><br><span class="line">    [<span class="string">&#x27;keydown&#x27;</span>, <span class="string">&#x27;click&#x27;</span>].forEach(<span class="function">(<span class="params"><span class="keyword">type</span></span>) =&gt;</span> &#123;</span><br><span class="line">      addEventListener(<span class="keyword">type</span>, stopListening, &#123;<span class="attr">once</span>: <span class="literal">true</span>, <span class="attr">capture</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    onHidden(stopListening, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当pageshow时，报告metric</span></span><br><span class="line">    onBFCacheRestore(<span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      metric = initMetric(<span class="string">&#x27;LCP&#x27;</span>);</span><br><span class="line">      report = bindReporter(onReport, metric, reportAllChanges);</span><br><span class="line">      requestAnimationFrame(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        requestAnimationFrame(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          metric.value = performance.now() - event.timeStamp;</span><br><span class="line">          finalMetrics.add(metric);</span><br><span class="line">          report();</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="TTFB"><a href="#TTFB" class="headerlink" title="TTFB"></a>TTFB</h3><p>TTFB时间直接取<code>performance.responseStart</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;web-vitals简介&quot;&gt;&lt;a href=&quot;#web-vitals简介&quot; class=&quot;headerlink&quot; title=&quot;web-vitals简介&quot;&gt;&lt;/a&gt;web-vitals简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com</summary>
      
    
    
    
    <category term="源码" scheme="https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="web-vitals" scheme="https://zxffan.github.io/tags/web-vitals/"/>
    
  </entry>
  
  <entry>
    <title>知识串联：JavaScript执行机制</title>
    <link href="https://zxffan.github.io/posts/1b8392cc.html"/>
    <id>https://zxffan.github.io/posts/1b8392cc.html</id>
    <published>2021-04-22T16:00:00.000Z</published>
    <updated>2021-06-29T14:05:26.769Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章将梳理JavaScript的执行机制，并且串联众多知识点：作用域、作用域链、闭包、变量提升、函数提升、<code>this</code>指向</p><h2 id="JavaScript-执行的阶段"><a href="#JavaScript-执行的阶段" class="headerlink" title="JavaScript 执行的阶段"></a>JavaScript 执行的阶段</h2><p>在 V8 引擎中 JavaScript 代码的运行过程主要分成三个阶段。</p><ul><li><p>语法分析阶段。 该阶段会对代码进行语法分析，检查是否有语法错误（SyntaxError），如果发现语法错误，会在控制台抛出异常并终止执行。</p></li><li><p>编译阶段。 该阶段会进行全局执行上下文（Execution Context）的创建，这个过程也被称为预解析阶段。</p></li><li><p>执行阶段。 将编译阶段中创建的执行上下文压入执行栈，并成为正在运行的执行上下文，代码执行结束后，将其出栈。在执行过程中，又可能会产生新的执行上下文（比如调用了函数）。再将新的执行上下文入栈，执行完出栈</p></li></ul><h2 id="三种执行上下文"><a href="#三种执行上下文" class="headerlink" title="三种执行上下文"></a>三种执行上下文</h2><p>执行上下文是对执行环境的抽象，它代表JavaScript执行时当前的执行环境，用于。JavaScript中一共有三种执行上下文</p><ul><li>全局执行上下文：有且仅有一个</li><li>函数执行上下文</li><li><code>eval</code>执行上下文：不讨论</li></ul><p>如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;zxfan&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayName()</span><br></pre></td></tr></table></figure><p>编译时，首先创建一个全局执行上下文<code>GlobalContext</code>，并将其放入执行栈</p><p>执行时，执行栈栈顶的执行上下文为当前正在执行的执行上下文，当执行到<code>sayName</code>函数时，又会创建一个函数执行上下文<code>FunctionContext</code>，并将其入栈。当函数执行上下文执行完毕，出栈。全局上下文也执行完毕，出栈。</p><blockquote><p>全局执行上下文是编译时被创建的</p><p>函数执行上下文是执行时被创建的</p></blockquote><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>执行栈是用来存放执行上下文的。</p><p>以函数为例，函数执行的时候创建函数执行上下文，并将其入栈，当函数执行完成后再出栈。全局执行上下文第一个入栈最后一个出栈。</p><h2 id="执行上下文做了什么？"><a href="#执行上下文做了什么？" class="headerlink" title="执行上下文做了什么？"></a>执行上下文做了什么？</h2><p>执行上下文被创建时，做了三件事：</p><ul><li>确定<code>this</code>的指向</li><li>创建环境记录<ul><li>创建词法环境(LexicalEnvironment)</li><li>创建变量环境(VariableEnvironment)</li></ul></li></ul><h3 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h3><p>this的取值取决于具体的场景：</p><ul><li>全局执行上下文中：this取全局对象（浏览器是window对象，nodejs是global对象）</li><li>函数执行上下文中：<ul><li>构造函数中：指向创建的实例对象</li><li>对象方法：this指向这个对象</li><li>箭头函数：外层执行上下文的this</li><li><code>call</code> <code>apply</code> <code>bind</code>：可以指定this</li><li>其它情况：this为undefined（严格模式下）</li></ul></li></ul><h3 id="环境记录-Environment-Record"><a href="#环境记录-Environment-Record" class="headerlink" title="环境记录(Environment Record)"></a>环境记录(Environment Record)</h3><p>基于JavaScript这种嵌套的代码结构，环境记录用来记录特定的<strong>标识符</strong>和代码中所定义的<strong>变量和函数</strong>之间的关系。</p><p>换句话说，环境记录就是记录一堆标识符，这些标识符指向具体代码中的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;zxfan&quot;</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">sayName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  console.log(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其环境记录</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Environment Record &#123;</span><br><span class="line">name: &lt;uninitialized&gt; // 代码执行完后 name: &lt;&quot;zxfan&quot;&gt;</span><br><span class="line">  age: &lt;18&gt; // var 具有变量提升，所以这里不是uninitialized</span><br><span class="line">sayName: &lt;function&gt; // function有函数提升，所以这里不是uninitialized</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>环境记录分类三种类型（声明环境记录又分为两种）：</p><ul><li>声明环境记录： 包含<code>var</code> <code>let</code> <code>const</code> <code>class</code> <code>function</code>  <code>import</code>声明的变量的标识符。<ul><li>函数环境记录： <code>function</code></li><li>模块环境记录：<code>import</code></li></ul></li><li>对象环境记录：为对象创建一个环境记录，它有一个**关联的绑定对象[[BindingObject]]**。比如全局执行上下文会创建一个对象环境记录，其关联绑定的对象是全局对象（window或global）</li><li>全局环境记录：最外层环境记录，包含声明环境记录和对象环境记录</li></ul><p><strong>词法环境和变量环境本质上都是环境记录</strong>，这么做是为了单独区分<code>var</code></p><h4 id="词法环境（作用域）"><a href="#词法环境（作用域）" class="headerlink" title="词法环境（作用域）"></a>词法环境（作用域）</h4><p>词法环境可以理解为<strong>作用域</strong>，从词法环境的角度能更好地理解作用域。词法环境有两个成员：</p><ul><li>环境记录（Environment Record）：用于记录自身词法环境中的变量对象。</li><li>外部词法环境引用（Outer Lexical Environment）：记录外层词法环境的引用。</li></ul><h5 id="环境记录"><a href="#环境记录" class="headerlink" title="环境记录"></a>环境记录</h5><p>词法环境的环境记录，会保存<strong>函数声明</strong>和<strong>变量声明</strong>(<code>let</code>和<code>const</code>声明的变量)，如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayFullName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> firstName = <span class="string">&quot;Donald&quot;</span></span><br><span class="line">  <span class="keyword">const</span> lastName = <span class="string">&quot;Trump&quot;</span></span><br><span class="line">  <span class="built_in">console</span>.log(firstName, lastName)</span><br><span class="line">&#125;</span><br><span class="line">sayFullName()</span><br></pre></td></tr></table></figure><p><code>sayFullNmae</code>的词法环境</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LexicalEnciroment &#123;</span><br><span class="line">Enviroment Record &#123;</span><br><span class="line">firstName: &lt;uninitialize&gt;</span><br><span class="line">lastName: &lt;uninitialize&gt;</span><br><span class="line">arguments: &lt;&#123;&#125;&gt;</span><br><span class="line">&#125;</span><br><span class="line">outer: &lt;Global or outer function environment reference&gt;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：<code>let</code>和<code>const</code>定义的变量初始都是<code>uninitialize</code>。当代码执行后才会赋值。</p><h5 id="外部词法环境引用（作用域链）"><a href="#外部词法环境引用（作用域链）" class="headerlink" title="外部词法环境引用（作用域链）"></a>外部词法环境引用（作用域链）</h5><p>任何一个词法环境（全局词法环境除外）都有一个指向外层词法环境的引用。这构成了词法环境链即<strong>作用域链</strong>。当访问一个变量时，先会在当前词法环境中寻找，找不到就去外部词法环境中寻找。就这样，一直找到全局词法环境。</p><h4 id="变量环境"><a href="#变量环境" class="headerlink" title="变量环境"></a>变量环境</h4><p>变量环境和词法环境的结构一致，区别是其环境记录所记录的数据不同。</p><p>语法环境的环境记录，是记录<code>var</code>声明。</p><blockquote><p>环境记录 词法环境 作用域 其实都是一个概念，这么区分是为了针对不同场景方便理解。</p></blockquote><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="解释作用域与作用域链"><a href="#解释作用域与作用域链" class="headerlink" title="解释作用域与作用域链"></a>解释作用域与作用域链</h3><p>JS的作用域时词法作用域，有词法结构决定。js代码编译时创建全局执行上下文，执行上下文又会创建当前环境的环境记录（分为词法环境和变量环境）。当执行js代码时（比如调用一个函数），又会创建函数执行上下文。随之函数环境的环境就又会创建。</p><p>每个环境记录都有个outer引用，指向外层环境记录。外层再指向外层，一直到最外层。这便构成了作用域链。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>解释闭包就是解释<strong>作用域</strong>和<strong>垃圾回收机制</strong></p><p><a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)">闭包</a> 是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。</p><p>正常情况下，代码执行完毕，其相应的执行上下文出栈，相应的内存空间会被回收。然而，闭包情况下，内层词法环境（作用域）可以访问到，所以外层词法环境不会被回收，仍然可以访问到，但仅限在内层词法环境访问。</p><h3 id="变量提升和函数提升"><a href="#变量提升和函数提升" class="headerlink" title="变量提升和函数提升"></a>变量提升和函数提升</h3><p>环境记录创建时，会记录当前环境下所有变量，遇到：</p><ul><li><p>var变量声明：此时会给变量分配内存，并将其初始化为undefined（该过程只进行定义声明，执行阶段才执行赋值语句）。</p></li><li><p>函数声明：此时会在内存里创建函数对象，并且直接初始化为该函数对象。</p></li></ul><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>this指向是在执行上下文创建时才确定的，具体指向谁取决于具体场景。上文已讨论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这篇文章将梳理JavaScript的执行机制，并且串联众多知识点：作用域、作用域链、闭包、变量提升、函数提升、&lt;code&gt;this&lt;/code&gt;指向&lt;/p&gt;
&lt;h2 id=&quot;JavaScript-执行的阶段&quot;&gt;&lt;a href=&quot;#JavaScript-执行的阶段&quot; clas</summary>
      
    
    
    
    <category term="JavaScript" scheme="https://zxffan.github.io/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://zxffan.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>XSS攻击与防御</title>
    <link href="https://zxffan.github.io/posts/df6ed6ff.html"/>
    <id>https://zxffan.github.io/posts/df6ed6ff.html</id>
    <published>2021-04-15T16:00:00.000Z</published>
    <updated>2021-06-29T14:02:58.235Z</updated>
    
    <content type="html"><![CDATA[<p><code>xss(cross-site script)</code>指<strong>网站对用户输入数据未做有效过滤，攻击者可以将恶意脚本注入网站页面中，达到执行恶意代码的目的</strong></p><p>攻击者只需要诱使受害者打开特定的网址，就可以在受害者的浏览器中执行被注入的恶意代码，从而窃取用户身份，执行一些敏感操作</p><h2 id="XSS攻击类型"><a href="#XSS攻击类型" class="headerlink" title="XSS攻击类型"></a>XSS攻击类型</h2><p>XSS攻击可以分成三种类型：</p><ul><li><p>反射型XSS</p></li><li><p>存储型XSS</p></li><li><p>DOM型XSS</p></li></ul><h3 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h3><p>反射型指的是<strong>将攻击代码存放在URL参数中</strong>，例如<code>http://localhost/home?name=&lt;script&gt;alert(1)&lt;/script&gt;</code>。</p><p>如果服务端直接去url中的name参数，并当作html返回给客户端。攻击代码就会执行。</p><h3 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h3><p>存储型是指<strong>将恶意代码存储到服务器上</strong>，只要诱使受害者访问被插入恶意代码的页面即可触发。存储型 XSS 经常出现在一些可以发表评论的地方，如帖子、博客</p><p>当用户在评论中输入一段攻击代码，网站又没有过滤。这段代码会存储到数据库中。当其它用户访问评论时，这段攻击代码被当作html内容输出就会引发攻击代码的执行</p><h3 id="DOM型"><a href="#DOM型" class="headerlink" title="DOM型"></a>DOM型</h3><p><strong>前两种都是服务端的XSS，DOM型是客户端的XSS</strong></p><p>JavaScript 能够操作DOM。通过JavaScript控制获取<strong>源数据（内含攻击代码）</strong>，又未进行处理。直接<strong>当作HTML输出（innerHTML）或脚本执行</strong></p><p>就会发生DOM型XSS攻击</p><p>常见的源数据有：<code>document</code> <code>location</code> <code>localStorage</code> <code>sessionStorage</code>等</p><p>常见的触发攻击的点：<code>document.write</code> <code>eval</code> <code>innerHTML</code> <code>a的href属性</code>等</p><h2 id="XSS常见的攻击方式"><a href="#XSS常见的攻击方式" class="headerlink" title="XSS常见的攻击方式"></a>XSS常见的攻击方式</h2><h3 id="窃取cookie"><a href="#窃取cookie" class="headerlink" title="窃取cookie"></a>窃取cookie</h3><p>许多网站都使用<code>cookie</code>来存放用户登陆信息。</p><p>攻击者利用<code>xss</code>漏洞来注入脚本。<code>document.cookie</code>就可以获取到cookie。然后再将获取到的cookie上报。之后就可以本地修改 Cookie 来登录受害者的账号</p><h3 id="蠕虫攻击"><a href="#蠕虫攻击" class="headerlink" title="蠕虫攻击"></a>蠕虫攻击</h3><p>以微博XSS蠕虫攻击为例：</p><ul><li><p>利用 XSS 漏洞插入恶意 JS 代码；</p></li><li><p>利用 XMLHttpRequest 发送请求去发表微博、关注用户、获取关注者列表并向其发送私信；</p></li><li><p>微博消息和私信都包含有恶意攻击链接，等于实现了攻击代码的自我复制和传播。</p></li></ul><h3 id="获取用户键盘记录"><a href="#获取用户键盘记录" class="headerlink" title="获取用户键盘记录"></a>获取用户键盘记录</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keys = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">document</span>.onkeypress = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  keys += <span class="built_in">String</span>.fromCharCode(<span class="built_in">window</span>.event.keyCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取剪贴板内容"><a href="#获取剪贴板内容" class="headerlink" title="获取剪贴板内容"></a>获取剪贴板内容</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;paste&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">evt</span>) </span>&#123;</span><br><span class="line">  clipdata = evt.clipboardData || <span class="built_in">window</span>.clipboardData;</span><br><span class="line">  <span class="built_in">console</span>.log(clipdata.getData(<span class="string">&#x27;text/plain&#x27;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="钓鱼欺骗用户输入账号、密码"><a href="#钓鱼欺骗用户输入账号、密码" class="headerlink" title="钓鱼欺骗用户输入账号、密码"></a>钓鱼欺骗用户输入账号、密码</h3><p>弹个弹窗，让用户输入账号密码</p><h2 id="XSS漏洞挖掘"><a href="#XSS漏洞挖掘" class="headerlink" title="XSS漏洞挖掘"></a>XSS漏洞挖掘</h2><h4 id="收集用例"><a href="#收集用例" class="headerlink" title="收集用例"></a>收集用例</h4><p>人工测试的主要思路就是在一切可输入数据的地方输入“XSS payload”（测试用例），这些地方包括所有的 GET、POST、Cookie、HTTP 头。提交数据之后，看网站的输出是否解析了前面输入的 XSS payload。</p><p>我常用的 XSS payload 有以下几个。搜索“XSS cheat sheet”，也可以找到很多这种测试用例。</p><p><a href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet">Cross-site scripting (XSS) cheat sheet</a></p><p><a href="https://owasp.org/www-community/xss-filter-evasion-cheatsheet">XSS Filter Evasion Cheat Sheet</a></p><p><a href="http://html5sec.org/">HTML5 Security Cheatsheet</a></p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>这一步可以手动测试也可以采用自动测试工具。</p><p>手动：可以先一次性批量输入测试，如果无效，再输入一些特殊字符看过滤情况，根据返回数据作相应的调整测试。</p><p>自动：<a href="https://github.com/s0md3v/XSStrike">XSStrike</a>，它内置了很多测试用例，也可以添加自定义测试用例</p><h2 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h2><h3 id="做好检查"><a href="#做好检查" class="headerlink" title="做好检查"></a>做好检查</h3><h4 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h4><p>检查攻击者所有可能的输入的地方</p><ul><li><code>URL</code>参数</li><li>（富）文本框</li><li>接口返回的数据</li></ul><blockquote><p>服务端也需要进行检查，前端是可以绕过去的</p></blockquote><h4 id="输出检查"><a href="#输出检查" class="headerlink" title="输出检查"></a>输出检查</h4><p>从前端角度来看，有两个地方可能导致恶意代码执行——<code>HTML</code>和<code>JavaScript</code></p><ul><li><p>HTML：<code>innerHTML</code> <code>outerHTML</code> <code>document.write()</code> <code>v-html</code> <code>danderousSetInnerHTML</code></p><p>将原数据当作HTML输出，极容易导致XSS攻击。尽量避免这么做，使用<code>textContent</code>来代替。如果必须输出（如评论内容），需要进行<strong>转义</strong>。通常使用<strong>白名单</strong>的方式进行转义。</p><blockquote><p><a href="https://www.npmjs.com/package/xss">xss</a>是npm上的一个不错的HTML转义库</p></blockquote></li><li><p>JavaScript：</p><ul><li>内联事件监听器：<code>location</code> <code>onclick</code> <code>onerror</code> <code>onload</code> <code>onmousemove</code>等等等</li><li>a标签的href属性使用伪协议：<code>&lt;a href=&quot;javascript:alert(&#39;attack&#39;)&quot; /&gt;</code></li><li><code>eval</code> <code>setTimeout</code> <code>setInterval</code>都能够把字符串当作js执行</li></ul><p>这些api的不恰当使用会导致XSS攻击，所以使用时要格外注意。好在它们大多都有可替代方案。</p></li></ul><h3 id="HttpOnly禁止cookie访问"><a href="#HttpOnly禁止cookie访问" class="headerlink" title="HttpOnly禁止cookie访问"></a>HttpOnly禁止cookie访问</h3><p>如果给某个 cookie 设置了 <code>HttpOnly</code> 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: Name=Value; expires=Wednesday, 01-May-2014 12:45:10 GMT; HttpOnly</span><br></pre></td></tr></table></figure><blockquote><p>cookie由服务端创建返回给浏览器的（响应头：<code>Set-Cookie</code>）。之后的请求会自动携带cookie。默认情况下，它随着seesion的结束而结束。</p><p>能不使用cookie就别使用了</p></blockquote><h3 id="CSP-内容安全策略"><a href="#CSP-内容安全策略" class="headerlink" title="CSP 内容安全策略"></a>CSP 内容安全策略</h3><p>内容安全策略（Content Security Policy，CSP）也是减少 XSS 攻击的一种方式 ，是浏览器提供一种防御机制。它采用的是白名单机制，告诉浏览器可以加载和执行哪些外部资源，这样就能防止被一些第三方恶意脚本注入执行。</p><p>开启 CSP 有两种方式：</p><ol><li><p>通过 HTTP 头信息的 Content-Security-Policy 的字段：(在返回html文件的请求的响应头上加)</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: script-src &#x27;self&#x27;; object-src &#x27;none&#x27;;style-src cdn.example.org third-party.org; child-src https:（2）通过网页的&lt;meta&gt;标签设置：</span><br></pre></td></tr></table></figure></li><li><p>通过网页的<code>&lt;meta&gt;</code>标签设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta</span><br><span class="line">  http-equiv=&quot;Content-Security-Policy&quot;</span><br><span class="line">  content=&quot;script-src &#x27;self&#x27;; object-src &#x27;none&#x27;; style-src cdn.example.org third-party.org; child-src https:&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li></ol><p>如何指定csp：<strong>指令 策略</strong></p><p>指令字段含义：</p><table><thead><tr><th>指令</th><th>策略示例</th><th>含义</th></tr></thead><tbody><tr><td><code>default-src</code></td><td><code>&#39;self&#39; www.aaa.com</code></td><td>默认资源加载策略，没有指定策略的指令使用本策略</td></tr><tr><td><code>script-src</code></td><td><code>&#39;selft&#39; js.a.com</code></td><td>针对js文件的策略</td></tr><tr><td><code>style-src</code></td><td><code>&#39;selft&#39; css.a.com</code></td><td>针对css文件的策略</td></tr><tr><td><code>img-src</code></td><td><code>&#39;selft&#39; img.a.com</code></td><td>针对img图片资源的策略</td></tr><tr><td><code>connect-src</code></td><td><code>&#39;selft&#39;</code></td><td>针对ajax、websocket的策略，不允许会返回400</td></tr><tr><td><code>font-src</code></td><td><code>font.a.com</code></td><td>针对字体的加载策略</td></tr><tr><td><code>media-src</code></td><td><code>media.a.com</code></td><td>针对video和audio引入资源的策略</td></tr><tr><td><code>frame-src</code></td><td><code>&#39;self&#39;</code></td><td>针对frame的加载策略</td></tr><tr><td><code>sandbox</code></td><td><code>allow-forms</code></td><td>对请求资源启用<code>sandbox</code></td></tr><tr><td><code>report-uri</code></td><td><code>/report-uri</code></td><td>告知浏览器，当请求资源不被策略允许时，往那个接口提交信息</td></tr></tbody></table><p>指令值字段含义：</p><ul><li><code>none</code> 表示不执行任何匹配。</li><li> <code>self</code>表示与当前来源（而不是其子域）匹配。</li><li> <code>unsafe-inline</code>表示允许使用内联 JavaScript 和 CSS。</li><li> <code>unsafe-eval</code> 表示允许使用类似 eval 的 text-to-JavaScript 机制。</li><li><code>www.aasd.com</code>允许加载指定域名的资源</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;xss(cross-site script)&lt;/code&gt;指&lt;strong&gt;网站对用户输入数据未做有效过滤，攻击者可以将恶意脚本注入网站页面中，达到执行恶意代码的目的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;攻击者只需要诱使受害者打开特定的网址，就可以在受害者的浏览器中</summary>
      
    
    
    
    <category term="experience" scheme="https://zxffan.github.io/categories/experience/"/>
    
    
    <category term="FrontEnd" scheme="https://zxffan.github.io/tags/FrontEnd/"/>
    
    <category term="安全" scheme="https://zxffan.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>排序问题梳理</title>
    <link href="https://zxffan.github.io/posts/88f2a5b3.html"/>
    <id>https://zxffan.github.io/posts/88f2a5b3.html</id>
    <published>2021-04-14T16:00:00.000Z</published>
    <updated>2021-06-29T14:03:47.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="数组的归并排序"><a href="#数组的归并排序" class="headerlink" title="数组的归并排序"></a>数组的归并排序</h3><p><a href="https://leetcode-cn.com/problems/sort-an-array/">912. 排序数组</a></p><p>归并排序类似二叉树的后序遍历，思想也一致：利用子树的信息推算出整棵树的信息</p><p>记忆：</p><ol><li>将list划分成两部分，</li><li>后序遍历</li><li>合并两个有序list</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArray</span>(<span class="params">nums: <span class="built_in">number</span>[], low = <span class="number">0</span>, high = nums.length - <span class="number">1</span></span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="comment">// 后序遍历</span></span><br><span class="line">  <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">    <span class="comment">// 1. 划分</span></span><br><span class="line">    <span class="keyword">const</span> mid = low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.后续遍历</span></span><br><span class="line">    sortArray(nums, low, mid);</span><br><span class="line">    sortArray(nums, mid + <span class="number">1</span>, high);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 合并两个有序list</span></span><br><span class="line">    merge(nums, low, mid, high);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序数组</span></span><br><span class="line"><span class="comment">// 数组A： nums[low ... mid]</span></span><br><span class="line"><span class="comment">// 数组B：nums[mid+1 ... high]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">nums: <span class="built_in">number</span>[], low: <span class="built_in">number</span>, mid: <span class="built_in">number</span>, high: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 两个数组的起始索引</span></span><br><span class="line">  <span class="keyword">let</span> i = low;</span><br><span class="line">  <span class="keyword">let</span> j = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt; nums[j]) store.push(nums[i++]);</span><br><span class="line">    <span class="keyword">else</span> store.push(nums[j++]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt;= mid) store.push(nums[i++]);</span><br><span class="line">  <span class="keyword">while</span> (j &lt;= high) store.push(nums[j++]);</span><br><span class="line"></span><br><span class="line">  store.forEach(<span class="function">(<span class="params">num</span>) =&gt;</span> (nums[low++] = num));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(nlgn)，空间复杂度 O(n)</p><h3 id="链表的归并排序"><a href="#链表的归并排序" class="headerlink" title="链表的归并排序"></a>链表的归并排序</h3><p><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></p><p>思路都一样，同样的三步</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortList</span>(<span class="params">head: ListNode | <span class="literal">null</span></span>): <span class="title">ListNode</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (head === <span class="literal">null</span> || head.next === <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1.划分</span></span><br><span class="line">  <span class="keyword">const</span> [back, front] = divide(head);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.后续遍历</span></span><br><span class="line">  <span class="keyword">const</span> left = sortList(back);</span><br><span class="line">  <span class="keyword">const</span> right = sortList(front);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.合并两个有序链表</span></span><br><span class="line">  dummy.next = merge(left, right);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将链表划分成两部分</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divide</span>(<span class="params">head: ListNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> back = head;</span><br><span class="line">  <span class="keyword">let</span> front = head;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (front.next) &#123;</span><br><span class="line">    front = front.next;</span><br><span class="line">    <span class="keyword">if</span> (front.next === <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">    front = front.next;</span><br><span class="line">    back = back;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> result = [head, back.next!];</span><br><span class="line">  back.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并两个有序列表 l1 l2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">l1: ListNode | <span class="literal">null</span>, l2: ListNode | <span class="literal">null</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dummy = <span class="keyword">new</span> ListNode();</span><br><span class="line">  <span class="keyword">let</span> tail = dummy;</span><br><span class="line">  <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">      tail.next = l1;</span><br><span class="line">      l1 = l1.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      tail.next = l2;</span><br><span class="line">      l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    tail = tail.next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (l1) tail.next = l1;</span><br><span class="line">  <span class="keyword">if</span> (l2) tail.next = l2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组中的逆序对"><a href="#数组中的逆序对" class="headerlink" title="数组中的逆序对"></a>数组中的逆序对</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指 Offer 51. 数组中的逆序对</a></p><p>这道题也是利用归并排序中的<strong>分治思想</strong>。现将数组不断划分，然后合并两个有序数组<code>a[low...mid]</code>和<code>a[mid+1...high]</code>，循环比较<code>a[i]</code>和<code>a[j]</code>的大小</p><ul><li>如果<code>a[j]</code>小，即<code>a[i...mid]</code>所有元素都比<code>a[j]</code>大，也就是说它们构成了逆序对。逆序对的数量加上<code>mid-i+1</code></li><li>如果<code>a[i]</code>小，无需处理</li></ul><h3 id="右侧较小元素个数"><a href="#右侧较小元素个数" class="headerlink" title="右侧较小元素个数"></a>右侧较小元素个数</h3><p><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortArray</span>(<span class="params">nums: <span class="built_in">number</span>[], low = <span class="number">0</span>, high = nums.length - <span class="number">1</span></span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">    <span class="keyword">const</span> index = partition(nums, low, high);</span><br><span class="line">    sortArray(nums, low, index - <span class="number">1</span>);</span><br><span class="line">    sortArray(nums, index + <span class="number">1</span>, high);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 划分操作</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">nums: <span class="built_in">number</span>[], low: <span class="built_in">number</span>, high: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> target = nums[low];</span><br><span class="line">  <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] &gt;= target) high--;</span><br><span class="line">    nums[low] = nums[high];</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] &lt;= target) low++;</span><br><span class="line">    nums[high] = nums[low];</span><br><span class="line">  &#125;</span><br><span class="line">  nums[low] = target;</span><br><span class="line">  <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h2&gt;&lt;h3 id=&quot;数组的归并排序&quot;&gt;&lt;a href=&quot;#数组的归并排序&quot; class=&quot;headerlink&quot; title=&quot;数组的</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://zxffan.github.io/categories/Algorithm/"/>
    
    
    <category term="JavaScript" scheme="https://zxffan.github.io/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="https://zxffan.github.io/tags/TypeScript/"/>
    
    <category term="Algorithm" scheme="https://zxffan.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>队列问题梳理</title>
    <link href="https://zxffan.github.io/posts/631e9859.html"/>
    <id>https://zxffan.github.io/posts/631e9859.html</id>
    <published>2021-04-13T16:00:00.000Z</published>
    <updated>2021-06-29T14:03:36.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BFS-广度优先遍历"><a href="#BFS-广度优先遍历" class="headerlink" title="BFS 广度优先遍历"></a>BFS 广度优先遍历</h2><p>BFS、广度优先、层序遍历都是一回事。需要通过队列来实现</p><h3 id="队列实现BFS"><a href="#队列实现BFS" class="headerlink" title="队列实现BFS"></a>队列实现BFS</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     left: TreeNode | null</span></span><br><span class="line"><span class="comment"> *     right: TreeNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *         this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">levelOrder</span>(<span class="params">root: TreeNode | <span class="literal">null</span></span>): <span class="title">number</span>[][] </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> queue: TreeNode[] = [root]</span><br><span class="line">  <span class="keyword">const</span> ans = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (root === <span class="literal">null</span>) <span class="keyword">return</span> ans</span><br><span class="line">  <span class="keyword">while</span> (queue.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = queue.shift()</span><br><span class="line">    ans.push(node.val)</span><br><span class="line">    <span class="keyword">if</span> (node.left) queue.push(node.left)</span><br><span class="line">    <span class="keyword">if</span> (node.right) queue.push(node.right)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="按层次输出层序遍历"><a href="#按层次输出层序遍历" class="headerlink" title="按层次输出层序遍历"></a>按层次输出层序遍历</h3><p>在层序遍历的过程中还要记住当前处在拿一层</p><ul><li>用一个last指针指向每一层最后一个节点</li><li>或者，前序遍历。逐个给每一层添加元素。前序遍历是先遍历第一个第一个元素，然后第二层第一个元素….</li></ul><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p><p>往往，考题不会只靠队列这一个点。层序遍历只是解决问题的一个手段</p><h3 id="填充右侧节点"><a href="#填充右侧节点" class="headerlink" title="填充右侧节点"></a>填充右侧节点</h3><p><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></p><p>考点：层序遍历+last指针记住层次</p><p>层次遍历到当前节点时：</p><ul><li>当前节点是last：不修改next指针</li><li>不是last：将当前节点的next指向队列中第一个元素</li></ul><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><a href="https://leetcode-cn.com/problems/design-circular-queue/">622. 设计循环队列</a></p><p>循环队列有两种实现方式</p><h4 id="fornt-rear-used"><a href="#fornt-rear-used" class="headerlink" title="fornt+rear+used"></a>fornt+rear+used</h4><p><img src="../../images/algorithm/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%971.png" alt="循环队列"></p><p>front和rear分别指向队头和队尾，used记录队列的元素个数，当：</p><ul><li>队列为空：front = rear且used=0</li><li>队列满了：front=rear且used=队列长度</li><li>其它情况：front != rear，used=队列元素个数</li></ul><h4 id="浪费一个空间"><a href="#浪费一个空间" class="headerlink" title="浪费一个空间"></a>浪费一个空间</h4><p><img src="../../images/algorithm/%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%972.png" alt="循环队列2"></p><p>front和rear分别指向队头和队尾，当：</p><ul><li>队列为空：front = rear</li><li>队列满了：(rear + 1) % capacity == front</li><li>其它情况：front != rear</li></ul><h3 id="🌟在js中实现循环队列"><a href="#🌟在js中实现循环队列" class="headerlink" title="🌟在js中实现循环队列"></a>🌟在js中实现循环队列</h3><p>无需指针，直接调用数组对象的<code>push</code>和<code>shift</code>方法模拟队列。</p><p>循环队列的出现是因为其它语言的数组是定长的，在声明时就要指定长度，所以需要充分利用空间。而JavaScript中的数组，无需声明是指定长度。所以并不需要循环队列这种数据结构。</p><p>理论上<code>shift</code>删除队列首元素，会导致后面所有元素向前移动一位。但是在<code>v8</code>的优化下，这种方式比<code>front</code>+<code>rear</code>两个指针要快</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCircularQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> size: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">private</span> queue: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">k: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.size = k;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  enQueue(value: <span class="built_in">number</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isFull()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.queue.push(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  deQueue(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.queue.shift();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Front(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Rear(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue[<span class="built_in">this</span>.queue.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isEmpty(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue.length === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isFull(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.queue.length === <span class="built_in">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>单调队列：</p><ul><li>基于双端队列：两端都可以入队和出队</li><li>队列元素满足<strong>单调递增</strong>或者<strong>单调递减</strong></li></ul><h3 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h3><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BFS-广度优先遍历&quot;&gt;&lt;a href=&quot;#BFS-广度优先遍历&quot; class=&quot;headerlink&quot; title=&quot;BFS 广度优先遍历&quot;&gt;&lt;/a&gt;BFS 广度优先遍历&lt;/h2&gt;&lt;p&gt;BFS、广度优先、层序遍历都是一回事。需要通过队列来实现&lt;/p&gt;
&lt;h3 i</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://zxffan.github.io/categories/Algorithm/"/>
    
    
    <category term="JavaScript" scheme="https://zxffan.github.io/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="https://zxffan.github.io/tags/TypeScript/"/>
    
    <category term="Algorithm" scheme="https://zxffan.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>vue3-任务调度</title>
    <link href="https://zxffan.github.io/posts/d2a05aba.html"/>
    <id>https://zxffan.github.io/posts/d2a05aba.html</id>
    <published>2021-04-03T16:00:00.000Z</published>
    <updated>2021-06-29T14:07:25.641Z</updated>
    
    <content type="html"><![CDATA[<p>在vue3中，修改一个响应式对象，像是这样：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;my-name&quot;</span>&gt;name: &#123;&#123; name &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=<span class="string">&quot;ts&quot;</span> setup&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ref, watchEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = ref(<span class="string">&quot;zxfan&quot;</span>)</span><br><span class="line"></span><br><span class="line">name.value += <span class="string">&#x27; yes!&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>当执行<code>name.value += &#39; yes!&#39;</code>，<code>vue3</code>并不会立即触发当前组件的更新。而是将更新任务放到任务队列中。这一点与vue2一致。</p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>调度相关的源码位于<code>runtime-core/src/schduler.ts</code>中</p><p>在任务调度过程中，任务会被放入三类任务队列中：</p><ul><li><p>preFlushCbs：要在执行queue之前执行的队列</p></li><li><p>queue：任务队列</p></li><li><p>postFlush：要在执行queue之后执行的队列</p></li></ul><p>每一次flush的过程（或者说一个<code>Tick</code>），都是按照<strong>清空preFlushCbs队列-&gt;清空queue队列-&gt;清空postFlush队列</strong>的顺序</p><blockquote><p>flush 指刷新任务队列，或者说 执行完任务队列中所有的任务</p></blockquote><h2 id="入队queue的时机"><a href="#入队queue的时机" class="headerlink" title="入队queue的时机"></a>入队queue的时机</h2><p><code>queue</code>存放的都是组件渲染任务</p><h3 id="组件更新"><a href="#组件更新" class="headerlink" title="组件更新"></a>组件更新</h3><p>先提一下vue中的响应式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;effect, ref&#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/reactivity&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> age = ref(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">effect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age.value) <span class="comment">// 会输出两次，分别是 20 和 21</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">age.value = <span class="number">21</span></span><br></pre></td></tr></table></figure><p><code>effect</code>的回调函数会被响应式得重写触发执行。</p><p>那么回到本文最开始的例子中，当执行<code>name.value += &#39; yes!&#39;</code>。响应式数据变化了，触发（<code>trigger</code>）其关联到的<code>effect</code>重新执行。那么需要重新执行的<code>effect</code>在哪里声明的呢？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtie-core/src/renderer.ts</span></span><br><span class="line"><span class="keyword">const</span> setupRenderEffect: SetupRenderEffectFn = (</span><br><span class="line">  instance,</span><br><span class="line">  initialVNode,</span><br><span class="line">  container,</span><br><span class="line">  anchor,</span><br><span class="line">  parentSuspense,</span><br><span class="line">  isSVG,</span><br><span class="line">  optimized</span><br><span class="line">) =&gt; &#123;</span><br><span class="line">  <span class="comment">// create reactive effect for rendering</span></span><br><span class="line">  instance.update = effect(<span class="function"><span class="keyword">function</span> <span class="title">componentEffect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 省略。。。创建或更新 VNode</span></span><br><span class="line">  &#125;, __DEV__ ? createDevEffectOptions(instance) : prodEffectOptions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>setupRenderEffect</code>给组件套上了个<code>effect</code>。这个函数是组件实例创建的时候调用的。</p><p>当修改组件内的响应式数据时，会触发该<code>effect</code>重新执行。</p><p>当然不会直接就执行了，注意到了吗，effect还有第二个参数。第二个参数的类型如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> ReactiveEffectOptions &#123;</span><br><span class="line">  lazy?: <span class="built_in">boolean</span> <span class="comment">// 该effect是否</span></span><br><span class="line">  scheduler?: <span class="function">(<span class="params">job: ReactiveEffect</span>) =&gt;</span> <span class="built_in">void</span> <span class="comment">// 调度</span></span><br><span class="line">  onTrack?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  onTrigger?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  onStop?: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  allowRecurse?: <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它先不关注，我们只看<code>scheduler</code>属性。</p><p>如果有这个属性，就不会直接执行<code>effect</code>，而是调用这个<code>scheduler</code>函数，并且将<code>effect</code>作为参数传给它</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  target: <span class="built_in">object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">type</span>: TriggerOpTypes,</span></span></span><br><span class="line"><span class="function"><span class="params">  key?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  newValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldValue?: unknown,</span></span></span><br><span class="line"><span class="function"><span class="params">  oldTarget?: <span class="built_in">Map</span>&lt;unknown, unknown&gt; | <span class="built_in">Set</span>&lt;unknown&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> run = <span class="function">(<span class="params">effect: ReactiveEffect</span>) =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有scheduler 调用 scheduler</span></span><br><span class="line">    <span class="keyword">if</span> (effect.options.scheduler) &#123;</span><br><span class="line">      effect.options.scheduler(effect)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 否则直接执行 effect</span></span><br><span class="line">      effect()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  effects.forEach(run)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在给组件实例套上<code>effect</code>的时候，传给<code>effect</code>的第二个参数是什么呢？</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtie-core/src/renderer.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodEffectOptions = &#123;</span><br><span class="line">  scheduler: queueJob,</span><br><span class="line">  <span class="comment">// #1801, #2043 component render effects should allow recursive updates</span></span><br><span class="line">  allowRecurse: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDevEffectOptions</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  instance: ComponentInternalInstance</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">ReactiveEffectOptions</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    scheduler: queueJob,</span><br><span class="line">    allowRecurse: <span class="literal">true</span>,</span><br><span class="line">    onTrack: instance.rtc ? <span class="function"><span class="params">e</span> =&gt;</span> invokeArrayFns(instance.rtc!, e) : <span class="built_in">void</span> <span class="number">0</span>,</span><br><span class="line">    onTrigger: instance.rtg ? <span class="function"><span class="params">e</span> =&gt;</span> invokeArrayFns(instance.rtg!, e) : <span class="built_in">void</span> <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__DEV__ ? createDevEffectOptions(instance) : prodEffectOptions)</code>根据不同的环境传递的参数有一些差异性。但是我们只关注scheduler，<code>scheduler</code>的值都是<code>queueJob</code>这个函数</p><p><code>queueJob</code>的作用就是将<code>effect</code>放入<code>queue</code>任务队列。</p><p>稍后在讨论<code>queueJob</code>具体都做了些什么，先总结一下组件更新的调度流程</p><ol><li><p>组件实例创建时，套上了effect方法</p></li><li><p>修改响应式数据，触发effect重新执行（先调用trigger函数）</p></li><li><p>effect的第二个参数中有<code>scheduler</code>属性，所以不会直接执行effect方法，而是将调用<code>scheduler</code>方法即<code>queueJob</code></p></li><li><p>将组件更新effect放入<code>queue</code>队列中</p></li></ol><h3 id="调用forceUpdate"><a href="#调用forceUpdate" class="headerlink" title="调用forceUpdate"></a>调用forceUpdate</h3><p>在<code>vue2</code>中可以使用<code>this.$forceUpdate</code>强制组件重新渲染。这一API在vue3 Options API中保留了下来</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime-core/src/componentPublicInstance.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> publicPropertiesMap: PublicPropertiesMap = extend(<span class="built_in">Object</span>.create(<span class="literal">null</span>), &#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">  $forceUpdate: <span class="function"><span class="params">i</span> =&gt;</span> <span class="function">() =&gt;</span> queueJob(i.update),</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125; <span class="keyword">as</span> PublicPropertiesMap)</span><br></pre></td></tr></table></figure><p>可以观察到，<code>forceUpdate</code>就是直接调用<code>queueJob</code>，并将<code>effect</code>(i.update就是effect)传入。</p><h3 id="hmr"><a href="#hmr" class="headerlink" title="hmr"></a>hmr</h3><p>开发环境下，热更新也会触发组件重新渲染。也是调用<code>queueJob</code>将更新任务加入任务队列</p><h2 id="入队preFlushCbs和postFlushCbs的时机"><a href="#入队preFlushCbs和postFlushCbs的时机" class="headerlink" title="入队preFlushCbs和postFlushCbs的时机"></a>入队preFlushCbs和postFlushCbs的时机</h2><p><code>preFlushCbs</code>存放的是组件渲染前需要完成的任务</p><p><code>postFlushCbs</code>存放的是组件渲染完成后要完成的任务</p><h3 id="watchEffect和watch"><a href="#watchEffect和watch" class="headerlink" title="watchEffect和watch"></a>watchEffect和watch</h3><p>以<code>watchEffect</code>为例，看一下它的类型声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  effect: (onInvalidate: InvalidateCbRegistrator) =&gt; <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: WatchEffectOptions</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">StopHandle</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">interface</span> <span class="title">WatchEffectOptions</span> </span>&#123;</span><br><span class="line">  flush?: <span class="string">&#x27;pre&#x27;</span> | <span class="string">&#x27;post&#x27;</span> | <span class="string">&#x27;sync&#x27;</span> <span class="comment">// 默认：&#x27;pre&#x27;</span></span><br><span class="line">  onTrack?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  onTrigger?: <span class="function">(<span class="params">event: DebuggerEvent</span>) =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>watchEffect</code>的第二个参数中有个<code>flush</code>属性，有三种取值</p><ul><li><code>pre</code>（默认）：在组件渲染前异步调用，会将任务放入<code>preFlushCbs</code>队列中</li><li><code>post</code>：在组件渲染后异步调用，会将任务放入<code>postFlushCbs</code>队列中</li><li><code>sync</code>：同步调用</li></ul><p>分析源码，来看一下具体放入队列的操作：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">watchEffect</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  effect: WatchEffect,</span></span></span><br><span class="line"><span class="function"><span class="params">  options?: WatchOptionsBase</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 调用doWatch方法</span></span><br><span class="line">  <span class="keyword">return</span> doWatch(effect, <span class="literal">null</span>, options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doWatch</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  source: WatchSource | WatchSource[] | WatchEffect | <span class="built_in">object</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  cb: WatchCallback | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  &#123; immediate, deep, flush, onTrack, onTrigger &#125;: WatchOptions = EMPTY_OBJ,</span></span></span><br><span class="line"><span class="function"><span class="params">  instance = currentInstance</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">WatchStopHandle</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">const</span> job: SchedulerJob = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 省略</span></span><br><span class="line">    <span class="comment">// 会执行传入的回调 cb</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 赋值scheduler</span></span><br><span class="line">  <span class="keyword">let</span> scheduler: ReactiveEffectOptions[<span class="string">&#x27;scheduler&#x27;</span>]</span><br><span class="line">  <span class="keyword">if</span> (flush === <span class="string">&#x27;sync&#x27;</span>) &#123;</span><br><span class="line">    scheduler = job</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (flush === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">    scheduler = <span class="function">() =&gt;</span> queuePostRenderEffect(job, instance &amp;&amp; instance.suspense)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// default: &#x27;pre&#x27;</span></span><br><span class="line">    scheduler = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!instance || instance.isMounted) &#123;</span><br><span class="line">        queuePreFlushCb(job)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 第一次执行，组件未渲染的话，同步执行</span></span><br><span class="line">        job()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建effect</span></span><br><span class="line">  <span class="keyword">const</span> runner = effect(getter, &#123;</span><br><span class="line">    lazy: <span class="literal">true</span>, <span class="comment">// true的话， effect第一次不会自动执行，而是直接返回effect</span></span><br><span class="line">    onTrack,</span><br><span class="line">    onTrigger,</span><br><span class="line">    scheduler</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下：</p><ol><li><p>响应式都是通过<code>effect</code>来实现的</p></li><li><p>先赋值<code>sheduler</code>，有三种情况</p><ul><li><code>flush: sync</code>：直接赋值<code>job</code>，也就是直接触发effect执行</li><li><code>flush: post</code>：赋值一个函数，函数会执行<code>queuePostRenderEffect</code>，即将<code>job</code>放入<code>postFlushCbs</code>队列</li><li><code>flush: pre</code>：赋值一个函数，函数会执行<code>queuePreRenderEffect</code>，即将<code>job</code>放入<code>preFlushCbs</code>队列</li></ul></li><li><p>创建<code>effect</code>，以实现响应式 并将<code>scheduler</code>传入。当响应式数据发生变化，就会调用<code>scheduler</code>函数</p></li></ol><p>除此之外，在Vnode创建、更新和销毁的过程中，许多环节需要在组件更新完之后再去执行相应操作。vue调用了<code>queuePostFlushCb</code>。</p><h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p>现在来具体看一下这些<strong>任务</strong>进入任务队列中都做了什么：</p><h3 id="queueJob"><a href="#queueJob" class="headerlink" title="queueJob"></a>queueJob</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime-core/src/schduler.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueJob</span>(<span class="params">job: SchedulerJob</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断队列中是否已有该job，没有才会添加到任务队列中</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (!queue.length ||</span><br><span class="line">      !queue.includes(</span><br><span class="line">        job,</span><br><span class="line">        isFlushing &amp;&amp; job.allowRecurse ? flushIndex + <span class="number">1</span> : flushIndex</span><br><span class="line">      )) &amp;&amp;</span><br><span class="line">    job !== currentPreFlushParentJob</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 找的任务在任务队列中合适的位置</span></span><br><span class="line">    <span class="keyword">const</span> pos = findInsertionIndex(job)</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      queue.splice(pos, <span class="number">0</span>, job)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queue.push(job)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清空任务队列</span></span><br><span class="line">    queueFlush()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先进行重复判断。<strong>这是确保任务队列中不会出现多个相同组件的effect，防止组件重复渲染</strong>。</p><p>最终调用<code>queueFlush</code>来执行清空任务队列（执行完所有任务）</p><h3 id="queuePreFlushCb"><a href="#queuePreFlushCb" class="headerlink" title="queuePreFlushCb"></a>queuePreFlushCb</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime-core/src/schduler.ts</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueCb</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  cb: SchedulerCbs,</span></span></span><br><span class="line"><span class="function"><span class="params">  activeQueue: SchedulerCb[] | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  pendingQueue: SchedulerCb[],</span></span></span><br><span class="line"><span class="function"><span class="params">  index: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isArray(cb)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !activeQueue ||</span><br><span class="line">      !activeQueue.includes(</span><br><span class="line">        cb,</span><br><span class="line">        (cb <span class="keyword">as</span> SchedulerJob).allowRecurse ? index + <span class="number">1</span> : index</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      pendingQueue.push(cb)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pendingQueue.push(...cb)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 清空任务队列</span></span><br><span class="line">  queueFlush()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queuePreFlushCb</span>(<span class="params">cb: SchedulerCb</span>) </span>&#123;</span><br><span class="line">  queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queuePostFlushCb</span>(<span class="params">cb: SchedulerCbs</span>) </span>&#123;</span><br><span class="line">  queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>queuePreFlushCb</code>和<code>queuePostFlushCb</code>都会再去调用<code>queueCb</code>函数，这个函数做两件事</p><ol><li>将任务放入响应的任务队列（当然 先判断重复）</li><li>执行<code>queueFlush</code>，来清空任务队列</li></ol><h3 id="queueFlush"><a href="#queueFlush" class="headerlink" title="queueFlush"></a>queueFlush</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime-core/src/schduler.ts</span></span><br><span class="line"><span class="keyword">const</span> resolvedPromise: <span class="built_in">Promise</span>&lt;<span class="built_in">any</span>&gt; = <span class="built_in">Promise</span>.resolve()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueFlush</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isFlushing &amp;&amp; !isFlushPending) &#123;</span><br><span class="line">    isFlushPending = <span class="literal">true</span></span><br><span class="line">    currentFlushPromise = resolvedPromise.then(flushJobs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushJobs</span>(<span class="params">seen?: CountMap</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1. 清空preFlushCb队列</span></span><br><span class="line">  flushPreFlushCbs(seen)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 清空queue队列</span></span><br><span class="line">    <span class="keyword">for</span> (flushIndex = <span class="number">0</span>; flushIndex &lt; queue.length; flushIndex++) &#123;</span><br><span class="line">      <span class="keyword">const</span> job = queue[flushIndex]</span><br><span class="line">      <span class="keyword">if</span> (job) &#123;</span><br><span class="line">        <span class="comment">// 执行job，也就是前面传入的effect</span></span><br><span class="line">        callWithErrorHandling(job, <span class="literal">null</span>, ErrorCodes.SCHEDULER)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 清空postFlushCbs队列</span></span><br><span class="line">    flushPostFlushCbs(seen)</span><br><span class="line"><span class="comment">// 省略...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清空队列主要流程：</p><ol><li>异步执行<code>flushJob</code>，这里使用了<code>resolvedPromise.then(flushJobs)</code>。将清空队列的操作变成了异步。</li><li>清空preFlushCb队列</li><li>清空queue队列</li><li>清空postFlushCbs队列</li></ol><p>这里的“清空”是执行队列中所有任务的意思</p><h2 id="nextTick原理？"><a href="#nextTick原理？" class="headerlink" title="nextTick原理？"></a>nextTick原理？</h2><p>先看一段demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;my-name&quot;&gt;name: &#123;&#123;name&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang&#x3D;&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; nextTick, onMounted, ref &#125; from &#39;vue&#39;</span><br><span class="line"></span><br><span class="line">const name &#x3D; ref(&quot;zxfan&quot;)</span><br><span class="line"></span><br><span class="line">onMounted(() &#x3D;&gt; &#123;</span><br><span class="line">  name.value +&#x3D; &#39; yes!&#39;</span><br><span class="line">  const dom &#x3D; document.querySelector(&quot;.my-name&quot;)</span><br><span class="line">  </span><br><span class="line">  console.log(dom?.innerHTML); &#x2F;&#x2F; 输出：name: zxfan</span><br><span class="line">  nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(dom?.innerHTML); &#x2F;&#x2F; 输出：name: zxfan yes!</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>由于修改响应式数据，不会立即触发组件重渲染，所以第一个<code>console.log</code>输出的内容是上一次渲染的内容。而<code>nexTick</code>注册的回调会等到在渲染完毕后执行。</p><p>我们看一下<code>nextTick</code>是如何实现的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime-core/src/schduler.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="built_in">this</span>: ComponentPublicInstance | <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  fn?: () =&gt; <span class="built_in">void</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Promise</span>&lt;<span class="title">void</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = currentFlushPromise || resolvedPromise</span><br><span class="line">  <span class="keyword">return</span> fn ? p.then(<span class="built_in">this</span> ? fn.bind(<span class="built_in">this</span>) : fn) : p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到，它是等promise执行完毕后在去执行回调函数。那么这个promise是什么呢？</p><ul><li><code>currentFlushPromise</code>：这个promise我们刚刚遇到过，是在<code>queueFlush</code>中赋值的。这个promise会在本轮任务队列全部清空后才会变成<code>fullfilled</code>。这是再去调用nextTick的回调，就能获取到最新的dom</li><li><code>resolvedPromise</code>：说明现在任务队列为空，那就包装一层promise并返回</li></ul><p>要理解nextTick，还需要结合浏览器的<strong>事件循环</strong>来分析，我们先明确几个知识点：</p><ol><li>浏览器的事件循环将事件放到两个队列——<strong>宏任务队列</strong>和**微任务队列</li><li>每一次事件循环，会优先先清空微任务队列</li><li>promise属于微任务</li></ol><p>以下面的demo为例，解释一下从修改响应式数据到<code>nextTick</code>中回调执行的过程</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name.value += <span class="string">&#x27; yes!&#x27;</span></span><br><span class="line">nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(dom?.innerHTML); <span class="comment">// 输出：name: zxfan yes!</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>当执行<code>name.value += &#39; yes!&#39;</code>时，响应式数据发生了改变。<ul><li>触发Proxy的setter，将<strong>更新组件任务的effect</strong>放入vue任务队列中（调用queueJob）</li><li>调用queueFlush，这里调用了<code>promise.resolve</code>，所以将<strong>flushJobs</strong>放入微任务队列</li><li>此时微任务队列= [flushJobs]</li></ul></li><li>接着执行<code>nextTick</code>。等待<code>currentFlushPromise</code>执行完毕</li><li>开始清空微任务队列。先执行flushJobs，执行<strong>更新组件任务的effect</strong>，这个过程会操作DOM，一旦操作DOM。浏览器会进行线程切换。由<strong>JS线程</strong>切换到<strong>渲染线程</strong>，浏览器去更新DOM。当DOM更新完毕，在切换回<strong>JS线程</strong>。回到JS线程后，<code>currentFlushPromise</code>状态变成<code>fullfilled</code>。将nextTick的回调<code>cb</code>放入微任务队列。此时微任务队列= [cb]</li><li>继续清空微任务队列，执行cb。此时如果在cb中访问dom，就是渲染完成后的dom内容。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="../../images/Vue/vue%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6.png" alt="vue任务调度.png"></p><h2 id="Vue2中的表现"><a href="#Vue2中的表现" class="headerlink" title="Vue2中的表现"></a>Vue2中的表现</h2><h3 id="任务调度-1"><a href="#任务调度-1" class="headerlink" title="任务调度"></a>任务调度</h3><p>vu2的任务调度原理也是类似。</p><ol><li>组件的响应式数据发生改变，会触发setter方法。</li><li>触发<code>dep.notify()</code>。</li><li>遍历dep对象上的<code>watcher</code>，逐一调用其<code>update</code>方法，（Watcher对象是在渲染组件时创建的，用来更新组件）</li><li>update再调用<code>queueWatcher</code>，将更新任务加入任务队列</li><li>调用<code>nextTick(flushSchedulerQueue)</code>，用来清空任务队列。<code>nextTick</code>是为了让组件更新变成异步。</li></ol><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p>vue2中的nextTick比vue3多了些内容。</p><p>nextTick也模拟了一个回调任务队列<code>callbacks</code>（注意这不是调度的任务队列）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将回调加入队列中</span></span><br><span class="line">  callbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果队列没有正在执行（flush），就去清空队列</span></span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    timerFunc() <span class="comment">// 清空队列</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nextTick调用了<code>timeFunc</code>来清空队列</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 省略... 就是清空callbakcs任务队列</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 支持promise，就用promise来模拟异步</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 2. 不支持promise 就用MutationObserver来模拟异步</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">  MutationObserver.toString() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="comment">// Use MutationObserver where native Promise is not available,</span></span><br><span class="line">  <span class="comment">// e.g. PhantomJS, iOS7, Android 4.4</span></span><br><span class="line">  <span class="comment">// (#6466 MutationObserver is unreliable in IE11)</span></span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.用setImmediate来模拟异步</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line"></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了更多的兼容浏览器，timerFunc模拟异步判断了三种情况</p><ol><li>支持Promise，就直接用Promise来模拟异步。Promise属于微任务</li><li>不支持Promise，支持MutationObserver。MutationObserver也属于微任务<ul><li>创建一个空的文本节点，监听这个文本节点的字符变化。变化了就调用<code>flushCallbacks</code>来清空回调任务队列</li><li>调用<code>timerFunc</code>，会修改文本节点的内容，从而触发<code>flushCallbacks</code>函数的执行</li></ul></li><li><code>MutationObserver</code>和<code>Promise</code>都不支持，就用<code>setImmediate</code>来模拟异步，后者属于宏任务</li><li>最后方案就是使用setTimeout来模拟异步</li></ol><p>可见<code>vue2</code>为了兼容性，下足了功夫。而<code>vue3</code>直接就使用了<code>Promise</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在vue3中，修改一个响应式对象，像是这样：&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    <category term="源码" scheme="https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="vue" scheme="https://zxffan.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>栈问题梳理</title>
    <link href="https://zxffan.github.io/posts/1f4ac2fb.html"/>
    <id>https://zxffan.github.io/posts/1f4ac2fb.html</id>
    <published>2021-04-02T16:00:00.000Z</published>
    <updated>2021-06-29T14:03:52.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="普通栈"><a href="#普通栈" class="headerlink" title="普通栈"></a>普通栈</h2><p>栈的特性：<code>先进后出</code></p><p>数组模拟：</p><ul><li>进栈：<code>arr.push()</code></li><li>出栈：<code>arr.pop()</code></li></ul><h3 id="匹配消除"><a href="#匹配消除" class="headerlink" title="匹配消除"></a>匹配消除</h3><p>栈可以用来解决<strong>匹配</strong>问题</p><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">20. 有效的括号</a></h3><p>括号匹配，<code>(&#123;[</code>与<code>]&#125;)</code>匹配</p><p>创建一个栈<code>stack</code>，并遍历字符串。当遇到<code>(&#123;[</code>时入栈，当遇到<code>]&#125;)</code>时，取栈顶元素比较</p><ul><li>相匹配，栈顶元素出栈，继续循环</li><li>不匹配，直接返回<code>false</code></li></ul><p>时间复杂度O(n)，空间复杂度O(n)</p><blockquote><p>如果栈中的元素都一样，就不需要用栈，用一个计数器count即可</p></blockquote><h3 id="大鱼吃小鱼"><a href="#大鱼吃小鱼" class="headerlink" title="大鱼吃小鱼"></a>大鱼吃小鱼</h3><p><em>题目】在水中有许多鱼，可以认为这些鱼停放在 x 轴上。再给定两个数组 Size，Dir，Size[i] 表示第 i 条鱼的大小，Dir[i] 表示鱼的方向 （0 表示向左游，1 表示向右游）。这两个数组分别表示鱼的大小和游动的方向，并且两个数组的长度相等。鱼的行为符合以下几个条件:</em></p><p><em>所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离；</em></p><p><em>当方向相对时，大鱼会吃掉小鱼；</em></p><p><em>鱼的大小都不一样。</em></p><p><em>输入：Size = [4, 2, 5, 3, 1], Dir = [1, 1, 0, 0, 0]</em></p><p><em>输出：3</em></p><p>这道题跟上一条题原理一样都是<strong>匹配消除</strong>，上一道题是根据元素的内容（括号）来判断匹配消除。而本道题是根据元素的<strong>大小</strong>的<strong>“方向”</strong>两个条件来判断</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> LEFT = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> RIGHT = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eatFish</span>(<span class="params">size: <span class="built_in">number</span>[], dir: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack: <span class="built_in">number</span>[] = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 还没有鱼</span></span><br><span class="line">    <span class="keyword">if</span> (stack.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      stack.push(i);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> insert = <span class="literal">true</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 栈顶的鱼比 当前的鱼小, 就一直循环得吃</span></span><br><span class="line">    <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> last = stack[stack.length - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">const</span> canMeet = dir[last] === RIGHT &amp;&amp; dir[i] == LEFT;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (canMeet &amp;&amp; size[last] &lt; size[i]) stack.pop();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 大鱼把栈中的所有鱼都吃完了，需要在最后将这条大鱼放入栈中</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (canMeet) &#123;</span><br><span class="line">        insert = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        insert = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 栈中的鱼都吃完了</span></span><br><span class="line">    <span class="keyword">if</span> (insert) stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> stack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>单调栈分为两种：</p><ul><li>递增栈</li><li>递减栈</li></ul><h3 id="相邻最小索引"><a href="#相邻最小索引" class="headerlink" title="相邻最小索引"></a>相邻最小索引</h3><p>【题目】一个整数数组 A，找到每个元素：右边第一个比我小的下标位置，没有则用 -1 表示。</p><p>输入：[5, 2]</p><p>输出：[1, -1]</p><p>解释：因为元素 5 的右边离我最近且比我小的位置应该是 A[1]，最后一个元素 2 右边没有比 2 小的元素，所以应该输出 -1。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析：</span></span><br><span class="line"><span class="comment"> *  遍历数组元素，构造递增栈</span></span><br><span class="line"><span class="comment"> *  当前元素比栈顶小，则栈顶元素需要出栈，并记录栈顶元素右侧第一个小的下标为当前元素下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findRightSmall</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result: <span class="built_in">number</span>[] = arr.map(<span class="function">(<span class="params">i</span>) =&gt;</span> -<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> stack: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> cur = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span> &amp;&amp; arr[stack[stack.length - <span class="number">1</span>]] &gt; cur) &#123;</span><br><span class="line">      result[stack[stack.length - <span class="number">1</span>]] = i;</span><br><span class="line">      stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变一下问题</span></span><br><span class="line"><span class="comment">// 求左边第一个比我下的下标为止，没有则用-1表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析</span></span><br><span class="line"><span class="comment"> *  还是遍历数组元素，构造递增栈</span></span><br><span class="line"><span class="comment"> *  当前元素小于等于栈顶元素是需要出栈</span></span><br><span class="line"><span class="comment"> *  当不需要栈顶元素出栈，说明当前元素比栈顶元素大。即栈顶元素是当前元素左侧第一个小的元素，记录一下</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 记录之前还要排除掉相等的情况，即从栈顶往下找，一直找到一个不相同的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findLeftSmall</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result: <span class="built_in">number</span>[] = arr.map(<span class="function">(<span class="params">i</span>) =&gt;</span> -<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> stack: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> cur = arr[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (stack.length &gt; <span class="number">0</span> &amp;&amp; arr[stack[stack.length - <span class="number">1</span>]] &gt; cur) stack.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> top = stack.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (arr[stack[top]] === cur) top--;</span><br><span class="line">    <span class="keyword">if</span> (top &gt;= <span class="number">0</span>) result[i] = stack[top];</span><br><span class="line"></span><br><span class="line">    stack.push(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="字典序最小的-k-个数的子序列"><a href="#字典序最小的-k-个数的子序列" class="headerlink" title="字典序最小的 k 个数的子序列"></a>字典序最小的 k 个数的子序列</h3><p>【题目】给定一个正整数数组和 k，要求依次取出 k 个数，输出其中数组的一个子序列，需要满足：1. 长度为 k；2.字典序最小。</p><p>输入：nums = [3,5,2,6], k = 2<br>输出：[2,6]</p><p>解释：在所有可能的解：{[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 字典序最小。</p><p>所谓字典序就是，给定两个数组：x = [x1,x2,x3,x4]，y = [y1,y2,y3,y4]，如果 0 ≤ p &lt; i，xp == yp 且 xi &lt; yi，那么我们认为 x 的字典序小于 y。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findSmallSeq</span>(<span class="params">seg: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> stack: <span class="built_in">number</span>[] = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; seg.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> cur = seg[i];</span><br><span class="line">    <span class="keyword">if</span> (stack.length &lt;= <span class="number">0</span>) stack.push(cur);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (</span><br><span class="line">      stack.length &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">      stack[stack.length - <span class="number">1</span>] &gt; cur &amp;&amp;</span><br><span class="line">      stack.length + seg.length - i &gt; k</span><br><span class="line">    )</span><br><span class="line">      stack.pop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stack.length &lt; k) stack.push(cur)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> stack;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="单调栈的运用"><a href="#单调栈的运用" class="headerlink" title="单调栈的运用"></a>单调栈的运用</h2><p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></p><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;普通栈&quot;&gt;&lt;a href=&quot;#普通栈&quot; class=&quot;headerlink&quot; title=&quot;普通栈&quot;&gt;&lt;/a&gt;普通栈&lt;/h2&gt;&lt;p&gt;栈的特性：&lt;code&gt;先进后出&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;数组模拟：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进栈：&lt;code&gt;arr.push</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://zxffan.github.io/categories/Algorithm/"/>
    
    
    <category term="JavaScript" scheme="https://zxffan.github.io/tags/JavaScript/"/>
    
    <category term="TypeScript" scheme="https://zxffan.github.io/tags/TypeScript/"/>
    
    <category term="Algorithm" scheme="https://zxffan.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>vue3-vnode</title>
    <link href="https://zxffan.github.io/posts/f9d1a0d8.html"/>
    <id>https://zxffan.github.io/posts/f9d1a0d8.html</id>
    <published>2021-03-29T16:00:00.000Z</published>
    <updated>2021-06-29T14:07:39.691Z</updated>
    
    <content type="html"><![CDATA[<p><code>VNode</code>是vue十分重要的核心概念，下图整理了VNode的创建、销毁、更新patch等流程。</p><p><img src="../../images/Vue/VNode.svg" alt="VNode"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;VNode&lt;/code&gt;是vue十分重要的核心概念，下图整理了VNode的创建、销毁、更新patch等流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/Vue/VNode.svg&quot; alt=&quot;VNode&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="源码" scheme="https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="vue" scheme="https://zxffan.github.io/tags/vue/"/>
    
  </entry>
  
</feed>
