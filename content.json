{"meta":{"title":"zxfan","subtitle":"zxfan's Blog","description":"","author":"zxfan","url":"https://zxffan.github.io","root":"/"},"pages":[{"title":"关于","date":"2021-06-29T13:27:06.033Z","updated":"2021-06-29T13:27:06.033Z","comments":false,"path":"about/index.html","permalink":"https://zxffan.github.io/about/index.html","excerpt":"","text":"个人信息zxffan 技术博客 Github Beijing 技术栈 Electron桌面开发 vue/react web开发 nodejs方向开发"},{"title":"分类","date":"2021-06-29T13:27:37.614Z","updated":"2021-06-29T13:27:37.614Z","comments":false,"path":"categories/index.html","permalink":"https://zxffan.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-06-29T13:28:49.898Z","updated":"2021-06-29T13:28:49.898Z","comments":false,"path":"repository/index.html","permalink":"https://zxffan.github.io/repository/index.html","excerpt":"","text":""},{"title":"source-code","date":"2021-03-14T08:11:53.703Z","updated":"2021-03-14T08:11:53.703Z","comments":true,"path":"source-code/index.html","permalink":"https://zxffan.github.io/source-code/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-06-29T13:29:07.180Z","updated":"2021-06-29T13:29:07.180Z","comments":true,"path":"tags/index.html","permalink":"https://zxffan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Crypto","slug":"experience/Crypto","date":"2021-06-19T16:00:00.000Z","updated":"2021-06-29T14:01:39.716Z","comments":true,"path":"posts/6f842db3.html","link":"","permalink":"https://zxffan.github.io/posts/6f842db3.html","excerpt":"","text":"哈希哈希算法又称为散列算法。将一个任意长度的的数组作为输入，能够获得固定长度的输出。 123456789101112131415161718const crypto = require(&quot;crypto&quot;);console.log(crypto.getHashes());/*输出[ &#x27;RSA-MD4&#x27;, &#x27;RSA-MD5&#x27;, &#x27;RSA-MDC2&#x27;, &#x27;RSA-RIPEMD160&#x27;, &#x27;RSA-SHA1&#x27;, &#x27;RSA-SHA1-2&#x27;, &#x27;RSA-SHA224&#x27;, ... ...]*/ 以md5为例： 12345678const crypto = require(&quot;crypto&quot;);const text = &quot;hello crypto!&quot;;const md5 = crypto.createHash(&quot;md5&quot;);const result = md5.update(text).digest(&quot;hex&quot;);console.log(result); createHash：创建hash，参数为hash算法，具体见crypto.getHashes() update：对字符串进行hash digest：获取信息摘要 不传参数，返回Buffer 参数为字符编码，hex返回16进制 md5是不可逆的，破解md5也只能使用暴力的“碰撞破解”。所以一般会对文本进行多次md5哈希：md5.update(text).update(text).update(text) 哈希算法通常用作信息摘要算法，比如双发通信时，发送方将资源（数据，用户）的信息摘要进行加密，接收方再去验证比对 HMACHmac被称为加盐算法，即 Hmac = hash + 密钥。比如sha-1算法 1234567const crypto = require(&quot;crypto&quot;);const text = &quot;hello crypto!&quot;;const result = crypto.createHmac(&quot;sha1&quot;, &quot;miyao&quot;).update(text).digest(&quot;hex&quot;);console.log(result); // 09ef939a42b909a48d8ea3803692ec88eedc4c04 createHmac第二个参数密钥 密钥可以通过openssl来创建 openssl genrsa -out rsa_private.key 1024 对称加密对称加密指：利用同意个密钥来加密/解密数据。这有两个关键点： 有加密也有解密，所以加密算法是可逆的 同一个密钥 以aes192为例： 1234567891011121314151617181920212223const crypto = require(&quot;crypto&quot;);const text = &quot;hello crypto!&quot;;const key = crypto.scryptSync(&quot;woshimiyao&quot;, &quot;yanzhi&quot;, 24); // 密钥// 加密function encrypt(data, iv) &#123; const cipher = crypto.createCipheriv(&quot;aes192&quot;, key, iv); return cipher.update(data, &quot;utf-8&quot;, &quot;hex&quot;).final(&quot;hex&quot;);&#125;// 解密function decrypt(data, iv) &#123; const decipher = crypto.createDecipheriv(&quot;aes192&quot;, key, iv); return decipher.update(data, &quot;hex&quot;, &quot;utf-8&quot;).final(&quot;utf-8&quot;);&#125;const iv = Buffer.alloc(16, 0); // 初始化向量const e = encrypt(text, iv);const d = decrypt(e, iv);console.log(e, d); // 3e07418b2c1ed2b128943b005610f166 hello crypto! 非对称加密非对称加密：利用两个密钥，一个用于加密另一个用于解密。这也有两个关键点： 有加密也有解密，所以加密算法是可逆的 两个密钥： 公钥：用于加密 私钥：用于解密 常见加密算法","categories":[{"name":"experience","slug":"experience","permalink":"https://zxffan.github.io/categories/experience/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://zxffan.github.io/tags/Nodejs/"},{"name":"crypto","slug":"crypto","permalink":"https://zxffan.github.io/tags/crypto/"}]},{"title":"字节跳动面试","slug":"self/byte dance","date":"2021-06-04T16:00:00.000Z","updated":"2021-06-29T14:06:58.075Z","comments":true,"path":"posts/33f3fd9d.html","link":"","permalink":"https://zxffan.github.io/posts/33f3fd9d.html","excerpt":"","text":"一面 自我介绍 网络模型：osi七层模型，每层干什么的？ http协议的理解。想到啥说啥。就是你随便说，面试官会顺着问 无状态 应用层协议，基于tcp 发展历史：从0.9到3.0 缓存 http状态吗：从1xx一直说到5xx https？说了一下tls协商 es6相关，说一些用过哪些？面试官会顺着问。 var/let/const ， 面试官顺着问了它们的区别 字符串有哪些方法。这个问题应该是问错了，他想问得是数组：map filter reduce sort… 模块规范 esm cjs 区别 promise，然后就开始手写。估计他最初是想让我实现数组相关的方法，但是发现自己问错了就跳过了。 3道题 Promise.all 快排、归并，dfs选一个写 最小银币找零问题：现有[1,2,5,9,10]几种硬币，当有18面值的硬币时，如何找零使得硬币数量最少；答案是2——18 = 9+9 感受：一面还是非常基础的。问了挺多的网络相关的内容 二面 自我介绍？没让自我介绍直接开始。 看简历： 问你是怎么优化（webpack）构建性能的？ 缓存：如何根据js代码变化去修改缓存的？ thread-loader 怎么选取进程数量的？ 如何去做chunk拆分，怎么考量的？ cli脚手架 怎么设计的？ vue的computed如何进行依赖收集？说了computed的实现机制。 vue3相对于vue2做了哪些改进？讲了响应式和compiler的优化（静态提升、pathFlag、BlockTree） 手写题目：类似vue中的渲染函数（render），让你生成dom元素（返回一个dom对象） 1234const vnode = el(&quot;div&quot;, &#123; class: &quot;container&quot; &#125;, [ el(&quot;span&quot;, &#123;&#125;, [&quot;hello world&quot;]),]);vnode.render(); 场景题： 一个多语言应用，大概14种语言。假如每个语言都放在一个js文件中（中文的一个文件，英文的一个文件）。目前存在两个问题 应用启动时，会加载这14种语言（js文件），但实际上只需要1种语言，问如何优化？ 随着开发，有一些语言的值不在使用了，但还是加载到内存中去了，如何优化？ 感受：二面连自我介绍都省了，哈哈！！感觉面试官爱从编译的角度问问题，估计这和他的具体工作相关吧。总体感觉这位面试官还是不错的，问得都是比较实际的问题。 三面三面聊得特别广，也挺深的。 之前性能优化怎么做的，这个聊了很久 cdn为什么会快？ 从url到页面渲染的过程 知道http如何判断响应返回的吗？ script 加载为什么会阻塞dom解析，既然有defer和async，为什么浏览器不默认defer/async? js中函数是一等公民。js中函数可以返回一个函数（闭包），知道这个特性实现难点在哪吗？ 你的项目（自己的开源项目）有做过设计吗？看过设计相关的书吗？ 设计模式 函数式编程 你项目写了虚拟列表优化，怎么做的 滚动得快的话，出现白屏怎么优化？ 如果高度不固定，怎么实现？ 为什么会学习electron？ electron的进程模型 浏览器的进程模型 手写题： 场景：根据ip判断ip所在范围，要求：尽可能高效 12345678// 假如在这两个范围内的 是中国的ipconst db = [ [&quot;0.0.0.0&quot;, &quot;10.0.0.0&quot;], [&quot;11.0.0.0&quot;, &quot;200.0.0.0&quot;],]// ip: string，判断ip是否是中国ipfunction isInChain(ip) &#123;&#125; 感觉三面的面试官的职责可能不仅仅是前端，喜欢问一些特别底层的问题。 三轮技术面试都没有怎么考算法，就一面考了一道动态规划。飞书的面试官还是比较注重实际的开发能力的。","categories":[{"name":"self","slug":"self","permalink":"https://zxffan.github.io/categories/self/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://zxffan.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"interview","slug":"interview","permalink":"https://zxffan.github.io/tags/interview/"}]},{"title":"clear 清除浮动","slug":"CSS/clear清除浮动","date":"2021-05-30T16:00:00.000Z","updated":"2021-06-29T14:04:02.889Z","comments":true,"path":"posts/d8bddba6.html","link":"","permalink":"https://zxffan.github.io/posts/d8bddba6.html","excerpt":"","text":"场景clear用于解决，由于float造成的浮动塌陷问题。 只能清除前面的浮动123456789101112131415161718192021&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;a&quot;&gt;a&lt;/div&gt; &lt;div class=&quot;b&quot;&gt;b&lt;/div&gt; &lt;div class=&quot;c&quot;&gt;c&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .box &#123; background: red; &#125; .a, .b, .c &#123; float: left; &#125; .b &#123; clear: left &#125;&lt;/style&gt; 无论对b设置clear: left/right/both。都只能清除a的浮动（a将独占一行），然而无法清除b的浮动。这是因为浏览器的解析顺序的缘故。 那么clear: right有什么用？当float:right时不就能清除右侧浮动了么！","categories":[{"name":"CSS","slug":"CSS","permalink":"https://zxffan.github.io/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"https://zxffan.github.io/tags/css/"}]},{"title":"前端性能优化","slug":"experience/性能优化","date":"2021-05-17T16:00:00.000Z","updated":"2021-06-29T14:02:54.457Z","comments":true,"path":"posts/616f4683.html","link":"","permalink":"https://zxffan.github.io/posts/616f4683.html","excerpt":"","text":"性能优化性能优化是很大的话题，可以从两个角度入手 优化资源体积 优化请求速度 优化资源体积资源懒加载资源懒加载就是指，当前这个页面只去加载本页面的资源。其它资源不去加载 按照路由懒加载如果使用webpack这种构建工具，可以使用动态import函数来按照路由实现拆分chunk 拆分node_modules如果一个项目使用到了诸如：element-ui vue pdfjs videojs这些插件；webpack默认会将所有node_modules打包成一个chunk。但是某一个页面只用到了vue没有用到其它库，这是就会导致这个页面加载了许多无用的资源 所以我们要根据使用情况来拆分node_modules。具体做法就是通过webpack的splitChunk功能来实现。 把这些库都拆分出去了，不就影响到下个页面的性能的吗？ 利用preftch解决 import函数可以使用魔法注释 /*.webpackPrefetch: true */ /*.webpackPreload: true */ 库按需加载比如element-ui，它内置了大量组件。我们应该去按需引用他们。 使用babel-plugin-import来实现组件库（js和css）的按需加载 资源压缩客户端压缩客户端压缩资源文件，比如js css img等 js：使用terser-webpack-plugin压缩脚本代码 css：使用optimize-css-webpack-plugin Img: 图片可以使用 image-webpack-loader压缩 服务端压缩服务端开启g-zip压缩 比如nginx，直接配置gzip: on即可 优化请求速度从请求速度角度入手。首先，需要理清楚页面显示之前都发生了些什么。 浏览器缓存输入url，后首先不是DNS，而是检查浏览器缓存。浏览器缓存可以分成四种 Service Workerservice worder就是服务端与客户端之间的代理人。客户端对资源的请求会被service worker拦截下来 12345678910111213141516171819202122// worker.js/* 监听安装事件，install 事件一般是被用来设置你的浏览器的离线缓存逻辑 */this.addEventListener(&#x27;install&#x27;, function (event) &#123; /* 通过这个方法可以防止缓存未完成，就关闭serviceWorker */ event.waitUntil( /* 创建一个名叫V1的缓存版本 */ caches.open(&#x27;v1&#x27;).then(function (cache) &#123; /* 指定要缓存的内容，地址为相对于跟域名的访问路径 */ return cache.addAll([ &#x27;./index.html&#x27; // 资源URL ]); &#125;) );&#125;);/* 注册fetch事件，拦截全站的请求 */this.addEventListener(&#x27;fetch&#x27;, function(event) &#123; /* 在缓存中匹配对应请求资源直接返回 */ event.respondWith(caches.match(event.request));&#125;); service worker需要注册, navigator.serviceWorker.register 123456789101112131415161718// main.js/* 判断当前浏览器是否支持serviceWorker */if (&#x27;serviceWorker&#x27; in navigator) &#123; /* 当页面加载完成就创建一个serviceWorker */ window.addEventListener(&#x27;load&#x27;, function () &#123; /* 创建并指定对应的执行内容 */ /* scope 参数是可选的，可以用来指定你想让 service worker 控制的内容的子目录。 在这个例子里，我们指定了 &#x27;/&#x27;，表示 根网域下的所有内容。这也是默认值。 */ navigator.serviceWorker.register(&#x27;./serviceWorker.js&#x27;, &#123;scope: &#x27;./&#x27;&#125;) .then(function (registration) &#123; console.log(&#x27;ServiceWorker registration successful with scope: &#x27;, registration.scope); &#125;) .catch(function (err) &#123; console.log(&#x27;ServiceWorker registration failed: &#x27;, err); &#125;); &#125;);&#125; service worker是基于web worker memory cache &amp; disk cache 内存缓存，这部分资源存放到内存中的 磁盘缓存，这部分资源是存放到磁盘中的。也就是我们常说的强缓存和协商缓存 chrome会自动将磁盘缓存存放到内存中，下次请求时，就会自动从内存中去。内存IO的性能肯定优于磁盘IO。当浏览器关闭后，存放到内存的缓存就会自动清空，而磁盘缓存一致存在 push cacheHTTP2拥有服务端推送的功能。 DNS prefetch开启DNS 预取，在加载HTML时，开始解析域名获取IP。 12345&lt;!-- 会自动加上响应头，告诉浏览器开始dns预解析 --&gt;&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot; /&gt;&lt;!-- 指定要解析的域名 --&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//www.zhix.net&quot; /&gt; CDN将一些图片或者不变的大资源，采用CDN上云的方式。从而加快请求速度 并发限制现代浏览器对同一个域的请求是有并发限制的。比如chrome最多并发6个请求。我们有两种方案来解决： 拆分不同的域名：那我们可以将资源拆分到不同的域下，从而绕开限制。 使用HTTP2：http2可以实现多路复用，一个域名只需要建立一个tcp连接","categories":[{"name":"experience","slug":"experience","permalink":"https://zxffan.github.io/categories/experience/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://zxffan.github.io/tags/Nodejs/"},{"name":"网络","slug":"网络","permalink":"https://zxffan.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"Vuex@4.x","slug":"sourcecode/Vuex@4","date":"2021-05-12T16:00:00.000Z","updated":"2021-06-29T14:07:43.104Z","comments":true,"path":"posts/340f0a10.html","link":"","permalink":"https://zxffan.github.io/posts/340f0a10.html","excerpt":"","text":"Vuex注册流程首先通过createStore方法创建一个store对象。然后使用app.use(store)。store对象是一个vue插件。所以必须实现install方法 12345678910&#123; install (app, injectKey) &#123; app.provide(injectKey || storeKey, this) app.config.globalProperties.$store = this &#125;&#125;// 在组件里使用vuex// 1: this.$store// 2: inject: [injectKey] 创建store对象的流程： 初始化所有module resetStoreState 注册getter 响应式state 如何注册moduleinstallModule会初始化root模块，也会初始化所有子模块 1234567891011121314151617181920212223242526272829303132333435363738394041function installModule (store, rootState, path, module, hot) &#123; const isRoot = !path.length const namespace = store._modules.getNamespace(path) // register in namespace map if (module.namespaced) &#123; store._modulesNamespaceMap[namespace] = module &#125; // set state if (!isRoot &amp;&amp; !hot) &#123; const parentState = getNestedState(rootState, path.slice(0, -1)) const moduleName = path[path.length - 1] &#125; const local = module.context = makeLocalContext(store, namespace, path) // 注册所有mutation module.forEachMutation((mutation, key) =&gt; &#123; const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local) &#125;) // 注册所有action module.forEachAction((action, key) =&gt; &#123; const type = action.root ? key : namespace + key const handler = action.handler || action registerAction(store, type, handler, local) &#125;) // 注册所有getter module.forEachGetter((getter, key) =&gt; &#123; const namespacedType = namespace + key registerGetter(store, namespacedType, getter, local) &#125;) // 注册所有子模块 module.forEachChild((child, key) =&gt; &#123; installModule(store, rootState, path.concat(key), child, hot) &#125;)&#125; 注册getters12345678910111213141516171819function registerGetter (store, type, rawGetter, local) &#123; if (store._wrappedGetters[type]) &#123; if (__DEV__) &#123; console.error(`[vuex] duplicate getter key: $&#123;type&#125;`) &#125; return &#125; // 把所有getter 注册到 _wrappedGetters对象上 store._wrappedGetters[type] = function wrappedGetter (store) &#123; // rawGetter就是开发者提供的getter return rawGetter( local.state, // local state local.getters, // local getters store.state, // root state store.getters // root getters ) &#125;&#125; 注册actions1234567891011121314151617181920212223242526272829function registerAction (store, type, handler, local) &#123; const entry = store._actions[type] || (store._actions[type] = []) // 利用闭包实现柯里化 // 下次执行函数就不需要传参数了 entry.push(function wrappedActionHandler (payload) &#123; let res = handler.call(store, &#123; dispatch: local.dispatch, commit: local.commit, getters: local.getters, state: local.state, rootGetters: store.getters, rootState: store.state &#125;, payload) // 会用Promise包一层 action if (!isPromise(res)) &#123; res = Promise.resolve(res) &#125; if (store._devtoolHook) &#123; return res.catch(err =&gt; &#123; store._devtoolHook.emit(&#x27;vuex:error&#x27;, err) throw err &#125;) &#125; else &#123; return res &#125; &#125;)&#125; 注册mutations12345678function registerMutation (store, type, handler, local) &#123; const entry = store._mutations[type] || (store._mutations[type] = []) // 对各个模块 注册mutation entry.push(function wrappedMutationHandler (payload) &#123; handler.call(store, local.state, payload) &#125;)&#125; 如何初始化store中的数据需要响应式的数据有getters和state state的响应式是通过reactive对象来实现的 1234567891011121314151617181920212223242526272829303132333435363738function resetStoreState (store, state, hot) &#123; const oldState = store._state // bind store public getters store.getters = &#123;&#125; // reset local getters cache store._makeLocalGettersCache = Object.create(null) const wrappedGetters = store._wrappedGetters const computedObj = &#123;&#125; forEachValue(wrappedGetters, (fn, key) =&gt; &#123; computedObj[key] = partial(fn, store) Object.defineProperty(store.getters, key, &#123; get: () =&gt; computedObj[key](), enumerable: true // for local getters &#125;) &#125;) // 使用reactive响应式state store._state = reactive(&#123; data: state &#125;) // enable strict mode for new state if (store.strict) &#123; enableStrictMode(store) &#125; if (oldState) &#123; if (hot) &#123; // dispatch changes in all subscribed watchers // to force getter re-evaluation for hot reloading. store._withCommit(() =&gt; &#123; oldState.data = null &#125;) &#125; &#125;&#125; 如何实现只有mutation才能修改state说明：只有严格模式且开发模式下，vuex才会阻止非mutation修改state 123456789101112131415161718// 严格模式会调用 enableStrictModeif (store.strict) &#123; enableStrictMode(store)&#125;// 使用watch监听state，如果state发生变化// 提示function enableStrictMode (store) &#123; watch(() =&gt; store._state.data, () =&gt; &#123; if (__DEV__) &#123; // assert如果条件为 false会抛一场 // 由于是sync // 所以会阻止修改 assert(store._committing, `do not mutate vuex store state outside mutation handlers.`) &#125; &#125;, &#123; deep: true, flush: &#x27;sync&#x27; &#125;)&#125; 所以这个store._committing只要是false就会阻止修改state。 那什么时候这个值为true呢，那肯定是commit的时候 1234567891011121314this._withCommit(() =&gt; &#123; entry.forEach(function commitIterator (handler) &#123; handler(payload) &#125;)&#125;)// _withCommit方法会修改_committing的状态// 执行完mutation又会 改回来_withCommit (fn) &#123; const committing = this._committing this._committing = true fn() this._committing = committing&#125;","categories":[{"name":"源码","slug":"源码","permalink":"https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://zxffan.github.io/tags/vue/"}]},{"title":"Electron的隔离上下文","slug":"Electron/Electron的隔离上下文","date":"2021-05-04T16:00:00.000Z","updated":"2021-06-29T14:04:31.391Z","comments":true,"path":"posts/b9b99d96.html","link":"","permalink":"https://zxffan.github.io/posts/b9b99d96.html","excerpt":"","text":"ContextIsolation处于安全考虑，Electron12默认开启了上下文隔离（context isolation），它会将上下文环境划分两个运行环境——主环境和隔离环境 主环境：渲染进程所运行的环境，无法访问到Electron API 隔离环境：preload脚本所运行的环境，能够访问到Electron API ContextIsolation是默认开启的 123456new BrowserWindow(&#123; webPreference: &#123; contextIsolation: true // 默认就是true preload: &#x27;path to your preload js file&#x27;, // 设置preload脚本 &#125;&#125;) ContextBridge通过使用ContextBridge，可以通过隔离环境将Electron API暴露给主环境 123456789// 隔离环境const &#123; contextBridge, ipcRenderer &#125; = require(&#x27;electron&#x27;)contextBridge.exposeInMainWorld( &#x27;electron&#x27;, &#123; doThing: () =&gt; ipcRenderer.send(&#x27;do-a-thing&#x27;) &#125;) 主环境直接在window对象上使用window.electron.doThing()","categories":[{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/categories/Electron/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/tags/Electron/"},{"name":"桌面端软件","slug":"桌面端软件","permalink":"https://zxffan.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF%E8%BD%AF%E4%BB%B6/"}]},{"title":"vue-router@4.x","slug":"sourcecode/vue-router@4","date":"2021-04-30T16:00:00.000Z","updated":"2021-06-29T14:07:20.169Z","comments":true,"path":"posts/22412f62.html","link":"","permalink":"https://zxffan.github.io/posts/22412f62.html","excerpt":"","text":"问题vue-router是如何实现修改url而不会使页面刷新？vue-router通过history这个BOM对象来修改url的 history.pushState：向当前浏览器会话的历史堆栈中添加一个state history.replaceState：替换历史堆栈栈顶的state 这两个API不会导致页面刷新 vue-router如何监听url变化？history.pushState和history.replaceState是手动执行的，不需要监听 需要监听浏览器后退——window.addEventListener(&quot;popstate&quot;, () =&gt; &#123;&#125;) 旧版本的vue-router。对hash路由做了一层兼容性判断：如果浏览器支持history.pushState就监听popstate事件，否则监听hashchange vue-router的路由组件如何响应url变化在执行vue-router的install方法时，将currentRoute全局注入（provide），然后在router-view组件内inject。 在创建router时传入了routes参数，以定义应用的路由列表。routes是一个树结构。每一次路由变化时，都会在routes中寻找一个匹配当前跳转url的路由列表（数组）并赋值给currentRoute.matched。 在router-view中时这样获取的： 123const matchedRouteRef = computed&lt;RouteLocationMatched | undefined&gt;( () =&gt; routeToDisplay.value.matched[depth]) router-view是一个嵌套结构，depth表示深度。depth是这样来的： 12const depth = inject(viewDepthKey, 0) // 初始默认为0provide(viewDepthKey, depth + 1) // +1 provide给子组件 这样就可以获取匹配到的路由，然后就是获取路由对应的组件，并渲染。 导航守卫原理每次发生路由跳转时，回去执行导航守卫，源码位于vue-router-next/src/router.ts下的navigate方法。该方法主要做了： 收集beforeRouteLeave导航守卫 执行所有收集到的导航 收集并执行全局守卫beforeEach 收集并执行beforeRouteUpdate 收集并执行beforeEnter 收集并执行beforeRouteEnter 收集并执行beforeResolve 最后执行afterEach 整个过程是Promise链式调用。若其中一步reject，后面就不会执行了。","categories":[{"name":"源码","slug":"源码","permalink":"https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://zxffan.github.io/tags/vue/"}]},{"title":"网络知识梳理","slug":"Network/网络知识梳理","date":"2021-04-29T16:00:00.000Z","updated":"2021-06-29T14:06:15.777Z","comments":true,"path":"posts/8c9e2fd.html","link":"","permalink":"https://zxffan.github.io/posts/8c9e2fd.html","excerpt":"","text":"HTTP演进HTTP/0.9第一版HTTP协议，只能传输文本，请求报文内容只有 1 行。 客户端：请求报文：GET/index.html 服务端：返回一个以 ASCII 字符流编码的 HTML 文档。 HTTP/1.0HTTP 可以用来传输脚本、样式、图片、音频和视频等不同类型的文件 增加了头部的设定，Accept和Content-Type HTTP/1.1解决了HTTP/1.0的连接问题，支持TCP连接复用 HTTP/1.0：每次请求都会建立连接、传输数据和断开连接三个阶段 HTTP/1.1：第二次请求会复用第一次请求的TCP连接 长连接可以在请求头中加上Connection: keep-alive。HTTP/1.1默认开启keep-alive，不加这个请求头也可以使用长连接的。 HTTP/2HTTP/2增强了并发能力 二进制传输：http/1.1传输的是文本，http/2传输的是二进制流 多路复用：http/2有两个概念——帧和流。http/2将数据报文分成一个个二进制帧（Frame），在一个TCP连接中，不同的帧组合在一起发送（二进制分帧）形成流（Stream）。在接收方根据帧首部信息在组合起来。HTTP/1.1只能一个个请求报文排队发送（容易发生队头阻塞）。 header压缩：http请求有这繁多冗长的首部，http/2会对首部进行压缩 服务端推送：能够主动给客户端推送资源 http/1.1加载网页的顺序：请求html，解析html，再请求js、css等文件 http/2：当服务端收到html请求时，服务端就主动吧html、css、js以及图片等资源发送给客户端 HTTP/3HTTP/1.x、HTTPS以及HTTP/2.0都离不开底层的TCP协议。 HTTP/2.0采用多路复用，多个数据包使用一个TCP连接。TCP是可靠连接，但发生丢包时，会进行重传。所以网络状态差的情况下，某些数据包频繁重传，从而导致拥塞，后面的HTTP包都穿不出去。这叫做头部阻塞（Head of line Blocking） HTTP/3.0就开始考虑放弃TCP转向UDP协议。起初Google搞出来个QUIC协议，后来IETF标准化了QUIC协议形成HTTP/3。其底层采用UDP，基于UDP实现做了众多增强： 0RTT：TPC建立连接每次都需要三次握手，就存在数据包的三次往返即3RTT。而QUIC首次建立连接只需要1RTT。其后的连接可以直接复用，只需要0RTT 连接迁移：当源IP、源端口、目的IP、目的端口其中一个发生变化就需要重新建立TCP连接。只要Connection ID没有变化。HTTP/3可以继续复用连接 头部阻塞：由于使用UDP，发生丢包时，也不会立即重传，阻塞连接。 拥塞控制 前向纠错 更多特性 请参考文章 chrome只支持 Google QUIC。对IETF QUIC的支持处于WIP状态 HTTPSHTTP(超文本传输协议)，有着一个致命的缺陷，那就是内容是明文传输的，没有经过任何加密，而这些明文数据会经过WiFi、路由器、运营商、机房等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露，这一攻击手法叫做MITM（Man In The Middle）中间人攻击。 HTTPS = HTTP + TLS/SSL。HTTPS就是在HTTP（应用层）与TCP（传输层）之间加上了一层TLS/SSL协议 对称加密和非对称加密区别： 加解密方式不同： 对称加密使用同一个密钥加解密 非对称加密使用不同的密钥加解密 性能：对称加密比非对称加密快 CA(Certification Authority)CA是为了保证密钥的正确性。具体来说就是把密钥放入一个证书中，该证书包含服务端的信息，比如颁发者、域名、有效期，为了保证证书是可信的，需要由一个可信的第三方来对证书进行签名。这个第三方一般是证书的颁发机构，也称 CA（Certification Authority，认证中心）。 HTTPS工作流程 客户端发送HTTPS请求（默认端口443） 服务端有一套CA数字证书，证书含有一个公钥public。服务端接收到请求，会将这个证书发送给客户端。服务端还有一个私钥private，私钥是一直保存再服务端不公开的。 客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续。 客户端先生成一段随机key，再利用证书中的公钥public加密这段随机key，并将这个随机key密文发送给服务端。 服务端收到这个随机key密文文后，通过私钥private来解密，获取客户端真正的随机key 服务端使用随机key来加密需要传输的HTTP数据，并发送给客户端 客户端再用随机key来解密服务端传输过来的密文，获取真正的数据 后续HTTPS请求使用之前交换好的随机Key进行对称加解密。 由于随机key明文没有再网络上传输，所以”中间人”并不知道用于加密和解密的随机key，因此是安全的 TCPSYN报文：请求连接 ACK报文：应答 FIN报文：断开连接 三次握手三次握手就是建立TCP连接的过程，流程如下图： 一共分三步： 客户端发送SYN消息给服务端（告知服务端要建立连接） 服务端同时发送两个消息（SYN和ACK）给客户端 ACK表示收到了客户端的SYN SYN表示服务端也要连接客户端 客户端发送ACK给服务端（表示接受服务端的SYN） 为什么要三次握手？ TCP是可靠传输，三次握手目的是确认双方的接收和发送能力。经过三次握手，服务端和客户端都确认了双方的接收和发送能力。 四次挥手四次挥手是TCP断开连接的过程，流程如下图 一共分为四步：（客户端和服务端都可以断开请求，以服务端为例） 服务端发送FIN请求，表示服务端要断开连接 客户端发送ACK请求，表示收到了服务端的请求 客户单发送FIN请求，表示客户端也要断开连接 服务端发送ACK请求，表示收到了客户端的请求 为什么2，3步骤不能一起发送 ACK只是对FIN的应答，断开连接要处理的问题比较多，比如说服务端/客户端可能还有发送出去的消息没有得到 ACK；也有可能服务端自己有资源要释放。 webscoketwebsocket的建立也是通过http实现的 首先，客户端先发送一个HTTP请求，请求头携带以下信息 1234567GET ws://websocket.example.com/ HTTP/1.1Host: websocket.example.comUpgrade: websocketConnection: UpgradeOrigin: http://example.comSec-WebSocket-Key:pAloKxsGSHtpIHrJdWLvzQ==Sec-WebSocket-Version:13 Connection: Upgrade告知服务端，浏览器想要升级协议 Upgrade: websocket：升级到websocket协议 Sec-WebSocket-Key浏览器的随机key，用于娇艳 Sec-WebSocket-Version：websocket版本 服务端收到请求，就开始升级协议，返回101。服务端收到。响应大概是这样的 1234HTTP/1.1 101 Switching ProtocolsUpgrade: websocketConnection: UpgradeSec-WebSocket-Accept: nRu4KAPUPjjWYrnzxDVeqOxCvlM= Sec-WebSocket-Accept是根据响应头中的key进行加密而来的 客户端收到这个响应后，会校验这个accept。就是以同样的方式加密key，看key和accept是否相同。 到这里，websocket的连接就建立完成了。随后的请求都是以websocket协议发送。 网络分层结构TCP/IP 四层模型TCP/IP是互联网相关的各类协议族的总称TCP/IP具有分层结构，分为：应用层、传输层、网络层和数据链路层 应用层应用层决定了向用户提供应用服务时通信的活动。相关协议：FTP、DNS以及HTTP 传输层传输层提供处于网络连接中的两台计算机之间的数据传输相关协议：TCP和UDP 网络层网络层规定了数据包通过怎样的传输线路到达对方计算机相关协议：IP 数据链路层数据链路是用来处理连接网络的硬件部分例如：NIC(网卡)、光纤等物理可见部分 OSI七层模型 应用层 表示层：负责数据格式的转换 会话层：负责建立和断开通信连接 传输层 网络层 数据链路层 物理层 数据链路层数据链路层主要有3种功能： 封装成帧：将物理层上交的比特流封装成帧 透明传输：封装成帧的时候，会给每个帧加上帧开始符（SOH）和帧结束符（EOT）。是指该层上传输的数据的内容、格式及编码没有限制，也没有必要解释信息结构的意义 差错检测 比特差错 帧 丢失/重复/失序 对于网络层，由于链路层的存在，而不需要关心物理层具体采用了那种传输介质和通信设备。 网络层、数据链路层和物理层要关联理解。 假如A与B通信（在不同的网段中），实际上AB之间还有很多的物理设备（交换机、路由器）。物理设备之间是通过传输介质相连接，比如光纤、同轴电缆（这属于物理层）。 消息从A到B，需要经过一个个的网段，每个网段内都是通过mac地址来寻找下一个站点（数据链路层）。在公网上使用IP来寻找目的主机（网络层） 传输单元物理层的 数据传输单元是数据位（bit）数据链路层的数据传输单元是数据帧（frame）网络层的数据传输单元是数据包（packet）传输层的 数据传输单元是数据段（segment）其他更高层次的数据传输单元是数据（data） TCP和UDP UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输，不使用流量控制和拥塞控制 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一，一对多，多对一和多对多交互通信 只能是一对一通信 传输方式 面向报文 面向字节流 首部开销 首部开销小，仅8字节 首部最小20字节，最大60字节 适用场景 适用于实时应用（IP电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输","categories":[{"name":"NetWork","slug":"NetWork","permalink":"https://zxffan.github.io/categories/NetWork/"}],"tags":[{"name":"NetWork","slug":"NetWork","permalink":"https://zxffan.github.io/tags/NetWork/"},{"name":"HTTP","slug":"HTTP","permalink":"https://zxffan.github.io/tags/HTTP/"}]},{"title":"JavaScript原型污染","slug":"JavaScript/JavaScript原型污染","date":"2021-04-28T16:00:00.000Z","updated":"2021-06-29T14:05:32.535Z","comments":true,"path":"posts/54b3fc67.html","link":"","permalink":"https://zxffan.github.io/posts/54b3fc67.html","excerpt":"","text":"原型污染 原型污染就是，通过某种手段达到修改JavaScript原型的目的 比如 1var a = &#123;&#125; 定义了一个对象a，a有一个constructor属性指向a的构造器（Object） 1a.constructor === Object // true Object很常用，比如：Object.prototype.toString 1Object.prototype.toString.call(a) // &quot;[object Object]&quot; 获取类型 但是问题来了，通过a对象可以访问并修改Object对象 1234a.constructor.prototype.toString = () =&gt; console.log(&quot;attack&quot;)// 再使用 toStringObject.prototype.toString.call(a) // &quot;attack&quot; 这就发生了原型污染 lodash发生过一次严重的原型污染bug，场景是两个对象合并merge(a, b)， 预防过滤危险属性两个对象合并，把constructor属性和__proto__这样的敏感过滤掉。 Object.freezeObject.freeze可以冻结一个对象，这个对象不能被修改。 原理就是修改对象的descriptor中的writable:false 12345Object.freeze(Object.prototype);Object.prototype.toString = &quot;attack&quot;consoel.log(Object.prototype.toString) // ƒ toString() &#123; [native code] &#125; Object.create(null)创建一个原型对象为null的对象，这样就不存在污染原型的情况 Map代替对象字面量map.set(&quot;__proto__&quot;, xx)并不会修改原型对象 提醒深合并和深拷贝算法注意原型污染","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"https://zxffan.github.io/tags/Promise/"}]},{"title":"Webpack构建流程源码解析","slug":"engineering/Webpack构建流程源码解析","date":"2021-04-27T16:00:00.000Z","updated":"2021-06-29T14:04:51.123Z","comments":true,"path":"posts/aef11e42.html","link":"","permalink":"https://zxffan.github.io/posts/aef11e42.html","excerpt":"","text":"webpack的构建分为3个阶段： 准备阶段：生成 compiler和compilation对象 编译阶段：递归生成模块依赖图 产出阶段：优化modules，生成chunks。最终输出文件 本文讨论的是webpack@5.34.0 准备阶段创建compiler对于每一个wepback的构建配置，都会创建一个compiler对象，记录着整个 Webpack 的生命周期 1234import webpack from &quot;webpack&quot;const compiler = webpack(options)// webpack(options, () =&gt; &#123;&#125;) 调用webpack函数会返回compiler对象，其内部大致逻辑如下： 12345678910111213const webpack = (options, callback) =&gt; &#123; // 1. 创建compiler let compiler; if (Array.isArray(options)) compiler = createMultiCompiler(options, options); else compiler = createCompiler(options); // 2. // 有callback参数就会自动执行compiler.run // options中watch为true就会自动调用compiler.watch // 3. 返回compiler return compiler&#125; 示例代码并非是webpack中的源码。只是将源码中的核心逻辑提炼出来的伪代码，这样更方便理解webpack的主流程。下同。 createCompiler和createMultiCompiler才是真正创建compiler的逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const createCompiler = rawOptions =&gt; &#123; // 1. normalize options // 就是对传入的options做些初始化，添加默认参数之类的工作 // 2. 他来了，创建compiler对象 const compiler = new Compiler(options.context); compiler.options = options; // 2. 新建NodeEvniromentPlugin，这是wepback启用的第一个plugin // 主要作用是 // - 创建日志（方便webpack输出构建日志） // - 设置compiler的文件系统 inputFileSystem... new NodeEnvironmentPlugin(&#123; infrastructureLogging: options.infrastructureLogging &#125;).apply(compiler); // 3. 执行所有plugin // - 函数plugin，执行函数 // - class plugin，执行其apply方法 if (Array.isArray(options.plugins)) &#123; for (const plugin of options.plugins) &#123; if (typeof plugin === &quot;function&quot;) &#123; plugin.call(compiler, compiler); &#125; else &#123; plugin.apply(compiler); &#125; &#125; &#125; applyWebpackOptionsDefaults(options); compiler.hooks.environment.call(); // hook compiler.hooks.afterEnvironment.call(); // hook // 5.添加默认内置plugin // 根据options的设置来配置响应内置plugin new WebpackOptionsApply().process(options, compiler); compiler.hooks.initialize.call(); return compiler&#125;const createMultiCompiler = (childOptions, options) =&gt; &#123; // 给每一个option创建一个compiler const compilers = childOptions.map(options =&gt; createCompiler(options)); // 创建MultiCompiler对象 const compiler = new MultiCompiler(compilers, options); // ... return compiler;&#125;; 这里注意一点：在compiler对象创建后： 逐一执行options.plugins中所有的plugin。 根据options的内容，添加webpack内置的plugin。比如EntryOptionPlugin。针对不同环境(node electron browser)会设置不同的plugin。 webpack有大量的内置plugin，这都是在WebpackOptionsApply中的process来设置的。可以说webpack的所有功能(resolve optimization module解析…)都是由相应的plugin完成的。 获得compiler对象后，下一步就时进行构建，这是通过compiler.run方法实现的。 run方法主要做了2件事： 执行compiler的hook beforeRun run readRecords。在创建compiler对象时会执行所有plugin。如果在这三个hook绑定的了事件，在此时会被执行。（这三个hook时串行执行的，代码是嵌套的） 执行compiler.compile方法进行构建 12345678910111213this.hooks.beforeRun.callAsync(this, err =&gt; &#123; if (err) return finalCallback(err); this.hooks.run.callAsync(this, err =&gt; &#123; if (err) return finalCallback(err); this.readRecords(err =&gt; &#123; if (err) return finalCallback(err); this.compile(onCompiled); &#125;); &#125;);&#125;); 创建Compilationcompilation对象属于compiler。每一次构建，compiler都会创建一个compilation对象 compiler.compile方法会真正地创建compilation对象 123456789101112131415// ./lib/Compiler.js// compileconst params = this.newCompilationParams();this.hooks.beforeCompile.callAsync(params, err =&gt; &#123; if (err) return callback(err); this.hooks.compile.call(params); // 创建compilation对象 const compilation = this.newCompilation(params); // ... // 执行compiler的各种hook // 以及执行compilation的 finish 和 seal方法&#125;); 代码很长，主要流程如下: compiler.hooks.beforeCompile 创建compilation对象。这里调用了compiler.newCompilation方法，该方法做了以下几件事 创建compilation，会先清理上一次构建的compilation对象 compiler.hooks.thisCompilation compiler.hooks.compilation compiler.hooks.make compiler.hooks.finishMake compilation.finish compilation.seal compiler.hooks.afterCompile 这些hooks都是串行执行的。afterCompile这个hook的执行表示一次构建已经完成。那么从compilation对象创建完成到afterCompile触发之前，包含了编译阶段和产出阶段 编译阶段compiler.hooks.make这个hook被触发执行，就代表了编译开始。 在compiler创建时(new WebpackOptionsApply().process(options, compiler); )，这里给compiler添加了许多并绑定了许多内置plugin。其中有一个EntryOptionsPlugin，他是用于解析入口(entry)配置。根据entry字段类型再选择不同的plugin entry为function：DynamicEntryPlugin entry不为function：EntryPlugin 编译阶段的开始就是从entry文件开始解析module。 以EntryPlugin为例，其apply方法： 12345678compiler.hooks.make.tapAsync(&quot;EntryPlugin&quot;, (compilation, callback) =&gt; &#123; const &#123; entry, options, context &#125; = this; const dep = EntryPlugin.createDependency(entry, options); compilation.addEntry(context, dep, options, err =&gt; &#123; callback(err); &#125;);&#125;); EntryPlugin在compile.make这个hook上注册了一个事件。compiler.hooks.make这个hook被触发执行时，hook上注册的事件全都会被执行。 EntryPlugin会调用compilation.addEntry方法。 接下看就看compilation的表演： addEntry添加入口文件 将资源文件转成NormalModule对象（简称module对象），一个文件(js css img)都是一个module 调用module.build方法 调用runLoaders，找到相应的loader处理该module 对于js module，会通过acorn转成AST。分析模块依赖关系，如果有依赖模块 调用compilation.addEntry（第1步） 最终获取所有module 编译阶段是一个递归的过程 每一个module build完成都会触发compilation.hooks.succeedModule，并传入当前module对象 产出阶段调用compilation.seal方法，封存文件就是处理文件生成chunk。 Seal首先触发compilation.hooks.optimizeDependencies这个hook上的所有事件。对module做一些优化操作（比如tree-shaking） 根据入口生成chunk，有几个入口就会有几个chunk。 然后就是递归分析chunk，如果有动态导入(import())就会单独拆分出chunk 这个过程还有一堆hooks，这些可以在这些hooks上做些优化操作。比如optimizeModules和optimizeChunks 生成chunck的hash 生成chunk的sourceMap AssetscreateChunkAssets生成assets ，会将生成的Assets存放到compilation.assets数组中 emitAsset将文件输出 Watch模式当调用compiler.watch，会启用watch模式。当文件发生更改是，会自动重新构建. 12345678&#123; watch(watchOptions, handler) &#123; // ... this.watching = new Watching(this, watchOptions, handler); return this.watching; &#125;&#125; watch方法创建了一个Watching实例。 1234567891011121314151617181920212223242526class Watch &#123; contstructor() &#123; // ... this._invalidate() &#125; _invalidate() &#123; // 防止重复构建 this._go() &#125; _go() &#123; // 构建逻辑 compiler.compile() // 调用compiler的compile方法进行构建 &#125; _done() &#123; // 构建完成了 // 获取构建完后的依赖 this.watch() // 监听这些依赖 &#125; watch() &#123; // 监听文件变化 this.compiler.watchFileSystem.watch() // 文件发生变化 监听的回调会被调用 this._invalidate() // 进行下一轮构建 &#125;&#125; 监听文件是通过this.compiler.watchFileSystem.watch()方法来实现的。这个watchFileSystem是在创建compiler对象时，初始化的。 创建compiler时，执行了NodeEvniromentPlugin。这个plugin会设置文件系统。将watchFleSystem设置成NodeWatchFileSystem，而其内部又会创建一个watchpack对象来监听文件变化。 123456789101112class NodeEnvironmentPlugin &#123; apply(compiler) &#123; //... compiler.inputFileSystem = new CachedInputFileSystem(fs, 60000); // ... compiler.watchFileSystem = new NodeWatchFileSystem( compiler.inputFileSystem ); // ... &#125;&#125; 值得一提的是，当文件短时间变化多次，会触发多次构建吗？ 其实是不会的，watchpack添加了防抖机制。只会触发最后一次。 总结一张图总结流程","categories":[{"name":"工程化","slug":"工程化","permalink":"https://zxffan.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"https://zxffan.github.io/tags/webpack/"},{"name":"架构","slug":"架构","permalink":"https://zxffan.github.io/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"vue2-生命周期","slug":"sourcecode/Vue2-生命周期","date":"2021-04-26T16:00:00.000Z","updated":"2021-06-29T14:07:23.038Z","comments":true,"path":"posts/bdeefbce.html","link":"","permalink":"https://zxffan.github.io/posts/bdeefbce.html","excerpt":"","text":"Vue2生命周期图 组件创建到页面渲染初始化new Vue()的执行，会创建一个组件实例（根组件）vm，然后进行各种初始化工作 合并 options，也就是初始化组件的options选项 初始化vm（组件实例）上的各个属性 初始化绑定在当前组件上的listener(v-on) 初始化render函数，在vm上绑定createElement方法 **beforeCreated**钩子调用 将inject定义为响应式 .初始化, 定义响应式数据 props methods data computed watch 初始化vm._provide属性 **creted**钩子调用 渲染如果new Vue传入了el属性，就会自动调用vm.$mount方法，渲染实例 调用mountComponent 新建Watcher，传入updateComponent逻辑 Watcher调用updateComponent逻辑 进入patch逻辑 响应式vue2的响应式涉及到三种角色——reactiveObj(响应式对象) Watcher Dep 响应式对象通过Object.defineProperty拦截getter和setter Watcher用于触发组件更新 每个响应式对象都有一个dep对象，它有一个subs的Watcher数组，用于记录依赖该响应式对象的所有watcher 当组件开始渲染时： 会创建一个Watcher对象。将组件更新的逻辑（updateComponent）记录到Watcher 将Dep.target设置为 创建的 Watcher对象 随即执行render方法，会触发响应式对象的getter。将Dep.target添加到dep.subs中，即依赖收集 在修改响应式对象，会触发setter。 执行dep.notify，触发dpe.subs中所有watcher的update方法 watcher.update()会触发updateComponent，从而使得组件更新","categories":[{"name":"源码","slug":"源码","permalink":"https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://zxffan.github.io/tags/vue/"}]},{"title":"Webpack之SplitChunks","slug":"engineering/Webpack之SplitChunks","date":"2021-04-25T16:00:00.000Z","updated":"2021-06-29T14:04:56.114Z","comments":true,"path":"posts/110bf707.html","link":"","permalink":"https://zxffan.github.io/posts/110bf707.html","excerpt":"","text":"SplitChunkssplitChunks可以指定webpack打包的拆分规则。 1234567891011121314151617181920212223242526module.exports = &#123; // ... optimization: &#123; splitChunks: &#123; chunks: &quot;async&quot;, // 三选一： &quot;initial&quot; | &quot;all&quot; | &quot;async&quot; (默认) minSize: 30000, // 最小尺寸，30K，development 下是10k，越大那么单个文件越大，chunk 数就会变少（针对于提取公共 chunk的时候，不管再大也不会把动态加载的模块合并到初始化模块中）当这个值很大的时候就不会做公共部分的抽取了 maxSize: 0, // 文件的最大尺寸，0为不限制，优先级：maxInitialRequest/maxAsyncRequests &lt; maxSize &lt; minSize minChunks: 1, // 默认1，被提取的一个模块至少需要在几个 chunk 中被引用，这个值越大，抽取出来的文件就越小 maxAsyncRequests: 5, // 在做一次按需加载的时候最多有多少个异步请求，为 1 的时候就不会抽取公共 chunk 了 maxInitialRequests: 3, // 针对一个 entry 做初始化模块分隔的时候的最大文件数，优先级高于 cacheGroup，所以为 1 的时候就不会抽取 initial common 了 automaticNameDelimiter: &quot;~&quot;, // 打包文件名分隔符 name: true, // 拆分出来文件的名字，默认为 true，表示自动生成文件名，如果设置为固定的字符串那么所有的 chunk 都会被合并成一个 cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, // 正则规则，如果符合就提取 chunk priority: -10, // 缓存组优先级，当一个模块可能属于多个 chunkGroup，这里是优先级 &#125;, default: &#123; minChunks: 2, priority: -20, // 优先级 reuseExistingChunk: true, // 如果该chunk包含的modules都已经另一个被分割的chunk中存在，那么直接引用已存在的chunk，不会再重新产生一个 &#125;, &#125;, &#125;, &#125;,&#125;; 使用动态导入import()或者requre.ensure()，就会根据 SplitChunks参数chunks有三个值——async all initial async(默认)只会将异步模块（import()导入的模块）提出出来 initial提取同步模块和异步模块。如果一个模块在moduleA中是同步导入，在moduleB中是异步导入。那么由于导入方式不同，这个模块会被抽离出不同的文件。 all提取同步模块和异步模块，无论是同步import还是异步import。都会抽离到一个文件中。all会最大程度复用文件。 maxInitialRequests和maxAsyncRequests浏览器对相同域名的并法请求是有限制的。比如chrome 限制6个相同域名的请求。如果同一时间发送10个请求。则另外4个就会被阻塞 所以，splitChunks把文件拆得太碎，反而会影响加载时间。 maxInitialRequests设置为3，表示浏览器初始最多发送3个请求。它会将入口文件拆成&lt;3份。 maxAsyncRequests是用来限制异步模块并行最大请求数的。 前者是限定入口的文件的拆分，后者是限定异步模块的拆分 minSize和maxSizeminSize：满足拆分的最小体积（单位字节）。大于这个大小并满足拆分规则就会被拆分 maxSize：默认为0表示不作限制。如果非0。待拆分模块大小大于maxSize时就会拆分 规则优先级：maxInitialRequest/maxAsyncRequests &lt; maxSize &lt; minSize cacheGroups这是splitChunks最重要的部分。它定义了拆分规则。 123456cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, // 正则规则，如果符合就提取 chunk priority: -10, // 缓存组优先级，当一个模块可能属于多个 chunkGroup，这里是优先级 &#125;,&#125; test表示匹配规则，可以是一个正则。/[\\\\/]node_modules[\\\\/]表示匹配/node_modules/或着\\node_modules\\ priority：缓存组优先级，当一个模块可能属于多个 chunkGroup时，取优先级高的 reuseExistingChunk: true表示复用其他chunk内已拥有的模块 当chunks引用了已经存在的被抽离的chunks时不会新创建一个chunk而是复用chunk。 其它属性：chunks maxInitialRequests maxAsyncRequests minSize……. cacheGroups下找不到chunks等属性，就会去splitChunks中的配置。","categories":[{"name":"工程化","slug":"工程化","permalink":"https://zxffan.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"https://zxffan.github.io/tags/webpack/"},{"name":"架构","slug":"架构","permalink":"https://zxffan.github.io/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"web-vitals源码解读","slug":"sourcecode/webVitals源码解读","date":"2021-04-25T16:00:00.000Z","updated":"2021-06-29T14:07:46.726Z","comments":true,"path":"posts/473044000000.html","link":"","permalink":"https://zxffan.github.io/posts/473044000000.html","excerpt":"","text":"web-vitals简介web-vitals是google开源的一个测量web性能指标的工具。体积才1KB，它可以用来测量CLS、FID、LCP、FCP、TTFB。 可通过npm来安装npm install web-vitals 使用也十分简单 12345import &#123;getLCP, getFID, getCLS&#125; from &#x27;web-vitals&#x27;;getCLS(console.log);getFID(console.log);getLCP(console.log); 源码结构web-vitals整个项目不是很复杂，目录结构如下 12345678910111213141516├─.git├─docs├─src # 源码├─test # 测试代码├─.eslintrc ├─.gitignore├─base.d.ts├─base.js├─CHANGELOG.md├─LICENSE # 开源协议├─package-lock.json├─package.json├─README.md├─rollup.config.js # rollup构建配置├─tsconfig.json # ts配置├─wdio.conf.js # e2e测试配置 代码规范Eslintweb-vitals通过配置eslint来约定代码规范。通常，eslint配置文件位于根目录下。这样对于整个项目都通用一套eslint配置。这往往是不满足需求的。可能src目录需要一套eslint配置，而test目录有需要另一套eslint配置。web-vitals是通过eslintrc下的overrides字段配置的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&#123; &quot;parser&quot;: &quot;babel-eslint&quot;, &quot;env&quot;: &#123; &quot;browser&quot;: true, &quot;es6&quot;: true, &quot;node&quot;: true, &quot;mocha&quot;: true &#125;, &quot;parserOptions&quot;: &#123; &quot;sourceType&quot;: &quot;module&quot; &#125;, &quot;overrides&quot;: [ &#123; &quot;files&quot;: &quot;wdio.conf.js&quot;, &quot;extends&quot;: [ &quot;eslint:recommended&quot;, &quot;google&quot; ], &quot;rules&quot;: &#123; &quot;max-len&quot;: &quot;off&quot; &#125; &#125;, &#123; &quot;files&quot;: [&quot;test/e2e/*.js&quot;], &quot;globals&quot;: &#123; &quot;$&quot;: false, &quot;browser&quot;: false &#125;, &quot;extends&quot;: [ &quot;eslint:recommended&quot;, &quot;google&quot; ], &quot;rules&quot;: &#123; &quot;no-invalid-this&quot;: &quot;off&quot;, &quot;max-len&quot;: [2, &#123; &quot;ignorePattern&quot;: &quot;^\\\\s*import|= require\\\\(|^\\\\s*it\\\\(|^\\\\s*describe\\\\(&quot;, &quot;ignoreUrls&quot;: true &#125;], &#125; &#125;, &#123; &quot;files&quot;: &quot;src/**/*.ts&quot;, &quot;parser&quot;: &quot;@typescript-eslint/parser&quot;, &quot;extends&quot;: [ &quot;plugin:@typescript-eslint/recommended&quot; ], &quot;rules&quot;: &#123; &quot;@typescript-eslint/no-non-null-assertion&quot;: &quot;off&quot;, &quot;@typescript-eslint/no-use-before-define&quot;: &quot;off&quot;, &quot;@typescript-eslint/explicit-function-return-type&quot;: &quot;off&quot;, &quot;@typescript-eslint/explicit-module-boundary-types&quot;: &quot;off&quot;, &quot;@typescript-eslint/ban-ts-comment&quot;: &quot;off&quot;, &quot;@typescript-eslint/camelcase&quot;: &quot;off&quot;, &quot;node/no-missing-import&quot;: &quot;off&quot;, &quot;node/no-unsupported-features/es-syntax&quot;: &quot;off&quot;, &quot;node/no-missing-require&quot;: &quot;off&quot;, &quot;node/shebang&quot;: &quot;off&quot;, &quot;no-dupe-class-members&quot;: &quot;off&quot; &#125;, &quot;parserOptions&quot;: &#123; &quot;ecmaVersion&quot;: 2018, &quot;sourceType&quot;: &quot;module&quot; &#125; &#125; ]&#125; overrides字段对应的值是一个数组，该数组中的每个元素都是一条新的eslint规则，并覆盖全局配置 huskyhusky是一个git钩子工具，package.json文件下有个husky字段 1234567891011&#123; &quot;scripts&quot;: &#123; &quot;lint&quot;: &quot;eslint \\&quot;*.js\\&quot; \\&quot;src/**/*.ts\\&quot; \\&quot;test/**/*.js\\&quot;&quot;, &quot;lint:fix&quot;: &quot;eslint --fix \\&quot;*.js\\&quot; \\&quot;src/**/*.ts\\&quot; \\&quot;test/**/*.js\\&quot;&quot;, &#125;, &quot;husky&quot;: &#123; &quot;hooks&quot;: &#123; &quot;pre-commit&quot;: &quot;npm run lint&quot; &#125; &#125;,&#125; 它的作用是，在每次git commit时，触发钩子并执行npm run lint，也就是进行Eslint检查。如果没有通过eslint，就会commit失败。 @rollup/plugin-eslintweb-vitals的rollup并没有配置@rollup/plugin-eslint。如果加上这个插件，会在构建时进行eslint检查，如果没有通过eslint，就会构建失败并给出相应的修复提示。 构建配置web-vitals是通过rollup进行构建打包的。其配置也十分简单 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// rollup.config.jsimport replace from &#x27;@rollup/plugin-replace&#x27;;import &#123;terser&#125; from &#x27;rollup-plugin-terser&#x27;;import babel from &#x27;rollup-plugin-babel&#x27;;const configurePlugins = (&#123;module, polyfill = false&#125;) =&gt; &#123; return [ babel(&#123; presets: [[&#x27;@babel/preset-env&#x27;, &#123; targets: &#123; browsers: [&#x27;ie 11&#x27;], &#125;, &#125;]], &#125;), terser(&#123; module, mangle: true, compress: true, &#125;), replace(&#123; &#x27;self.__WEB_VITALS_POLYFILL__&#x27;: polyfill, &#125;) ]&#125;const configs = [ &#123; input: &#x27;dist/modules/index.js&#x27;, output: &#123; format: &#x27;esm&#x27;, file: &#x27;./dist/web-vitals.js&#x27;, &#125;, plugins: configurePlugins(&#123;module: true, polyfill: false&#125;), &#125;, &#123; input: &#x27;dist/modules/index.js&#x27;, output: &#123; format: &#x27;umd&#x27;, file: `./dist/web-vitals.umd.js`, name: &#x27;webVitals&#x27;, &#125;, plugins: configurePlugins(&#123;module: false, polyfill: false&#125;), &#125;, &#123; input: &#x27;dist/modules/index.js&#x27;, output: &#123; format: &#x27;esm&#x27;, file: &#x27;./dist/web-vitals.base.js&#x27;, &#125;, plugins: configurePlugins(&#123;module: true, polyfill: true&#125;), &#125;, &#123; input: &#x27;dist/modules/index.js&#x27;, output: &#123; format: &#x27;umd&#x27;, file: `./dist/web-vitals.base.umd.js`, name: &#x27;webVitals&#x27;, extend: true, &#125;, plugins: configurePlugins(&#123;module: false, polyfill: true&#125;), &#125;, &#123; input: &#x27;dist/modules/polyfill.js&#x27;, output: &#123; format: &#x27;iife&#x27;, file: &#x27;./dist/polyfill.js&#x27;, name: &#x27;webVitals&#x27;, strict: false, &#125;, plugins: configurePlugins(&#123;module: false&#125;), &#125;,];export default configs; 不同的产出文件导出的config是一个数组。每个数组元素是一份rollup配置 产出文件名 module polyfill web-vitals.js esm 不含 web-vitals.umd.js umd 不含 web-vitals.base.js esm 含 web-vitals.base.umd.js umd 含 polyfill.js iife - esm：即 ES Module，在代码中直接import使用 iife：立即执行函数，就是(function() &#123;&#125;)(window)这种形式 umd：本质上也是iife，但是它将待执行的函数作为iife的参数传入 12345678var a = 2;(function IIFE( def ) &#123; def( window );&#125;)(function def( global ) &#123; var a = 3; console.log( a ); // 3 console.log( global.a ); // 2&#125;); iife和umd都是直接在浏览器中使用了 tree-shakingrolup使用了@rollup/plugin-replace，用于替换一些常量 123replace(&#123; &#x27;self.__WEB_VITALS_POLYFILL__&#x27;: polyfill,&#125;) 这会将代码中所有出现的self.__WEB_VITALS_POLYFILL__的地方替换成polyfill变量的对应的值（true或false）。在代码中出现大量的self.__WEB_VITALS_POLYFILL__ 123456789101112// src/lib/getFirstHidden.ts // function getFirstHiddenif (self.__WEB_VITALS_POLYFILL__) &#123; firstHiddenTime = self.webVitals.firstHiddenTime; if (firstHiddenTime === Infinity) &#123; trackChanges(); &#125;&#125; else &#123; firstHiddenTime = initHiddenTime(); trackChanges();&#125; 如果self.__WEB_VITALS_POLYFILL__是true，rollup在构建时，就会吧else的逻辑删掉。反之，会把if的逻辑给删掉。这样就实现了Tree Shaking——删除多余代码。 TypeScriptweb-vitals的源码是使用TS编写的，最终需要生成js文件。 web-vitals的构建过程： 先通过tsc生成js文件和类型声明文件。 再通过rollup进行对js文件打包构建 类型声明需要再package.json中typings字段指定声明文件的位置 1234567891011&#123; &quot;main&quot;: &quot;dist/web-vitals.umd.js&quot;, &quot;module&quot;: &quot;dist/web-vitals.js&quot;, &quot;typings&quot;: &quot;dist/modules/index.d.ts&quot;, &quot;files&quot;: [ &quot;base.js&quot;, &quot;base.d.ts&quot;, &quot;dist&quot;, &quot;src&quot; ],&#125; main: 定义了 npm 包的入口文件，browser 环境和 node 环境均可使用 module: 定义 npm 包的 ESM 规范的入口文件，browser 环境和 node 环境均可使用 好有个browser : 定义 npm 包在 browser 环境下的入口文件 files：当npm publish是，指定需要上传的文件。 开源协议web-vitals采用Apache-2.0开源协议。该协议允许开发者修改代码，并且商业发布。但是对于改动部分必须提供一份声明。 测试web-vitals的测试需要真实的浏览器环境，即需要端到端测试（e2e test）。项目通过[wdio（webDriver.IO）](Getting Started | WebdriverIO)来实现的。 1234567&#123; &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;npm-run-all build -p -r test:*&quot;, &quot;test:e2e&quot;: &quot;wdio wdio.conf.js&quot;, &quot;test:server&quot;: &quot;node test/server.js&quot;, &#125;&#125; 测试流程当执行npm run test时 先构建打包项目 启动一个HTTP服务，用于处理浏览器的资源请求 启动wdio测试 当执行test/e2e目录下的测试用例时，例如getLCP-test.js 12345678910111213141516171819it(&#x27;reports the correct value on hidden (reportAllChanges === false)&#x27;, async function() &#123; // 浏览器不支持就跳过这条用例 if (!browserSupportsLCP) this.skip(); // 打开 /test/lcp这个网页，这是测试网页 await browser.url(&#x27;/test/lcp&#x27;); // 等待所有图片加载完成 await imagesPainted(); // 跳转到空白页，触发上一个页面的 hide状态 await browser.url(&#x27;about:blank&#x27;); // 检测是beacon.log中是否有数据，参数为数据条数 await beaconCountIs(1); // 对 beacon数据进行断言 assertStandardReportsAreCorrect(await getBeacons());&#125;); 当输入browser.url(&#39;/test/lcp&#39;)其实访问的地址是http://localhost:9090/test/lcp(在wdio.config.js中配置的)。这条请求会发送给本地的HTTP服务上。 1234567891011// src/test/server.jsapp.get(&#x27;/test/:view&#x27;, function(req, res) &#123; const data = &#123; ...req.query, modulePath: `/dist/web-vitals$&#123; req.query.polyfill ? `.base` : ``&#125;.js`, webVitalsPolyfill: fs.readFileSync(&#x27;./dist/polyfill.js&#x27;, &#x27;utf-8&#x27;), &#125; res.send(nunjucks.render(`$&#123;req.params.view&#125;.njk`, data));&#125;); nunjucks是一个模板引擎。data数据会插入到模板引擎内。当访问/test/lcp时，会将解析lcp.njk并将html返回给浏览器。 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!-- src/test/view/lcp.njk --&gt;&#123;% extends &#x27;layout.njk&#x27; %&#125;&#123;% block content %&#125; &lt;h1&gt;LCP Test&lt;/h1&gt; &lt;p&gt; &#123;% if not imgDelay %&#125; &#123;% set imgDelay = 500 %&#125; &#123;% endif %&#125; &lt;img &#123;% if imgHidden %&#125;hidden&#123;% endif %&#125; src=&quot;/test/img/square.png?delay=&#123;&#123; imgDelay &#125;&#125;&quot;&gt; &lt;/p&gt; &lt;p&gt;Text below the image&lt;/p&gt; &lt;p&gt;&lt;a id=&quot;navigate-away&quot; href=&quot;https://example.com&quot;&gt;Navigate away&lt;/a&gt;&lt;/p&gt; &lt;!-- Include a tall element to ensure scrolling is possible. --&gt; &lt;div style=&quot;height: 100vh&quot;&gt;&lt;/div&gt; &lt;footer&gt;Text below the full-height element.&lt;/footer&gt; &lt;script type=&quot;module&quot;&gt; import &#123;getLCP&#125; from &#x27;&#123;&#123; modulePath &#125;&#125;&#x27;; getLCP((lcp) =&gt; &#123; // Log for easier manual testing. console.log(lcp); // Elements can&#x27;t be serialized, so we convert first. lcp = &#123; ...lcp, entries: lcp.entries.map((e) =&gt; (&#123; element: e.element.nodeName.toLowerCase(), size: e.size, startTime: e.startTime, &#125;)), &#125;; // 发送统计数据 navigator.sendBeacon(`/collect`, JSON.stringify(lcp)); &#125;, self.__reportAllChanges); &lt;/script&gt;&#123;% endblock %&#125; html中的最后一步调用了 navigator.sendBeacon(&quot;/collect&quot;, JSON.stringify(lcp));，/collect这个请求也是发到本地的HTTP服务。服务端会将数据写入到src/test/beacons.log中。 sendBeaconnavigator.sendBeacon是专门用来发送异步统计数据的API。 有一种需求：当页面跳转或关闭时，我们需要将当前页面的一些统计数据发送到服务端。往往这些数据不能提前发送。如果使用异步XMLHttpRequest的话，浏览器可能会忽略这个请求。如果使用同步XMLHttpRequest的话，会影响下个页面的加载速度。 使用navigator.sendBeacon，会发送一个异步请求，并且不会被浏览器忽略。 12345document.addEventListener(&#x27;visibilitychange&#x27;, function logData() &#123; if (document.visibilityState === &#x27;hidden&#x27;) &#123; navigator.sendBeacon(&#x27;/log&#x27;, analyticsData); &#125;&#125;); 判断页面关闭与否，建议使用visibilitychange事件 safari需要使用pagehide事件 代码实现PerformanceObserver性能观察者(PerformanceObserver)用于获取性能数据。 new PerformanceObserver(callback); 接受一个callback作为参数 observer方法用于注册性能条目类型，type指所要观测的性能条目类型，取值情况通过PerformanceObserver.supportedEntryTypes属性查看。 [&quot;element&quot;, &quot;event&quot;, &quot;first-input&quot;, &quot;largest-contentful-paint&quot;, &quot;layout-shift&quot;, &quot;longtask&quot;, &quot;mark&quot;, &quot;measure&quot;, &quot;navigation&quot;, &quot;paint&quot;, &quot;resource&quot;] 其中: largest-contentful-paint：LCP layout-shift：CLS first-input：FID 12345678910// 获取lcp时间const callback = (entryList) =&gt; &#123; for (const entry of entryList.getEntries()) &#123; console.log(&#x27;LCP candidate:&#x27;, entry.startTime, entry); &#125;&#125;const observer = new PerformanceObserver(callback)observer.observe(&#123;type: &#x27;largest-contentful-paint&#x27;, buffered: true&#125;); LCP、FID、CLSweb-vitals中的LCP、FID和CLS都是通过PerformanceObserver来实现的。 以LCP为例： getLCP函数位于src/getLCP.ts文件中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556export const getLCP = (onReport: ReportHandler, reportAllChanges?: boolean) =&gt; &#123; // 1 获取 第一次页面处于hidden状态的时间 const firstHidden = getFirstHidden(); let metric = initMetric(&#x27;LCP&#x27;); let report: ReturnType&lt;typeof bindReporter&gt;; // 2. PerformanceObserver const entryHandler = (entry: PerformanceEntry) =&gt; &#123; const value = entry.startTime; // 过滤掉切换pagehide后的 性能数据 if (value &lt; firstHidden.timeStamp) &#123; metric.value = value; metric.entries.push(entry); &#125; report(); &#125;; const po = observe(&#x27;largest-contentful-paint&#x27;, entryHandler); if (po) &#123; report = bindReporter(onReport, metric, reportAllChanges); const stopListening = () =&gt; &#123; if (!finalMetrics.has(metric)) &#123; po.takeRecords().map(entryHandler as PerformanceEntryHandler); po.disconnect(); finalMetrics.add(metric); report(); &#125; &#125; // 当用户点击页面时，立即触发 report [&#x27;keydown&#x27;, &#x27;click&#x27;].forEach((type) =&gt; &#123; addEventListener(type, stopListening, &#123;once: true, capture: true&#125;); &#125;); onHidden(stopListening, true); // 当pageshow时，报告metric onBFCacheRestore((event) =&gt; &#123; metric = initMetric(&#x27;LCP&#x27;); report = bindReporter(onReport, metric, reportAllChanges); requestAnimationFrame(() =&gt; &#123; requestAnimationFrame(() =&gt; &#123; metric.value = performance.now() - event.timeStamp; finalMetrics.add(metric); report(); &#125;); &#125;); &#125;); &#125;&#125;; TTFBTTFB时间直接取performance.responseStart","categories":[{"name":"源码","slug":"源码","permalink":"https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"web-vitals","slug":"web-vitals","permalink":"https://zxffan.github.io/tags/web-vitals/"}]},{"title":"知识串联：JavaScript执行机制","slug":"JavaScript/知识串联：JavaScript执行机制","date":"2021-04-22T16:00:00.000Z","updated":"2021-06-29T14:05:26.769Z","comments":true,"path":"posts/1b8392cc.html","link":"","permalink":"https://zxffan.github.io/posts/1b8392cc.html","excerpt":"","text":"这篇文章将梳理JavaScript的执行机制，并且串联众多知识点：作用域、作用域链、闭包、变量提升、函数提升、this指向 JavaScript 执行的阶段在 V8 引擎中 JavaScript 代码的运行过程主要分成三个阶段。 语法分析阶段。 该阶段会对代码进行语法分析，检查是否有语法错误（SyntaxError），如果发现语法错误，会在控制台抛出异常并终止执行。 编译阶段。 该阶段会进行全局执行上下文（Execution Context）的创建，这个过程也被称为预解析阶段。 执行阶段。 将编译阶段中创建的执行上下文压入执行栈，并成为正在运行的执行上下文，代码执行结束后，将其出栈。在执行过程中，又可能会产生新的执行上下文（比如调用了函数）。再将新的执行上下文入栈，执行完出栈 三种执行上下文执行上下文是对执行环境的抽象，它代表JavaScript执行时当前的执行环境，用于。JavaScript中一共有三种执行上下文 全局执行上下文：有且仅有一个 函数执行上下文 eval执行上下文：不讨论 如下代码: 1234567const name = &quot;zxfan&quot;function sayName() &#123; console.log(name)&#125;sayName() 编译时，首先创建一个全局执行上下文GlobalContext，并将其放入执行栈 执行时，执行栈栈顶的执行上下文为当前正在执行的执行上下文，当执行到sayName函数时，又会创建一个函数执行上下文FunctionContext，并将其入栈。当函数执行上下文执行完毕，出栈。全局上下文也执行完毕，出栈。 全局执行上下文是编译时被创建的 函数执行上下文是执行时被创建的 执行栈执行栈是用来存放执行上下文的。 以函数为例，函数执行的时候创建函数执行上下文，并将其入栈，当函数执行完成后再出栈。全局执行上下文第一个入栈最后一个出栈。 执行上下文做了什么？执行上下文被创建时，做了三件事： 确定this的指向 创建环境记录 创建词法环境(LexicalEnvironment) 创建变量环境(VariableEnvironment) this的指向this的取值取决于具体的场景： 全局执行上下文中：this取全局对象（浏览器是window对象，nodejs是global对象） 函数执行上下文中： 构造函数中：指向创建的实例对象 对象方法：this指向这个对象 箭头函数：外层执行上下文的this call apply bind：可以指定this 其它情况：this为undefined（严格模式下） 环境记录(Environment Record)基于JavaScript这种嵌套的代码结构，环境记录用来记录特定的标识符和代码中所定义的变量和函数之间的关系。 换句话说，环境记录就是记录一堆标识符，这些标识符指向具体代码中的数据。 123456const name = &quot;zxfan&quot;var age = 18function sayName() &#123; console.log(name)&#125; 其环境记录 12345Environment Record &#123; name: &lt;uninitialized&gt; // 代码执行完后 name: &lt;&quot;zxfan&quot;&gt; age: &lt;18&gt; // var 具有变量提升，所以这里不是uninitialized sayName: &lt;function&gt; // function有函数提升，所以这里不是uninitialized&#125; 环境记录分类三种类型（声明环境记录又分为两种）： 声明环境记录： 包含var let const class function import声明的变量的标识符。 函数环境记录： function 模块环境记录：import 对象环境记录：为对象创建一个环境记录，它有一个**关联的绑定对象[[BindingObject]]**。比如全局执行上下文会创建一个对象环境记录，其关联绑定的对象是全局对象（window或global） 全局环境记录：最外层环境记录，包含声明环境记录和对象环境记录 词法环境和变量环境本质上都是环境记录，这么做是为了单独区分var 词法环境（作用域）词法环境可以理解为作用域，从词法环境的角度能更好地理解作用域。词法环境有两个成员： 环境记录（Environment Record）：用于记录自身词法环境中的变量对象。 外部词法环境引用（Outer Lexical Environment）：记录外层词法环境的引用。 环境记录词法环境的环境记录，会保存函数声明和变量声明(let和const声明的变量)，如 123456function sayFullName() &#123; const firstName = &quot;Donald&quot; const lastName = &quot;Trump&quot; console.log(firstName, lastName)&#125;sayFullName() sayFullNmae的词法环境 12345678LexicalEnciroment &#123; Enviroment Record &#123; firstName: &lt;uninitialize&gt; lastName: &lt;uninitialize&gt; arguments: &lt;&#123;&#125;&gt; &#125; outer: &lt;Global or outer function environment reference&gt; &#125; 注意：let和const定义的变量初始都是uninitialize。当代码执行后才会赋值。 外部词法环境引用（作用域链）任何一个词法环境（全局词法环境除外）都有一个指向外层词法环境的引用。这构成了词法环境链即作用域链。当访问一个变量时，先会在当前词法环境中寻找，找不到就去外部词法环境中寻找。就这样，一直找到全局词法环境。 变量环境变量环境和词法环境的结构一致，区别是其环境记录所记录的数据不同。 语法环境的环境记录，是记录var声明。 环境记录 词法环境 作用域 其实都是一个概念，这么区分是为了针对不同场景方便理解。 常见问题解释作用域与作用域链JS的作用域时词法作用域，有词法结构决定。js代码编译时创建全局执行上下文，执行上下文又会创建当前环境的环境记录（分为词法环境和变量环境）。当执行js代码时（比如调用一个函数），又会创建函数执行上下文。随之函数环境的环境就又会创建。 每个环境记录都有个outer引用，指向外层环境记录。外层再指向外层，一直到最外层。这便构成了作用域链。 闭包解释闭包就是解释作用域和垃圾回收机制 闭包 是指内部函数总是可以访问其所在的外部函数中声明的变量和参数，即使在其外部函数被返回（寿命终结）了之后。 正常情况下，代码执行完毕，其相应的执行上下文出栈，相应的内存空间会被回收。然而，闭包情况下，内层词法环境（作用域）可以访问到，所以外层词法环境不会被回收，仍然可以访问到，但仅限在内层词法环境访问。 变量提升和函数提升环境记录创建时，会记录当前环境下所有变量，遇到： var变量声明：此时会给变量分配内存，并将其初始化为undefined（该过程只进行定义声明，执行阶段才执行赋值语句）。 函数声明：此时会在内存里创建函数对象，并且直接初始化为该函数对象。 this指向this指向是在执行上下文创建时才确定的，具体指向谁取决于具体场景。上文已讨论。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/tags/JavaScript/"}]},{"title":"XSS攻击与防御","slug":"experience/XSS攻击与防御","date":"2021-04-15T16:00:00.000Z","updated":"2021-06-29T14:02:58.235Z","comments":true,"path":"posts/df6ed6ff.html","link":"","permalink":"https://zxffan.github.io/posts/df6ed6ff.html","excerpt":"","text":"xss(cross-site script)指网站对用户输入数据未做有效过滤，攻击者可以将恶意脚本注入网站页面中，达到执行恶意代码的目的 攻击者只需要诱使受害者打开特定的网址，就可以在受害者的浏览器中执行被注入的恶意代码，从而窃取用户身份，执行一些敏感操作 XSS攻击类型XSS攻击可以分成三种类型： 反射型XSS 存储型XSS DOM型XSS 反射型反射型指的是将攻击代码存放在URL参数中，例如http://localhost/home?name=&lt;script&gt;alert(1)&lt;/script&gt;。 如果服务端直接去url中的name参数，并当作html返回给客户端。攻击代码就会执行。 存储型存储型是指将恶意代码存储到服务器上，只要诱使受害者访问被插入恶意代码的页面即可触发。存储型 XSS 经常出现在一些可以发表评论的地方，如帖子、博客 当用户在评论中输入一段攻击代码，网站又没有过滤。这段代码会存储到数据库中。当其它用户访问评论时，这段攻击代码被当作html内容输出就会引发攻击代码的执行 DOM型前两种都是服务端的XSS，DOM型是客户端的XSS JavaScript 能够操作DOM。通过JavaScript控制获取源数据（内含攻击代码），又未进行处理。直接当作HTML输出（innerHTML）或脚本执行 就会发生DOM型XSS攻击 常见的源数据有：document location localStorage sessionStorage等 常见的触发攻击的点：document.write eval innerHTML a的href属性等 XSS常见的攻击方式窃取cookie许多网站都使用cookie来存放用户登陆信息。 攻击者利用xss漏洞来注入脚本。document.cookie就可以获取到cookie。然后再将获取到的cookie上报。之后就可以本地修改 Cookie 来登录受害者的账号 蠕虫攻击以微博XSS蠕虫攻击为例： 利用 XSS 漏洞插入恶意 JS 代码； 利用 XMLHttpRequest 发送请求去发表微博、关注用户、获取关注者列表并向其发送私信； 微博消息和私信都包含有恶意攻击链接，等于实现了攻击代码的自我复制和传播。 获取用户键盘记录1234keys = &quot;&quot;document.onkeypress = function()&#123; keys += String.fromCharCode(window.event.keyCode);&#125; 获取剪贴板内容1234document.addEventListener(&#x27;paste&#x27;, function (evt) &#123; clipdata = evt.clipboardData || window.clipboardData; console.log(clipdata.getData(&#x27;text/plain&#x27;));&#125;); 钓鱼欺骗用户输入账号、密码弹个弹窗，让用户输入账号密码 XSS漏洞挖掘收集用例人工测试的主要思路就是在一切可输入数据的地方输入“XSS payload”（测试用例），这些地方包括所有的 GET、POST、Cookie、HTTP 头。提交数据之后，看网站的输出是否解析了前面输入的 XSS payload。 我常用的 XSS payload 有以下几个。搜索“XSS cheat sheet”，也可以找到很多这种测试用例。 Cross-site scripting (XSS) cheat sheet XSS Filter Evasion Cheat Sheet HTML5 Security Cheatsheet 测试这一步可以手动测试也可以采用自动测试工具。 手动：可以先一次性批量输入测试，如果无效，再输入一些特殊字符看过滤情况，根据返回数据作相应的调整测试。 自动：XSStrike，它内置了很多测试用例，也可以添加自定义测试用例 XSS防御做好检查输入检查检查攻击者所有可能的输入的地方 URL参数 （富）文本框 接口返回的数据 服务端也需要进行检查，前端是可以绕过去的 输出检查从前端角度来看，有两个地方可能导致恶意代码执行——HTML和JavaScript HTML：innerHTML outerHTML document.write() v-html danderousSetInnerHTML 将原数据当作HTML输出，极容易导致XSS攻击。尽量避免这么做，使用textContent来代替。如果必须输出（如评论内容），需要进行转义。通常使用白名单的方式进行转义。 xss是npm上的一个不错的HTML转义库 JavaScript： 内联事件监听器：location onclick onerror onload onmousemove等等等 a标签的href属性使用伪协议：&lt;a href=&quot;javascript:alert(&#39;attack&#39;)&quot; /&gt; eval setTimeout setInterval都能够把字符串当作js执行 这些api的不恰当使用会导致XSS攻击，所以使用时要格外注意。好在它们大多都有可替代方案。 HttpOnly禁止cookie访问如果给某个 cookie 设置了 HttpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全 1Set-Cookie: Name=Value; expires=Wednesday, 01-May-2014 12:45:10 GMT; HttpOnly cookie由服务端创建返回给浏览器的（响应头：Set-Cookie）。之后的请求会自动携带cookie。默认情况下，它随着seesion的结束而结束。 能不使用cookie就别使用了 CSP 内容安全策略内容安全策略（Content Security Policy，CSP）也是减少 XSS 攻击的一种方式 ，是浏览器提供一种防御机制。它采用的是白名单机制，告诉浏览器可以加载和执行哪些外部资源，这样就能防止被一些第三方恶意脚本注入执行。 开启 CSP 有两种方式： 通过 HTTP 头信息的 Content-Security-Policy 的字段：(在返回html文件的请求的响应头上加) 1Content-Security-Policy: script-src &#x27;self&#x27;; object-src &#x27;none&#x27;;style-src cdn.example.org third-party.org; child-src https:（2）通过网页的&lt;meta&gt;标签设置： 通过网页的&lt;meta&gt;标签设置 1234&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#x27;self&#x27;; object-src &#x27;none&#x27;; style-src cdn.example.org third-party.org; child-src https:&quot;/&gt; 如何指定csp：指令 策略 指令字段含义： 指令 策略示例 含义 default-src &#39;self&#39; www.aaa.com 默认资源加载策略，没有指定策略的指令使用本策略 script-src &#39;selft&#39; js.a.com 针对js文件的策略 style-src &#39;selft&#39; css.a.com 针对css文件的策略 img-src &#39;selft&#39; img.a.com 针对img图片资源的策略 connect-src &#39;selft&#39; 针对ajax、websocket的策略，不允许会返回400 font-src font.a.com 针对字体的加载策略 media-src media.a.com 针对video和audio引入资源的策略 frame-src &#39;self&#39; 针对frame的加载策略 sandbox allow-forms 对请求资源启用sandbox report-uri /report-uri 告知浏览器，当请求资源不被策略允许时，往那个接口提交信息 指令值字段含义： none 表示不执行任何匹配。 self表示与当前来源（而不是其子域）匹配。 unsafe-inline表示允许使用内联 JavaScript 和 CSS。 unsafe-eval 表示允许使用类似 eval 的 text-to-JavaScript 机制。 www.aasd.com允许加载指定域名的资源","categories":[{"name":"experience","slug":"experience","permalink":"https://zxffan.github.io/categories/experience/"}],"tags":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://zxffan.github.io/tags/FrontEnd/"},{"name":"安全","slug":"安全","permalink":"https://zxffan.github.io/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"排序问题梳理","slug":"Algorithm/排序问题梳理","date":"2021-04-14T16:00:00.000Z","updated":"2021-06-29T14:03:47.578Z","comments":true,"path":"posts/88f2a5b3.html","link":"","permalink":"https://zxffan.github.io/posts/88f2a5b3.html","excerpt":"","text":"归并排序数组的归并排序912. 排序数组 归并排序类似二叉树的后序遍历，思想也一致：利用子树的信息推算出整棵树的信息 记忆： 将list划分成两部分， 后序遍历 合并两个有序list 12345678910111213141516171819202122232425262728293031323334353637function sortArray(nums: number[], low = 0, high = nums.length - 1): number[] &#123; // 后序遍历 if (low &lt; high) &#123; // 1. 划分 const mid = low + ((high - low) &gt;&gt; 1); // 2.后续遍历 sortArray(nums, low, mid); sortArray(nums, mid + 1, high); // 3. 合并两个有序list merge(nums, low, mid, high); &#125; return nums;&#125;// 合并两个有序数组// 数组A： nums[low ... mid]// 数组B：nums[mid+1 ... high]function merge(nums: number[], low: number, mid: number, high: number) &#123; const store: number[] = []; // 两个数组的起始索引 let i = low; let j = mid + 1; while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (nums[i] &lt; nums[j]) store.push(nums[i++]); else store.push(nums[j++]); &#125; while (i &lt;= mid) store.push(nums[i++]); while (j &lt;= high) store.push(nums[j++]); store.forEach((num) =&gt; (nums[low++] = num));&#125; 时间复杂度 O(nlgn)，空间复杂度 O(n) 链表的归并排序148. 排序链表 思路都一样，同样的三步 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152function sortList(head: ListNode | null): ListNode | null &#123; if (head === null || head.next === null) return head; const dummy = new ListNode(); // 1.划分 const [back, front] = divide(head); // 2.后续遍历 const left = sortList(back); const right = sortList(front); // 3.合并两个有序链表 dummy.next = merge(left, right); return dummy.next;&#125;// 将链表划分成两部分function divide(head: ListNode) &#123; let back = head; let front = head; while (front.next) &#123; front = front.next; if (front.next === null) break; front = front.next; back = back; &#125; const result = [head, back.next!]; back.next = null; return result;&#125;// 合并两个有序列表 l1 l2function merge(l1: ListNode | null, l2: ListNode | null) &#123; const dummy = new ListNode(); let tail = dummy; while (l1 &amp;&amp; l2) &#123; if (l1.val &lt; l2.val) &#123; tail.next = l1; l1 = l1.next; &#125; else &#123; tail.next = l2; l2 = l2.next; &#125; tail = tail.next; &#125; if (l1) tail.next = l1; if (l2) tail.next = l2; return dummy.next;&#125; 数组中的逆序对剑指 Offer 51. 数组中的逆序对 这道题也是利用归并排序中的分治思想。现将数组不断划分，然后合并两个有序数组a[low...mid]和a[mid+1...high]，循环比较a[i]和a[j]的大小 如果a[j]小，即a[i...mid]所有元素都比a[j]大，也就是说它们构成了逆序对。逆序对的数量加上mid-i+1 如果a[i]小，无需处理 右侧较小元素个数315. 计算右侧小于当前元素的个数 快速排序123456789101112131415161718192021function sortArray(nums: number[], low = 0, high = nums.length - 1): number[] &#123; if (low &lt; high) &#123; const index = partition(nums, low, high); sortArray(nums, low, index - 1); sortArray(nums, index + 1, high); &#125; return nums;&#125;// 划分操作function partition(nums: number[], low: number, high: number) &#123; const target = nums[low]; while (low &lt; high) &#123; while (low &lt; high &amp;&amp; nums[high] &gt;= target) high--; nums[low] = nums[high]; while (low &lt; high &amp;&amp; nums[low] &lt;= target) low++; nums[high] = nums[low]; &#125; nums[low] = target; return low;&#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/categories/Algorithm/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://zxffan.github.io/tags/TypeScript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/tags/Algorithm/"}]},{"title":"队列问题梳理","slug":"Algorithm/队列问题梳理","date":"2021-04-13T16:00:00.000Z","updated":"2021-06-29T14:03:36.780Z","comments":true,"path":"posts/631e9859.html","link":"","permalink":"https://zxffan.github.io/posts/631e9859.html","excerpt":"","text":"BFS 广度优先遍历BFS、广度优先、层序遍历都是一回事。需要通过队列来实现 队列实现BFS12345678910111213141516171819202122232425262728/** * Definition for a binary tree node. * class TreeNode &#123; * val: number * left: TreeNode | null * right: TreeNode | null * constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; * &#125; */function levelOrder(root: TreeNode | null): number[][] &#123; const queue: TreeNode[] = [root] const ans = [] if (root === null) return ans while (queue.length &gt; 0) &#123; const node = queue.shift() ans.push(node.val) if (node.left) queue.push(node.left) if (node.right) queue.push(node.right) &#125; return ans&#125;; 按层次输出层序遍历在层序遍历的过程中还要记住当前处在拿一层 用一个last指针指向每一层最后一个节点 或者，前序遍历。逐个给每一层添加元素。前序遍历是先遍历第一个第一个元素，然后第二层第一个元素…. 102. 二叉树的层序遍历 往往，考题不会只靠队列这一个点。层序遍历只是解决问题的一个手段 填充右侧节点117. 填充每个节点的下一个右侧节点指针 II 考点：层序遍历+last指针记住层次 层次遍历到当前节点时： 当前节点是last：不修改next指针 不是last：将当前节点的next指向队列中第一个元素 循环队列实现622. 设计循环队列 循环队列有两种实现方式 fornt+rear+used front和rear分别指向队头和队尾，used记录队列的元素个数，当： 队列为空：front = rear且used=0 队列满了：front=rear且used=队列长度 其它情况：front != rear，used=队列元素个数 浪费一个空间 front和rear分别指向队头和队尾，当： 队列为空：front = rear 队列满了：(rear + 1) % capacity == front 其它情况：front != rear 🌟在js中实现循环队列无需指针，直接调用数组对象的push和shift方法模拟队列。 循环队列的出现是因为其它语言的数组是定长的，在声明时就要指定长度，所以需要充分利用空间。而JavaScript中的数组，无需声明是指定长度。所以并不需要循环队列这种数据结构。 理论上shift删除队列首元素，会导致后面所有元素向前移动一位。但是在v8的优化下，这种方式比front+rear两个指针要快 1234567891011121314151617181920212223242526272829303132333435363738class MyCircularQueue &#123; private size: number; private queue: number[] = []; constructor(k: number) &#123; this.size = k; &#125; enQueue(value: number): boolean &#123; if (this.isFull()) return false; this.queue.push(value); return true; &#125; deQueue(): boolean &#123; if (this.isEmpty()) return false; this.queue.shift(); return true; &#125; Front(): number &#123; if (this.isEmpty()) return -1; return this.queue[0]; &#125; Rear(): number &#123; if (this.isEmpty()) return -1; return this.queue[this.queue.length - 1]; &#125; isEmpty(): boolean &#123; return this.queue.length === 0; &#125; isFull(): boolean &#123; return this.queue.length === this.size; &#125;&#125; 单调队列单调队列： 基于双端队列：两端都可以入队和出队 队列元素满足单调递增或者单调递减 滑动窗口最大值239. 滑动窗口最大值","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/categories/Algorithm/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://zxffan.github.io/tags/TypeScript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/tags/Algorithm/"}]},{"title":"vue3-任务调度","slug":"sourcecode/vue3-任务调度","date":"2021-04-03T16:00:00.000Z","updated":"2021-06-29T14:07:25.641Z","comments":true,"path":"posts/d2a05aba.html","link":"","permalink":"https://zxffan.github.io/posts/d2a05aba.html","excerpt":"","text":"在vue3中，修改一个响应式对象，像是这样： 123456789101112&lt;template&gt; &lt;span class=&quot;my-name&quot;&gt;name: &#123;&#123; name &#125;&#125;&lt;/span&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;import &#123; ref, watchEffect &#125; from &#x27;vue&#x27;const name = ref(&quot;zxfan&quot;)name.value += &#x27; yes!&#x27;&lt;/script&gt; 当执行name.value += &#39; yes!&#39;，vue3并不会立即触发当前组件的更新。而是将更新任务放到任务队列中。这一点与vue2一致。 任务队列调度相关的源码位于runtime-core/src/schduler.ts中 在任务调度过程中，任务会被放入三类任务队列中： preFlushCbs：要在执行queue之前执行的队列 queue：任务队列 postFlush：要在执行queue之后执行的队列 每一次flush的过程（或者说一个Tick），都是按照清空preFlushCbs队列-&gt;清空queue队列-&gt;清空postFlush队列的顺序 flush 指刷新任务队列，或者说 执行完任务队列中所有的任务 入队queue的时机queue存放的都是组件渲染任务 组件更新先提一下vue中的响应式： 123456789import &#123;effect, ref&#125; from &#x27;@vue/reactivity&#x27;const age = ref(20)effect(() =&gt; &#123; console.log(age.value) // 会输出两次，分别是 20 和 21&#125;)age.value = 21 effect的回调函数会被响应式得重写触发执行。 那么回到本文最开始的例子中，当执行name.value += &#39; yes!&#39;。响应式数据变化了，触发（trigger）其关联到的effect重新执行。那么需要重新执行的effect在哪里声明的呢？ 123456789101112131415// runtie-core/src/renderer.tsconst setupRenderEffect: SetupRenderEffectFn = ( instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) =&gt; &#123; // create reactive effect for rendering instance.update = effect(function componentEffect() &#123; // 省略。。。创建或更新 VNode &#125;, __DEV__ ? createDevEffectOptions(instance) : prodEffectOptions)&#125; setupRenderEffect给组件套上了个effect。这个函数是组件实例创建的时候调用的。 当修改组件内的响应式数据时，会触发该effect重新执行。 当然不会直接就执行了，注意到了吗，effect还有第二个参数。第二个参数的类型如下： 12345678export interface ReactiveEffectOptions &#123; lazy?: boolean // 该effect是否 scheduler?: (job: ReactiveEffect) =&gt; void // 调度 onTrack?: (event: DebuggerEvent) =&gt; void onTrigger?: (event: DebuggerEvent) =&gt; void onStop?: () =&gt; void allowRecurse?: boolean&#125; 其它先不关注，我们只看scheduler属性。 如果有这个属性，就不会直接执行effect，而是调用这个scheduler函数，并且将effect作为参数传给它 123456789101112131415161718192021222324export function trigger( target: object, type: TriggerOpTypes, key?: unknown, newValue?: unknown, oldValue?: unknown, oldTarget?: Map&lt;unknown, unknown&gt; | Set&lt;unknown&gt;) &#123; // 省略... const run = (effect: ReactiveEffect) =&gt; &#123; // 有scheduler 调用 scheduler if (effect.options.scheduler) &#123; effect.options.scheduler(effect) &#125; else &#123; // 否则直接执行 effect effect() &#125; &#125; effects.forEach(run)&#125; 那么在给组件实例套上effect的时候，传给effect的第二个参数是什么呢？ 123456789101112131415161718// runtie-core/src/renderer.tsconst prodEffectOptions = &#123; scheduler: queueJob, // #1801, #2043 component render effects should allow recursive updates allowRecurse: true&#125;function createDevEffectOptions( instance: ComponentInternalInstance): ReactiveEffectOptions &#123; return &#123; scheduler: queueJob, allowRecurse: true, onTrack: instance.rtc ? e =&gt; invokeArrayFns(instance.rtc!, e) : void 0, onTrigger: instance.rtg ? e =&gt; invokeArrayFns(instance.rtg!, e) : void 0 &#125;&#125; __DEV__ ? createDevEffectOptions(instance) : prodEffectOptions)根据不同的环境传递的参数有一些差异性。但是我们只关注scheduler，scheduler的值都是queueJob这个函数 queueJob的作用就是将effect放入queue任务队列。 稍后在讨论queueJob具体都做了些什么，先总结一下组件更新的调度流程 组件实例创建时，套上了effect方法 修改响应式数据，触发effect重新执行（先调用trigger函数） effect的第二个参数中有scheduler属性，所以不会直接执行effect方法，而是将调用scheduler方法即queueJob 将组件更新effect放入queue队列中 调用forceUpdate在vue2中可以使用this.$forceUpdate强制组件重新渲染。这一API在vue3 Options API中保留了下来 123456789// runtime-core/src/componentPublicInstance.tsconst publicPropertiesMap: PublicPropertiesMap = extend(Object.create(null), &#123; // 省略... $forceUpdate: i =&gt; () =&gt; queueJob(i.update), // 省略...&#125; as PublicPropertiesMap) 可以观察到，forceUpdate就是直接调用queueJob，并将effect(i.update就是effect)传入。 hmr开发环境下，热更新也会触发组件重新渲染。也是调用queueJob将更新任务加入任务队列 入队preFlushCbs和postFlushCbs的时机preFlushCbs存放的是组件渲染前需要完成的任务 postFlushCbs存放的是组件渲染完成后要完成的任务 watchEffect和watch以watchEffect为例，看一下它的类型声明： 12345678910function watchEffect( effect: (onInvalidate: InvalidateCbRegistrator) =&gt; void, options?: WatchEffectOptions): StopHandleinterface WatchEffectOptions &#123; flush?: &#x27;pre&#x27; | &#x27;post&#x27; | &#x27;sync&#x27; // 默认：&#x27;pre&#x27; onTrack?: (event: DebuggerEvent) =&gt; void onTrigger?: (event: DebuggerEvent) =&gt; void&#125; watchEffect的第二个参数中有个flush属性，有三种取值 pre（默认）：在组件渲染前异步调用，会将任务放入preFlushCbs队列中 post：在组件渲染后异步调用，会将任务放入postFlushCbs队列中 sync：同步调用 分析源码，来看一下具体放入队列的操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051export function watchEffect( effect: WatchEffect, options?: WatchOptionsBase): WatchStopHandle &#123; // 调用doWatch方法 return doWatch(effect, null, options)&#125;function doWatch( source: WatchSource | WatchSource[] | WatchEffect | object, cb: WatchCallback | null, &#123; immediate, deep, flush, onTrack, onTrigger &#125;: WatchOptions = EMPTY_OBJ, instance = currentInstance): WatchStopHandle &#123; // 省略... const job: SchedulerJob = () =&gt; &#123; // 省略 // 会执行传入的回调 cb &#125; // 赋值scheduler let scheduler: ReactiveEffectOptions[&#x27;scheduler&#x27;] if (flush === &#x27;sync&#x27;) &#123; scheduler = job &#125; else if (flush === &#x27;post&#x27;) &#123; scheduler = () =&gt; queuePostRenderEffect(job, instance &amp;&amp; instance.suspense) &#125; else &#123; // default: &#x27;pre&#x27; scheduler = () =&gt; &#123; if (!instance || instance.isMounted) &#123; queuePreFlushCb(job) &#125; else &#123; // 第一次执行，组件未渲染的话，同步执行 job() &#125; &#125; &#125; // 创建effect const runner = effect(getter, &#123; lazy: true, // true的话， effect第一次不会自动执行，而是直接返回effect onTrack, onTrigger, scheduler &#125;) // 省略...&#125; 总结一下： 响应式都是通过effect来实现的 先赋值sheduler，有三种情况 flush: sync：直接赋值job，也就是直接触发effect执行 flush: post：赋值一个函数，函数会执行queuePostRenderEffect，即将job放入postFlushCbs队列 flush: pre：赋值一个函数，函数会执行queuePreRenderEffect，即将job放入preFlushCbs队列 创建effect，以实现响应式 并将scheduler传入。当响应式数据发生变化，就会调用scheduler函数 除此之外，在Vnode创建、更新和销毁的过程中，许多环节需要在组件更新完之后再去执行相应操作。vue调用了queuePostFlushCb。 任务调度现在来具体看一下这些任务进入任务队列中都做了什么： queueJob12345678910111213141516171819202122// runtime-core/src/schduler.tsexport function queueJob(job: SchedulerJob) &#123; // 判断队列中是否已有该job，没有才会添加到任务队列中 if ( (!queue.length || !queue.includes( job, isFlushing &amp;&amp; job.allowRecurse ? flushIndex + 1 : flushIndex )) &amp;&amp; job !== currentPreFlushParentJob ) &#123; // 找的任务在任务队列中合适的位置 const pos = findInsertionIndex(job) if (pos &gt; -1) &#123; queue.splice(pos, 0, job) &#125; else &#123; queue.push(job) &#125; // 清空任务队列 queueFlush() &#125;&#125; 先进行重复判断。这是确保任务队列中不会出现多个相同组件的effect，防止组件重复渲染。 最终调用queueFlush来执行清空任务队列（执行完所有任务） queuePreFlushCb1234567891011121314151617181920212223242526272829303132// runtime-core/src/schduler.tsfunction queueCb( cb: SchedulerCbs, activeQueue: SchedulerCb[] | null, pendingQueue: SchedulerCb[], index: number) &#123; if (!isArray(cb)) &#123; if ( !activeQueue || !activeQueue.includes( cb, (cb as SchedulerJob).allowRecurse ? index + 1 : index ) ) &#123; pendingQueue.push(cb) &#125; &#125; else &#123; pendingQueue.push(...cb) &#125; // 清空任务队列 queueFlush()&#125;export function queuePreFlushCb(cb: SchedulerCb) &#123; queueCb(cb, activePreFlushCbs, pendingPreFlushCbs, preFlushIndex)&#125;export function queuePostFlushCb(cb: SchedulerCbs) &#123; queueCb(cb, activePostFlushCbs, pendingPostFlushCbs, postFlushIndex)&#125; queuePreFlushCb和queuePostFlushCb都会再去调用queueCb函数，这个函数做两件事 将任务放入响应的任务队列（当然 先判断重复） 执行queueFlush，来清空任务队列 queueFlush1234567891011121314151617181920212223242526272829303132333435// runtime-core/src/schduler.tsconst resolvedPromise: Promise&lt;any&gt; = Promise.resolve()function queueFlush() &#123; if (!isFlushing &amp;&amp; !isFlushPending) &#123; isFlushPending = true currentFlushPromise = resolvedPromise.then(flushJobs) &#125;&#125;function flushJobs(seen?: CountMap) &#123; // 省略... // 1. 清空preFlushCb队列 flushPreFlushCbs(seen) // 省略... try &#123; // 2. 清空queue队列 for (flushIndex = 0; flushIndex &lt; queue.length; flushIndex++) &#123; const job = queue[flushIndex] if (job) &#123; // 执行job，也就是前面传入的effect callWithErrorHandling(job, null, ErrorCodes.SCHEDULER) &#125; &#125; &#125; finally &#123; // 省略... // 3. 清空postFlushCbs队列 flushPostFlushCbs(seen) // 省略... &#125;&#125; 清空队列主要流程： 异步执行flushJob，这里使用了resolvedPromise.then(flushJobs)。将清空队列的操作变成了异步。 清空preFlushCb队列 清空queue队列 清空postFlushCbs队列 这里的“清空”是执行队列中所有任务的意思 nextTick原理？先看一段demo： 12345678910111213141516171819&lt;template&gt; &lt;span class&#x3D;&quot;my-name&quot;&gt;name: &#123;&#123;name&#125;&#125;&lt;&#x2F;span&gt;&lt;&#x2F;template&gt;&lt;script lang&#x3D;&quot;ts&quot; setup&gt;import &#123; nextTick, onMounted, ref &#125; from &#39;vue&#39;const name &#x3D; ref(&quot;zxfan&quot;)onMounted(() &#x3D;&gt; &#123; name.value +&#x3D; &#39; yes!&#39; const dom &#x3D; document.querySelector(&quot;.my-name&quot;) console.log(dom?.innerHTML); &#x2F;&#x2F; 输出：name: zxfan nextTick(() &#x3D;&gt; &#123; console.log(dom?.innerHTML); &#x2F;&#x2F; 输出：name: zxfan yes! &#125;)&#125;)&lt;&#x2F;script&gt; 由于修改响应式数据，不会立即触发组件重渲染，所以第一个console.log输出的内容是上一次渲染的内容。而nexTick注册的回调会等到在渲染完毕后执行。 我们看一下nextTick是如何实现的 12345678// runtime-core/src/schduler.tsexport function nextTick( this: ComponentPublicInstance | void, fn?: () =&gt; void): Promise&lt;void&gt; &#123; const p = currentFlushPromise || resolvedPromise return fn ? p.then(this ? fn.bind(this) : fn) : p&#125; 注意到，它是等promise执行完毕后在去执行回调函数。那么这个promise是什么呢？ currentFlushPromise：这个promise我们刚刚遇到过，是在queueFlush中赋值的。这个promise会在本轮任务队列全部清空后才会变成fullfilled。这是再去调用nextTick的回调，就能获取到最新的dom resolvedPromise：说明现在任务队列为空，那就包装一层promise并返回 要理解nextTick，还需要结合浏览器的事件循环来分析，我们先明确几个知识点： 浏览器的事件循环将事件放到两个队列——宏任务队列和**微任务队列 每一次事件循环，会优先先清空微任务队列 promise属于微任务 以下面的demo为例，解释一下从修改响应式数据到nextTick中回调执行的过程 1234name.value += &#x27; yes!&#x27;nextTick(() =&gt; &#123; console.log(dom?.innerHTML); // 输出：name: zxfan yes!&#125;) 当执行name.value += &#39; yes!&#39;时，响应式数据发生了改变。 触发Proxy的setter，将更新组件任务的effect放入vue任务队列中（调用queueJob） 调用queueFlush，这里调用了promise.resolve，所以将flushJobs放入微任务队列 此时微任务队列= [flushJobs] 接着执行nextTick。等待currentFlushPromise执行完毕 开始清空微任务队列。先执行flushJobs，执行更新组件任务的effect，这个过程会操作DOM，一旦操作DOM。浏览器会进行线程切换。由JS线程切换到渲染线程，浏览器去更新DOM。当DOM更新完毕，在切换回JS线程。回到JS线程后，currentFlushPromise状态变成fullfilled。将nextTick的回调cb放入微任务队列。此时微任务队列= [cb] 继续清空微任务队列，执行cb。此时如果在cb中访问dom，就是渲染完成后的dom内容。 总结 Vue2中的表现任务调度vu2的任务调度原理也是类似。 组件的响应式数据发生改变，会触发setter方法。 触发dep.notify()。 遍历dep对象上的watcher，逐一调用其update方法，（Watcher对象是在渲染组件时创建的，用来更新组件） update再调用queueWatcher，将更新任务加入任务队列 调用nextTick(flushSchedulerQueue)，用来清空任务队列。nextTick是为了让组件更新变成异步。 nextTickvue2中的nextTick比vue3多了些内容。 nextTick也模拟了一个回调任务队列callbacks（注意这不是调度的任务队列） 12345678910111213141516171819202122232425262728export function nextTick (cb?: Function, ctx?: Object) &#123; let _resolve // 将回调加入队列中 callbacks.push(() =&gt; &#123; if (cb) &#123; try &#123; cb.call(ctx) &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;) &#125; &#125; else if (_resolve) &#123; _resolve(ctx) &#125; &#125;) // 如果队列没有正在执行（flush），就去清空队列 if (!pending) &#123; pending = true timerFunc() // 清空队列 &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(resolve =&gt; &#123; _resolve = resolve &#125;) &#125;&#125; nextTick调用了timeFunc来清空队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function flushCallbacks () &#123; // 省略... 就是清空callbakcs任务队列&#125;let timerFunc// 1 支持promise，就用promise来模拟异步if (typeof Promise !== &#x27;undefined&#x27; &amp;&amp; isNative(Promise)) &#123; const p = Promise.resolve() timerFunc = () =&gt; &#123; p.then(flushCallbacks) if (isIOS) setTimeout(noop) &#125; isUsingMicroTask = true&#125; // 2. 不支持promise 就用MutationObserver来模拟异步else if (!isIE &amp;&amp; typeof MutationObserver !== &#x27;undefined&#x27; &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === &#x27;[object MutationObserverConstructor]&#x27;)) &#123; // Use MutationObserver where native Promise is not available, // e.g. PhantomJS, iOS7, Android 4.4 // (#6466 MutationObserver is unreliable in IE11) let counter = 1 const observer = new MutationObserver(flushCallbacks) const textNode = document.createTextNode(String(counter)) observer.observe(textNode, &#123; characterData: true &#125;) timerFunc = () =&gt; &#123; counter = (counter + 1) % 2 textNode.data = String(counter) &#125; isUsingMicroTask = true&#125; // 3.用setImmediate来模拟异步else if (typeof setImmediate !== &#x27;undefined&#x27; &amp;&amp; isNative(setImmediate)) &#123; timerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else &#123; // Fallback to setTimeout. timerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125; 为了更多的兼容浏览器，timerFunc模拟异步判断了三种情况 支持Promise，就直接用Promise来模拟异步。Promise属于微任务 不支持Promise，支持MutationObserver。MutationObserver也属于微任务 创建一个空的文本节点，监听这个文本节点的字符变化。变化了就调用flushCallbacks来清空回调任务队列 调用timerFunc，会修改文本节点的内容，从而触发flushCallbacks函数的执行 MutationObserver和Promise都不支持，就用setImmediate来模拟异步，后者属于宏任务 最后方案就是使用setTimeout来模拟异步 可见vue2为了兼容性，下足了功夫。而vue3直接就使用了Promise","categories":[{"name":"源码","slug":"源码","permalink":"https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://zxffan.github.io/tags/vue/"}]},{"title":"栈问题梳理","slug":"Algorithm/栈问题梳理","date":"2021-04-02T16:00:00.000Z","updated":"2021-06-29T14:03:52.788Z","comments":true,"path":"posts/1f4ac2fb.html","link":"","permalink":"https://zxffan.github.io/posts/1f4ac2fb.html","excerpt":"","text":"普通栈栈的特性：先进后出 数组模拟： 进栈：arr.push() 出栈：arr.pop() 匹配消除栈可以用来解决匹配问题 20. 有效的括号括号匹配，(&#123;[与]&#125;)匹配 创建一个栈stack，并遍历字符串。当遇到(&#123;[时入栈，当遇到]&#125;)时，取栈顶元素比较 相匹配，栈顶元素出栈，继续循环 不匹配，直接返回false 时间复杂度O(n)，空间复杂度O(n) 如果栈中的元素都一样，就不需要用栈，用一个计数器count即可 大鱼吃小鱼题目】在水中有许多鱼，可以认为这些鱼停放在 x 轴上。再给定两个数组 Size，Dir，Size[i] 表示第 i 条鱼的大小，Dir[i] 表示鱼的方向 （0 表示向左游，1 表示向右游）。这两个数组分别表示鱼的大小和游动的方向，并且两个数组的长度相等。鱼的行为符合以下几个条件: 所有的鱼都同时开始游动，每次按照鱼的方向，都游动一个单位距离； 当方向相对时，大鱼会吃掉小鱼； 鱼的大小都不一样。 输入：Size = [4, 2, 5, 3, 1], Dir = [1, 1, 0, 0, 0] 输出：3 这道题跟上一条题原理一样都是匹配消除，上一道题是根据元素的内容（括号）来判断匹配消除。而本道题是根据元素的大小的“方向”两个条件来判断 123456789101112131415161718192021222324252627282930313233343536const LEFT = 0;const RIGHT = 1;function eatFish(size: number[], dir: number[]) &#123; const stack: number[] = []; for (let i = 0; i &lt; size.length; i++) &#123; // 还没有鱼 if (stack.length &lt;= 0) &#123; stack.push(i); continue; &#125; let insert = true; // 栈顶的鱼比 当前的鱼小, 就一直循环得吃 while (stack.length &gt; 0) &#123; let last = stack[stack.length - 1]; const canMeet = dir[last] === RIGHT &amp;&amp; dir[i] == LEFT; if (canMeet &amp;&amp; size[last] &lt; size[i]) stack.pop(); // 大鱼把栈中的所有鱼都吃完了，需要在最后将这条大鱼放入栈中 else if (canMeet) &#123; insert = false; break; &#125; else &#123; insert = true; break; &#125; &#125; // 栈中的鱼都吃完了 if (insert) stack.push(i); &#125; return stack;&#125; 单调栈单调栈分为两种： 递增栈 递减栈 相邻最小索引【题目】一个整数数组 A，找到每个元素：右边第一个比我小的下标位置，没有则用 -1 表示。 输入：[5, 2] 输出：[1, -1] 解释：因为元素 5 的右边离我最近且比我小的位置应该是 A[1]，最后一个元素 2 右边没有比 2 小的元素，所以应该输出 -1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 解析： * 遍历数组元素，构造递增栈 * 当前元素比栈顶小，则栈顶元素需要出栈，并记录栈顶元素右侧第一个小的下标为当前元素下标 */function findRightSmall(arr: number[]) &#123; const result: number[] = arr.map((i) =&gt; -1); const stack: number[] = []; for (let i = 0; i &lt; arr.length; i++) &#123; const cur = arr[i]; while (stack.length &gt; 0 &amp;&amp; arr[stack[stack.length - 1]] &gt; cur) &#123; result[stack[stack.length - 1]] = i; stack.pop(); &#125; stack.push(i); &#125; return result;&#125;// 改变一下问题// 求左边第一个比我下的下标为止，没有则用-1表示/** * 解析 * 还是遍历数组元素，构造递增栈 * 当前元素小于等于栈顶元素是需要出栈 * 当不需要栈顶元素出栈，说明当前元素比栈顶元素大。即栈顶元素是当前元素左侧第一个小的元素，记录一下 * * 记录之前还要排除掉相等的情况，即从栈顶往下找，一直找到一个不相同的元素 */function findLeftSmall(arr: number[]) &#123; const result: number[] = arr.map((i) =&gt; -1); const stack: number[] = []; for (let i = 0; i &lt; arr.length; i++) &#123; const cur = arr[i]; while (stack.length &gt; 0 &amp;&amp; arr[stack[stack.length - 1]] &gt; cur) stack.pop(); let top = stack.length - 1; while (arr[stack[top]] === cur) top--; if (top &gt;= 0) result[i] = stack[top]; stack.push(i); &#125; return result;&#125; 字典序最小的 k 个数的子序列【题目】给定一个正整数数组和 k，要求依次取出 k 个数，输出其中数组的一个子序列，需要满足：1. 长度为 k；2.字典序最小。 输入：nums = [3,5,2,6], k = 2输出：[2,6] 解释：在所有可能的解：{[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 字典序最小。 所谓字典序就是，给定两个数组：x = [x1,x2,x3,x4]，y = [y1,y2,y3,y4]，如果 0 ≤ p &lt; i，xp == yp 且 xi &lt; yi，那么我们认为 x 的字典序小于 y。 1234567891011121314151617181920function findSmallSeq(seg: number[], k: number) &#123; const stack: number[] = []; for (let i = 0; i &lt; seg.length; i++) &#123; const cur = seg[i]; if (stack.length &lt;= 0) stack.push(cur); while ( stack.length &gt; 0 &amp;&amp; stack[stack.length - 1] &gt; cur &amp;&amp; stack.length + seg.length - i &gt; k ) stack.pop(); if(stack.length &lt; k) stack.push(cur) &#125; return stack;&#125; 单调栈的运用84. 柱状图中最大的矩形 42. 接雨水","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/categories/Algorithm/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://zxffan.github.io/tags/TypeScript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/tags/Algorithm/"}]},{"title":"vue3-vnode","slug":"sourcecode/vue3-vnode","date":"2021-03-29T16:00:00.000Z","updated":"2021-06-29T14:07:39.691Z","comments":true,"path":"posts/f9d1a0d8.html","link":"","permalink":"https://zxffan.github.io/posts/f9d1a0d8.html","excerpt":"","text":"VNode是vue十分重要的核心概念，下图整理了VNode的创建、销毁、更新patch等流程。","categories":[{"name":"源码","slug":"源码","permalink":"https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://zxffan.github.io/tags/vue/"}]},{"title":"二叉树遍历问题梳理","slug":"Algorithm/二叉树遍历问题梳理","date":"2021-03-27T16:00:00.000Z","updated":"2021-06-29T14:03:40.061Z","comments":true,"path":"posts/4ed68d4d.html","link":"","permalink":"https://zxffan.github.io/posts/4ed68d4d.html","excerpt":"","text":"二叉树二叉树的定义 12345class TreeNode &#123; public value: number; public left?: TreeNode; public right?: TreeNode;&#125; 有四种遍历方式: 前序遍历 中序遍历 后序遍历 层次遍历 前序遍历——给子树传递信息LeetCode 114.二叉树的前序遍历 解法： 递归 栈 Morris 常见的解法：递归法 12345678910function preOrder(node: TreeNode): void &#123; if (!node) return // 访问节点 console.log(node.value) // 遍历左子树 preOrder(node.left) // 遍历右子树 preOrder(node.right)&#125; 使用栈：栈模拟递归，先依次将节点以及节点的左子节点放入栈中，如果没有左子节点，就去栈顶元算的右子节点依次循环。当栈为空说明遍历完了，时间复杂度O(n)，空间复杂度O(h)，h为树的高度。 Morris 遍历可以实现空间复杂度O(1)，无需递归。 “影子”二叉树星座二叉树是一种思考方式，根据题意，将所给二叉树构造成另一颗二叉树 LeetCode 98. 验证二叉搜索树[解析]：可以构造影子二叉树，影子二叉树的节点都是一个区间[min, max]，我们需要做的就是判断原二叉树的节点是否在其对应的影子二叉树节点所表示的区间范围累 先前序遍历二叉树，根节点判断是否在[-Infinity, Infinity]区间，左子树判断是否在[-Infinity, root.val]之间，右子树判断是否在[root.val, Infinity]之间 前序遍历可以递归或栈，也可以用Morris 使用栈的话，就需要自己构造出影子二叉树，在递归的过程中不断给min和max赋值。 1234567891011class ShadowNode &#123; node: TreeNode; min: number; max: number; constructor(node: TreeNode, min: number, max: number) &#123; this.node = node this.min = min this.max = max &#125;&#125; LeetCode 100. 相同的树[题解]：题目给了两棵树p和q，他们俩互为影子二叉树，两棵树同时前序遍历，判断对应节点是否相同 LeetCode 572. 另一个树的子树[题解]：题目给了两棵树s和t，前序遍历s，当s.val === t.val是，t可能是s的子树，这时再去判断s和t是否是相同的树(上一题) 利用回溯（回归）113. 路径总和 II计算符合所给target值的全部路径。 [题解]： 前序遍历二叉树，在遍历的过程中使用path数组记录路径，sum变量记录路径和。当遍历到叶子节点时（左右子树为空）。判断sum === target，相等将path放入result(二维数组)中。 没有遍历到叶子节点继续回溯 到叶子节点后，要将path.pop。即把叶子结点从路径最后扔掉! 扩展：求从根节点到所有叶子节点的路径 中序遍历——有序性94. 二叉树的中序遍历中序遍历： 递归 栈 Morris 使用栈解决中序遍历：算法和前序遍历差不多，就是读取数据的实际不同，前序是在每一次深入左子树前读；而中序是每次切换右子树时读 中序有序性98. 验证二叉搜索树使用中序遍历解决这道题比前序遍历要简单，因为一个特性：中序遍历二叉搜索树，一定有序。只要在遍历过程中判断当前节点的值是否大于上一个节点的值，如果不满足可以直接判断不是二叉搜索树。 501. 二叉搜索树中的众数求二叉搜索树出现次数最多的数（可能不止一个）。采用中序遍历，因为一定有序。所以问题就转化成：给定有序数组，求出现次数最多的数。 最简单的就是Map统计每个数据的出现次数，空间复杂度O(n) 空间O(1)解决方法：四个变量: max：数组，存放出现次数最多的元素 maxCount：出现次数最多的元素的次数 last：上一个遍历到的数据 lastCount：上一个遍历到的数据出现的次数 当当前节点值不等于last，就需要判断lastCount和maxCount的大小，来决定是否将lastCount放入数组 边界情况：当遍历结束后，还要再判断一下。 783. 二叉搜索树节点最小距离还是利用中序遍历二叉搜索树的有序性。当前节点和上一个节点的值相减取最小值即可。 99. 恢复二叉搜索树还有利用中序遍历二叉搜索树的有序性，问题就转化为：还原升序数组被调换的两个数。 三个指针 first：指向第一个被调换的节点 second：指向第二个被调换的节点 lastNode：上一个遍历的节点 每次遍历，判断当前节点与lastNode的大小。动态调整first和second的指向。遍历有两种情况 只会遇到一次root.val &lt; lastNode.val：被调换的两个节点相邻在一起，这时first和second分别指向root和lastNode 会遇到第二次，第二次只需要调整second，指向root 二叉搜索树（BST）的增删查450. 删除二叉搜索树中的节点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Definition for a binary tree node. * class TreeNode &#123; * val: number * left: TreeNode | null * right: TreeNode | null * constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123; * this.val = (val===undefined ? 0 : val) * this.left = (left===undefined ? null : left) * this.right = (right===undefined ? null : right) * &#125; * &#125; */function deleteNode(root: TreeNode | null, key: number): TreeNode | null &#123; // case1 空树 if (root === null) return root // case2 要删除的元素在左子树 if (key &lt; root.val) root.left = deleteNode(root.left, key) // case3 要删除的元素在右子树 else if (key &gt; root.val) root.right = deleteNode(root.right, key) // case4 当前节点即为 需要删除的元素 ，又分为四种情况： else &#123; // 1.叶子节点 if (root.left === null &amp;&amp; root.right === null) return null // 2.有左子树 else if (root.left !== null) &#123; // 找左子树最大值 let node = root.left while (node.right) node = node.right swapNodeVal(root, node) root.left = deleteNode(root.left, node.val) &#125; // 3.有右子树 else if (root.right !== null) &#123; // 找右子树最小值 let node = root.right while (node.left) node = node.left swapNodeVal(root, node) root.right = deleteNode(root.right, node.val) &#125; // 4.既有左子树 又有右子树。这种情况包含在情况2中 // 所以最终答案有两种 &#125; return root&#125;;function swapNodeVal(a: TreeNode, b: TreeNode) &#123; const val = a.val a.val = b.val b.val = val&#125; 701. 二叉搜索树中的插入操作插入操作和删除相似，但是就没有那么多边界情况 12345678function insertIntoBST(root: TreeNode | null, val: number): TreeNode | null &#123; if (root === null) return new TreeNode(val) if (root.val &lt; val) root.right = insertIntoBST(root.right, val) else if (root.val &gt; val) root.left = insertIntoBST(root.left, val) return root&#125;; 700. 二叉搜索树中的搜索搜索也类似 1234567function searchBST(root: TreeNode | null, val: number): TreeNode | null &#123; if (root === null) return root if (root.val &lt; val) return searchBST(root.right, val) else if (root.val &gt; val) return searchBST(root.left, val) else return root&#125;; 后序遍历——给父节点传递信息如果一个节点既有左子树又有右子树，那么该节点会在回溯时被访问（即该节点被遍历到两次） 后续遍历： 递归 栈 Morris 145. 二叉树的后序遍历使用栈来递归遍历二叉树，比前序和中序要稍微复杂一些，一些节点是在第二次遍历到时才访问 使用一个变量pre始终指向上一个访问的节点 遍历到节点时有两个分支 当前节点没有右节点或者右节点等于pre时，访问该节点，不再深入有节点（因为是回溯回来的） 反之，继续访问右节点 12345678910111213141516171819202122232425function postorderTraversal(root: TreeNode | null): number[] &#123; const stack: TreeNode[] = [] const result: number[] = [] let pre: TreeNode | null while (true) &#123; while (root) &#123; stack.push(root) root = root.left &#125; if (stack.length &lt;= 0) break root = stack[stack.length - 1] // 取栈顶元素 // 右子树为空，或者右子树等于上一个被访问的节点（回溯回来的）时，访问 if (root.right === null || root.right === pre) &#123; result.push(root.val) stack.pop() // 出栈 pre = root root = null // root = null 说明不再遍历该节点的子树 &#125; // 否则继续后序遍历 else root = root.right &#125; return result&#125;; 剑指 Offer 68 - II. 二叉树的最近公共祖先后序遍历后续遍历的精髓：先深入左右子树搜取信息，回溯时再判断（回溯时就知道了子节点的信息） 现深入左右子树，回溯时，判断每个节点左右子树等于p和q的次数l与r 如果l和r均为1，说明当前节点就是p和q的最近公共祖先 如何l和r有一个为1且当前节点等于p或q，也说明当前节点就是p和q的最近公共祖先 回溯时，返回以当前节点为根节点的树中p和q的数量 注意这道题的前提条件：p、q唯一且不相等 前序遍历这道题还可以用前序遍历来解决，前序遍历时遍历到该节点就去访问，此时只知道当前节点和遍历过的节点信息并不知道子节点信息。 在遍历到该节点是，判断一下该节点是不是等于p或q 如果是，就直接返回子节点就不需要在遍历了 如果不是，继续遍历左子树和右子树找p和q的点 当左右子树找完了 左右子树都找到了p和q，说明该节点就是最近公共祖先 如果只找到一个，或者没有找到（没找到的话返回null），返回不等于null的节点（继续往下找），都等于null说明不存在最近公共祖先 扩展：多个节点的最近公共祖先呢？ 思考题105. 从前序与中序遍历序列构造二叉树前序遍历 preorder = [3,9,20,15,7]中序遍历inorder = [9,3,15,20,7] 特性： 前序遍历的第一个元素一定为根节点，后面的元素分别是左子树和右子树 中序遍历某一个元素如果为根节点，则左边的都是其左子树的节点，右边都是其右子树的节点 根据特性可以总结出以下解体思路 先构造一个map，存放inorder的value-&gt;index，这是为了查找索引时方便（空间换时间） 递归遍历preorder， 取第一个元素出来，当作根节点 在分别设置改根节点的左子树和右子树 12345678910111213141516171819function buildTree(preorder: number[], inorder: number[]): TreeNode | null &#123; const map = new Map&lt;number, number&gt;() inorder.map((v, i) =&gt; map.set(v, i)) function build(s: number, e: number) &#123; if (s &gt; e) return null const val = preorder.shift() const root = new TreeNode(val) const index = map.get(val) // 查找索引 // 设置左右子树 root.left = build(s, index - 1) root.right = build(index + 1, e) return root &#125; return build(0, preorder.length - 1)&#125;;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/categories/Algorithm/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://zxffan.github.io/tags/TypeScript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/tags/Algorithm/"}]},{"title":"二分法梳理","slug":"Algorithm/二分法梳理","date":"2021-03-27T16:00:00.000Z","updated":"2021-06-29T14:03:42.641Z","comments":true,"path":"posts/d7f42810.html","link":"","permalink":"https://zxffan.github.io/posts/d7f42810.html","excerpt":"","text":"二分查找的原则 开闭原则：首先要确定查找的区间。i一般都取0；j可以取length也可以取length-1 j = length：意味着左闭右开区间即[i, j) j = length - 1：意味着左闭右闭区间[i, j] 循环终止条件 while(i &lt; j)：当采用左闭右开区间时使用这个。终止搜索区间为[i, i)(长度为0)；终止条件i === j。 while(i &lt;= j)：当采用左闭右闭区间时使用这个。终止搜索区间为[i, i]（长度为1，还有个i）；终止条件i = j + 1。 (i + j) &gt;&gt; 1：这样默认是取下限；(i + j + 1) &gt;&gt; 1：这样默认是取上限 i和j怎么变？ i = mid + 1和j = mid：当采用左闭右开区间时使用这个，mid是取不到的，所以j可以等于mid i = mid + 1和j = mid - 1 ：当采用左闭右闭区间时使用这个，因为是右闭，所以j要等于mid - 1 确定开闭原则是十分重要 两个模版【题目】给定一个有序数组，返回指定元素在数组的最左/右边的位置 输入：A = [1, 2, 2, 2, 2, 3, 3], target = 2； 元素在数组最左的位置（lowBound模版）我们选左闭右开区间 [i, j) 也就是找到数组中第一次出现指定元素2的位置。 当遍历到一个元素 nums[mid]，会分两种情况 nums[mid] &gt;= target：此时区间[i, mid)是我们要继续搜索的。当前元素就是元素2，因为我们是要找第一个2，所以还需要往左边找，防止mid nums[mid] &lt; target：此时区间[mid + 1, j)是我们要继续搜索的，说明target在mid的右侧 1234567891011function findLeft(nums: number[], target: number) &#123; let i = 0 let j = nums.length while (i &lt; j) &#123; const mid = (i + j) &gt;&gt; 1 if (nums[mid] &lt; target) i = mid + 1 else j = mid &#125; return i&#125; 元素在数组最右的位置（upperBound模版）同理，当遍历到一个元素 nums[mid]，有三种情况。有两种情况处理结果一样： nums[mid] &gt; target：此时区间[i, mid - 1]是我们要继续搜索的，说明target在mid的左侧 nums[mid] &lt;= target：此时区间[mid, high]是我们要继续搜索的，说明target在mid的右侧 1234567891011function findRight(nums: number[], target: number) &#123; let i = 0 let j = nums.length while (i &lt; j) &#123; const mid = (i + j) &gt;&gt; 1 if (nums[mid] &gt; target) j = mid else i = mid + 1 &#125; return i - 1&#125; 为什么return i - 1? 应为当 num[mid] === target时，i = mid + 1。所以最后nums[i]一定不等于target，只有nums[i-1]才可能等于target（如果存在target元素） 练习：35. 搜索插入位置二分解题思路二分的前提：搜索范围有规律（例如：有序） 提问破题法。 要什么，什么就是 x。x表示搜索空间 获取C[f(1), f(2), … f(x)…]， 满足约束条件的 f(x) = 0。f(x) 表示通过 x 得到的值。约束条件看题意 不满足约束条件的 f(x) 设置为 -1 或者 1。 最优解 0 在 C[] 的最左边还是最右边，决定使用 lowerBound 还是 upperBound。 852. 山脉数组的峰顶索引 确定搜索空间[1,len-1)左闭右开 C[] &amp;&amp; f(x) arr[x]比左边小比右边大（处于递增）：return -1 arr[x]比两边都大：return 0 arr[x]比左边大比右边小（处于递减）：return 1 所找元素唯一（不存在重复），选择使用 lowerBound 还是 upperBound都可以， 当f(x) 等于-1：i = m + 1 等于0或等于1: j = m 给定一个有序数组，找出数组中下标与值相等的那些数。123456789101112131415/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var getNumberSameAsIndex= function(nums) &#123; let i = 0 let j = nums.length while(i &lt; j) &#123; const m = (i + j) &gt;&gt; 1 if(m === nums[i]) return m else if (m &lt; nums[i]) j = m else i = m + 1 &#125; return m&#125;; 给定一个有序数组，找出数组中下标与值相等的数的范围。先使用lowerBound找一个left 再使用upperBound找一个right [left, right]就是答案","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/categories/Algorithm/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://zxffan.github.io/tags/TypeScript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/tags/Algorithm/"}]},{"title":"链表问题梳理","slug":"Algorithm/链表问题梳理","date":"2021-03-27T16:00:00.000Z","updated":"2021-06-29T14:03:45.284Z","comments":true,"path":"posts/4ed68d4d.html","link":"","permalink":"https://zxffan.github.io/posts/4ed68d4d.html","excerpt":"","text":"解决链表问题的“三板斧”：假头、新链表、双指针。 假头节点假头通常也叫作 Dummy Head。就是在链表前面，加上一个额外的结点。此时，存放了 N 个数据的带假头的链表，算上假头一共有 N+1 个结点。添加假头后，可以省略掉很多空指针的判断，链表的各种操作会变得更加简洁。 LeetCode[707] 设计链表掌握几种常见的链表操作 get: 查找制定索引的链表元素 addAtHead: 头部插入元素 addAtTail: 尾部插入元素 addAtIndex: 指定索引插入 deleteAtIndex: 指定索引删除 新链表做链表的反转、交换等操作时，不建议直接在原来的链表上进行操作。一种可取的思路是，把这些操作想象成要生成新的链表。 反转列表反转(LeetCode 201)：可以新建一个有头节点的新链表，遍历旧链表。将每个元素采用头部插入的方法放到新链表中 删除元素根据一些条件判断来删除元素 移除链表指定元素(LeetCode 203)：同样创建一个新链表。遍历旧链表，相同元素跳过，不同元素加入新链表 删除链表重复元素：判断当前遍历的元素与新链表中最后的元素是否相等。 删除链表所有重复过的元素： 合并 合并两个有序链表(LeetCode 21) 合并K个升序链表(LeetCode 23) 这两道题页都是生成 dummy 新链表，然后选择结点往新链表尾部追加数据 升序： 选择最小的 降序：选择最大的 考点：在选择最小或最大时，可以使用堆（优先队列）来优化 交换交换链表中的结点(LeetCode 24)：两两反转即奇偶位置元素交换 先拆分：按照奇偶拆成两个链表 再合并：奇数位对应原来偶数位，偶数位对应原来奇数位 K 个一组翻转链表(LeetCode 25)：每k的元素一组交换(k=2就等价于上一题) 准备两个链表——temp和result 遍历链表，将节点插入temp，满k个就反转并插入result中 最终将剩余的节点（不满k个）插入result 逆向k个一组：上一题翻着来 先将链表反转 再沿用上题的方法 双指针链表的双指针有两种： 间隔指针：前面的指针先走一步，然后后面的指针再一起走；前面的指针先走 k 步，后面的指针再一起走。 快慢指针：两个指针的速度一快一慢前进，比如一个每次走一步，一个每次走两步。 LeetCode[19] 删除链表倒数第K个节点 采用间隔指针back,front front先走k布 back，front再一起走直到front到最后一个节点 边界情况：删除的是第一个节点 将链表从中间拆分成两半 采用快慢指针back,front front每次走2步，back每次走1步 边界 奇数个节点时，front正好是最后一个节点 偶数个节点时，front为空，应返回back的前驱 LeetCode[143] 重排链表 先把链表平分 把后半部分逆置 再把逆置的后半部分插入到前半部分的偶数位上 LeetCode[141] 环形链表 采用快慢指针back,front front每次走2步，back每次走1步 如果有环，back和front必定相遇 找出环形链表成环的节点 记住一个结论：快慢指针分别从头节点和相遇节点出发，最终一定会再成环节点相遇 先都从头节点出发，找到相遇节点 分别从头节点和相遇节点出发，最后相遇的节点即成环节点 LeetCode[148] 链表排序：给定一个单向链表，如何给这个链表排序，要求复杂度达到 O(nlogn)。 采用归并排序的思想来解 递推过程：两两分解——用快慢将链表不断二分 回归过程：两两合并——利用新建头尖点来不断合并两个有序链表","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/categories/Algorithm/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://zxffan.github.io/tags/TypeScript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/tags/Algorithm/"}]},{"title":"js位运算和权限","slug":"JavaScript/JS位运算和权限","date":"2021-03-26T16:00:00.000Z","updated":"2021-06-29T14:05:38.543Z","comments":true,"path":"posts/8d54c840.html","link":"","permalink":"https://zxffan.github.io/posts/8d54c840.html","excerpt":"","text":"位运算与 &amp;都为1则为1，否则为0 A：0011010B：0101100C：0001000 或 |有1即为1，否则为0 A：0011010B：0101100C：0111110 非 ^不同为1，相同为0 A：0011010B：0101100C：0110110 权限控制现在有读、写和执行三种权限 1234读 写 执行 十进制 权限0 0 1 1 只有执行0 1 0 2 只有写1 0 0 4 只有读 读写执行对应的值分别是1、2和4 011即3对应的权限为写和执行，其它以此类推。 添加权限使用|来添加权限 用户的权限为1(001，只有执行)，现在需要加上读(4, 100) 12341 | 4:0 0 1 =&gt; 11 0 0 =&gt; 41 0 1 =&gt; 5 结果为5(101)对应执行和读的权限 删除权限使用^来删除权限 用户的权限为7(111)，需要删除写(2, 010)的权限 12347 ^ 2:1 1 1 =&gt; 70 1 0 =&gt; 21 0 1 =&gt; 5 结果为5(101)，对应执行和读的权限 判断权限当拿到用户权限时，使用&amp;来判断用户的权限 用户的权限是6（110，读和写） 110 &amp; 001 = 000， 表示没有执行权限 110 &amp; 010 = 010， 表示有写的权限 110 &amp; 100 = 100， 表示有读的权限 只有&amp;后的结果等于所需判断的权限，就表示有该权限 权限数的限制每增加一位权限，就需要多一位二进制位。 JavaScript 将数字存储为 64 位浮点数，但所有按位运算都以 32 位二进制数执行。 在执行位运算之前，JavaScript 将数字转换为 32位有符号整数。 执行按位操作后，结果将转换回 64 位 JavaScript 数。 所以，js中最多能配置32种权限(1 1 &lt;&lt; 1….1 &lt;&lt; 31)。1 &lt;&lt; 32等于1 使用BigInt能够表示更多的权限。 1n &lt;&lt; 33n =&gt; 8589934592n","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"位运算","slug":"位运算","permalink":"https://zxffan.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"js中的数值类型","slug":"JavaScript/JS中的数值类型","date":"2021-03-26T16:00:00.000Z","updated":"2021-06-29T14:05:41.423Z","comments":true,"path":"posts/9a6a2aee.html","link":"","permalink":"https://zxffan.github.io/posts/9a6a2aee.html","excerpt":"","text":"IEEE 754JavaScript的数值类型遵循IEEE 754规范。JavaScript中的数字都是以是64-bits的双精度数的形式存储的。所以能表示有2^64种情况。 浮点数公式js中的任何一个二进制浮点数可以由以下公式来表示：$$V = (-1)^{S} * M * 2^{E}$$ V：表示二进制浮点数 S：符号位，1位。为0正数，1为负数 M：有效数字，52位。 E：指数位，11位 M是一个介于1和2之间的数即(1.xxxxxxxxxxx, 11个x)。第一个1是默认填上的所以M有2^53 - 1中可能。 E的取值有2^11中可能，由于E需要能够表示负数，所以要减去一个中间数(1023) 十进制7，二进制为111：$$7(111) = (-1)^{0} * 1.11 * 2^{2}= 1.11 * 100 = 111$$注意：这里是2进制的运算2^2 = 100 E为2（10），这里已经减去1023。2+1023=1025，即十一位二进制对应的值为1025 E的几种情况同时指数E还可以根据规定分为三种情况讨论 E不全为0或不全为1 这个阶段就是正常的浮点数表示，通过计算E然后减去1024即为指数 E全为0 浮点数的指数E等于0-1023 = -1023，当指数为-1023时，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字 E全为1 此时如果有效数字M全为0，那么就表示+∞或者-∞，取决于第一位符号位。但是如果有效数字M不全为0，则表示这不是一个数(NaN) JavaScript中的IEEE 754最大安全整数$$Number.MAX_SAFE_INTEGER = 2^{53} - 1$$ 有效数字只有52位，2^53和2^53+1以及后面的数在js中都相等。所以js能够表示的最大安全整数是2^53 - 1。 0.1 + 0.2 !== 0.3 ?计算机进行数值运算是，是将十进制转成二进制补码再进行计算 1230.1D = (-1)^0 * 1.1001..(1001循环13次)1010B * 2^-40.2D = (-1)^0 * 1.1001..(1001循环13次)1010B * 2^-30.3D = (-1)^0 * 1.0011..(0011循环13次)0011B * 2^-2 当0.1，0.2转化为二进制的时候，有效数字都是52位(4 * 12 + 4)，因为在64位精确度中，只能保持52位有效数字，如果没有52位有效数字的约束，其实在第53位中，0.1转二进制本来是1，但是有了52位约束之后，根据二进制的取舍（0舍1入） ，最后五位数就从1001 1(第53位) 变成了 1010。 我们可以手动计算一下0.1的二进制加上0.2的二进制：$$0.1 + 0.2 = (-1)^{0} * 1.0011…(0011 循环13次)0011 * 2^{-2}$$那么相加结果转换为十进制其实等于0.30000000000000004，这就是为什么0.1 + 0.2 != 0.3 的原因了。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"Number","slug":"Number","permalink":"https://zxffan.github.io/tags/Number/"}]},{"title":"Rust学习笔记-Struct","slug":"Rust/Rust笔记-Struct","date":"2021-03-23T16:00:00.000Z","updated":"2021-06-29T14:06:47.797Z","comments":true,"path":"posts/a574aaab.html","link":"","permalink":"https://zxffan.github.io/posts/a574aaab.html","excerpt":"","text":"本系列文章是笔者学习Rust时所做的笔记，供日后翻阅复习。 定义Struct使用struct来定义一个结构体，结构体是key-value集合。key是字段名, value是类型。 123456struct User &#123; username: String, email: String, sign_in_count: u64, active: bool,&#125; Strut的存在 类似其他语言的class 实例化Struct实例化时，需要提供初始参数。 123456let user = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;someusername123&quot;), active: true, sign_in_count: 1,&#125;; 默认，user是immutable，如果需要mutable，在定义时加上mut 12345678let mut user = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;someusername123&quot;), active: true, sign_in_count: 1,&#125;;user.username = String::from(&quot;zxfan&quot;) 如果加上mut那么，整个实例都是可变的。rust不允许指定字段是可变的。 工厂模式实例化采用工厂模式来实例化Struct 12345678fn build_user(email: String, username: String) -&gt; User &#123; User &#123; email, username, active: true, sign_in_count: 1, &#125;&#125; email: email可以省略为email。这一特性和JavaScript一样。 结构体更新语法Struct Update Syntax允许创建使用一个实例来创建另一个实例 123456789101112131415let user1 = User &#123; email: String::from(&quot;someone@example.com&quot;), username: String::from(&quot;someusername123&quot;), active: true, sign_in_count: 1,&#125;;let user2 = User &#123; email: String::from(&quot;another@example.com&quot;), username: String::from(&quot;anotherusername567&quot;), ..user1&#125;;// owner 发生 move// user1 无法访问 通过..语法指定user2的剩余字段取user1的值。注意：..会发生owner的move，user1就无法再访问了 Tupple Struct没有字段名，以元组的方式定义struct 1234567struct Color(i32, i32, i32);struct Point(i32, i32, i32);let black = Color(0, 0, 0);let origin = Point(0, 0, 0);balck.0 // 访问 通过.来访问其元素 默认情况下，struct字段值不能是引用(References )。 在指定有lifetime的情况下，可以在结构体中使用引用。生命周期能够确保只有struct有效，那么其strutct内的应用也有效 使用派生特性添加使用功能当使用println!直接输出一个结构体，会报错！ 12345678910111213141516171819202122232425struct Rectangle &#123; width: u32, height: u32,&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50, &#125;; println!(&quot;rect1 is &#123;&#125;&quot;, rect1);&#125;/* --&gt; src/main.rs:12:29 |12 | println!(&quot;rect1 is &#123;&#125;&quot;, rect1); | ^^^^^ `Rectangle` cannot be formatted with the default formatter | = help: the trait `std::fmt::Display` is not implemented for `Rectangle` = note: in format strings you may be able to use `&#123;:?&#125;` (or &#123;:#?&#125; for pretty-print) instead = note: required by `std::fmt::Display::fmt` = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)*/ Rectangle cannot be formatted with the default formatter。利用派生特性可以解决struct输出的问题。 #[derive(Debug)]：将Debug特性派生到自定义类型（结构体）中 12345678910111213141516// #声明注解#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50, &#125;; // 在输出时，加上&#123;:?&#125; println!(&quot;rect1 is &#123;:?&#125;&quot;, rect1);&#125; 两种输出： &#123;:?&#125;: 输出rect1 is Rectangle &#123; width: 30, height: 50 &#125; &#123;:#?&#125;: 格式化输出 1234rect1 is Rectangle &#123; width: 30, height: 50,&#125; 结构体方法struct类似其它语言的class。类有成员方法。stuct也有类型概念。使用impl（implement）关键字来给struct添加成员方法 123456789101112131415161718192021222324#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32,&#125;impl Rectangle &#123; fn area(&amp;self) -&gt; u32 &#123; self.width * self.height &#125;&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50, &#125;; println!( &quot;The area of the rectangle is &#123;&#125; square pixels.&quot;, rect1.area() );&#125; 结构体方法的第一个参数必定为self，它是struct实例。加上&amp;是因为只需要引用。 使用时直接用.调用，无需考虑像C/C++那样有.和-&gt;两种调用方式。因为Rust能够自动引用和解引用。 一个impl能够声明多个方法，一个struct也能有多个impl 关联函数impl能够声明不以self作为参数的函数，被称为关联函数。可以理解成其他语言的静态方法 12345678impl Rectangle &#123; fn square(size: u32) -&gt; Rectangle &#123; Rectangle &#123; width: size, height: size &#125; &#125;&#125;// 调用let sq = Rectangle::square(3) 使用::来调用关联函数。","categories":[{"name":"Rust","slug":"Rust","permalink":"https://zxffan.github.io/categories/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://zxffan.github.io/tags/Rust/"},{"name":"语言学习","slug":"语言学习","permalink":"https://zxffan.github.io/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"前端性能指标","slug":"experience/前端性能指标","date":"2021-03-10T16:00:00.000Z","updated":"2021-06-29T14:03:31.487Z","comments":true,"path":"posts/d43bedc2.html","link":"","permalink":"https://zxffan.github.io/posts/d43bedc2.html","excerpt":"","text":"性能指标google的Core Web Vitals主要由三个性能指标组成 LCP(Largest Contentful Paint)：最大内容绘制 FID(First Input Delay)：首次输入延迟 CLS(Cumlative Layout Shift)：累积布局偏移 除此之外，还有一些常见性能指标： FCP(First Contentful Paint)：首次内容绘制 TTFB(Time to First Byte)：首字节时间 Web VitalsWeb Vitals是google发起的倡议，为web性能提供统一的衡量标准。它有三部分组成——LCP、FID和CLS。 Largest Contentful Paint (LCP): 用于衡量加载性能。考虑到用户体验，LCP应该在2.5s内 First Input Delay (FID): 用来衡量网站的交互性。考虑到用户体验，FID应该小于100ms Cumulative Layout Shift (CLS): 用来衡量网站的视觉稳定性。考虑到用户体验，CLS应该小于0.1 衡量一个网站的性能：如果一个网站有**75%**的页面能达到GOOD标准，那么该网站就满足GOOD级别的性能。 这三个性能数据都可以通过 Google开源的web-vitals lighthouse 来测量。 Largest Contentful Paint(LCP)最大内容绘制时间是指网页最大图像/文本块的绘制时间。当一个页面的最大丰富内容元素绘制完成了，就几乎可以认为是该页面渲染完成。LCP认为的最大丰富内容元素有： img元素 svg里的image元素 video元素 css中url()加载的图片 包含文本元素的块级元素 分阶段加载页面的加载是分阶段的，页面上的最大元素可能会发生变化。 当页面首帧绘制完毕后，浏览器会实例一个化PerformanceEntry对象，并且将其entryType属性设置为largest-contentful-paint。用于标识首帧元素的绘制 当页面出现新的最大元素时，又会再创建一个PerformancenEntry对象。如何有任何元素大于大于上一个最大元素，就会创建一个PerformanceEntry对象 FCP是值首次内容绘制时间，指的是页面出现第一个绘制完成元素的时间。所以FCP比LCP要快。 影响LCP的因素 服务端响应慢 css和js阻塞渲染 资源加载时间 客户端渲染 First Input Delay首次输入延迟（FID）度量标准有助于衡量用户对网站的交互性和响应性的第一印象。 FID衡量的是从用户首次与页面进行交互（即当他们单击链接，点击按钮或使用自定义的JavaScript事件）到浏览器实际上能够开始处理事件处理程序的时间 FID仅在事件处理中测量“延迟”。它不会测量事件处理时间本身。 当用户第一次与页面交互（例如点击页面）。但是这时JS线程正在执行，它会阻塞渲染线程的执行，所以此时，页面是没有给用户反馈的。这段时间就是FID 要再强调首次，FID只衡量第一次的交互。第一个输入延迟将是用户对您网站的响应度的第一印象，而第一印象对于塑造我们对网站质量和可靠性的整体印象至关重要。 再次强调FID只测量输入延迟，记录首次交互到事件开始的事件，并不记录事件执行的事件。 Cumlative Layout Shift累积布局偏移会测量在页面整个生命周期中发生的每个意外的布局移位的所有个别布偏移分数的总和 布局偏移是指页面上的课件元素下一阵偏移到其它位置。 布局偏移分数Layout Shift Score计算，是通过视窗口中两个渲染帧之间元素的运动，取该运动中两个度量的乘积：冲击分数（Impact Fraction）和距离分数（Distance Fraction） $layout shift score = impact fraction * distance fraction$ Impact Fraction 在上图中，有一个元素在一帧中占据了视口的一半。然后，在下一帧中，元素下移视口高度的25％。红色的虚线矩形表示两个帧中元素的可见区域的并集，在这种情况下，其为总视口的75％，因此其影响分数为0.75。 Distance Fraction 在上面的示例中，最大视口尺寸是高度，不稳定元素已移动了视口高度的25％，这使得距离分数为0.25。 因此，在此示例中，碰撞分数为0.75，距离分数为0.25，因此布局偏移分数为0.75 * 0.25 = 0.1875。 如何改善CLS 对于大多数网站，可以遵循一些指导原则来避免所有意外的布局变化： 务必确保图片和视频元素有正确的尺寸，通过padding-top实现宽高等比例，容器内容使用绝对定位 除非响应用户交互，否则切勿在现有内容上方插入内容。这样可以确保可以预期发生任何版式移位。 与将动画（animation）触发布局更改的属性动画相比，转换（transform）动画更可取。对过渡进行动画处理，以提供状态与状态之间的上下文和连续性。 First Contentful Paint首次内容绘制衡量页面开始加载到页面首个元素渲染完成的事件。通常可以用来代表网页的白屏时间。通常LCP时间是大于或等于FCP时间 Time To First Bytes首字节时间是指客户端（浏览器）接收到服务端发来的第一个字节所经历的时间。包括DNS解析、TCP三次握手、TLS协商以及服务端处理请求 其它性能数据通过performance对象，能获取到详细的网页性能数据 performance.timing对象结构： 123456789101112131415161718192021222324interface PerformanceTiming &#123; readonly connectEnd: number; readonly connectStart: number; readonly domComplete: number; readonly domContentLoadedEventEnd: number; readonly domContentLoadedEventStart: number; readonly domInteractive: number; readonly domLoading: number; readonly domainLookupEnd: number; readonly domainLookupStart: number; readonly fetchStart: number; readonly loadEventEnd: number; readonly loadEventStart: number; readonly navigationStart: number; readonly redirectEnd: number; readonly redirectStart: number; readonly requestStart: number; readonly responseEnd: number; readonly responseStart: number; readonly secureConnectionStart: number; readonly unloadEventEnd: number; readonly unloadEventStart: number; toJSON(): any;&#125; timing对象提供了各种与浏览器处理相关的时间数据。具体如下表 名称 作用（这里所有时间戳都代表UNIX毫秒时间戳） connectEnd 浏览器与服务器之间的连接建立时的时间戳，连接建立指的是所有握手和认证过程全部结束 connectStart HTTP请求开始向服务器发送时的时间戳，如果是持久连接，则等同于fetchStart。 domComplete 当前网页DOM结构生成时，也就是Document.readyState属性变为“complete”,并且相应的readystatechange事件触发时的时间戳。 domContentLoadedEventEnd 当前网页DOMContentLoaded事件发生时，也就是DOM结构解析完毕、所有脚本运行完成时的时间戳。 domContentLoadedEventStart 当前网页DOMContentLoaded事件发生时，也就是DOM结构解析完毕、所有脚本开始运行时的时间戳。 domInteractive 当前网页DOM结构结束解析、开始加载内嵌资源时，也就是Document.readyState属性变为“interactive”、并且相应的readystatechange事件触发时的时间戳。 domLoading 当前网页DOM结构开始解析时,也就是Document.readyState属性变为“loading”、并且相应的readystatechange事件触发时的时间戳。 domainLookupEnd 域名查询结束时的时间戳。如果使用持久连接，或者从本地缓存获取信息的，等同于fetchStart domainLookupStart 域名查询开始时的时间戳。如果使用持久连接，或者从本地缓存获取信息的，等同于fetchStart fetchStart 浏览器准备通过HTTP请求去获取页面的时间戳。在检查应用缓存之前发生。 loadEventEnd 当前网页load事件的回调函数结束时的时间戳。如果该事件还没有发生，返回0。 loadEventStart 当前网页load事件的回调函数开始时的时间戳。如果该事件还没有发生，返回0。 navigationStart 当前浏览器窗口的前一个网页关闭，发生unload事件时的时间戳。如果没有前一个网页，就等于fetchStart redirectEnd 最后一次重定向完成，也就是Http响应的最后一个字节返回时的时间戳。如果没有重定向，或者上次重定向不是同源的。则为0 redirectStart 第一次重定向开始时的时间戳，如果没有重定向，或者上次重定向不是同源的。则为0 requestStart 浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的时间戳。 responseEnd 浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的时间戳 responseStart 浏览器从服务器收到（或从本地缓存读取）第一个字节时的时间戳。 secureConnectionStart 浏览器与服务器开始安全链接的握手时的时间戳。如果当前网页不要求安全连接，则返回0。 unloadEventEnd 如果前一个网页与当前网页属于同一个域下，则表示前一个网页的unload回调结束时的时间戳。如果没有前一个网页，或者之前的网页跳转不是属于同一个域内，则返回值为0。 unloadEventStart 如果前一个网页与当前网页属于同一个域下，则表示前一个网页的unload事件发生时的时间戳。如果没有前一个网页，或者之前的网页跳转不是属于同一个域内，则返回值为0。 常用指标计算公式如下 DNS解析耗时: domainLookupEnd - domainLookupStart TCP连接耗时: connectEnd - connectStart SSL安全连接耗时: connectEnd - secureConnectionStart 网络请求耗时(TTFB): responseStart - requestStart 数据传输耗时: responseEnd - responseStart DOM解析耗时: domInteractive - responseEnd 资源加载耗时: loadEventStart - domContentLoadedEventEnd 首包时间: responseStart - domainLookupStart 首次渲染时间 / 白屏时间: responseEnd - fetchStart 首次可交互时间: domInteractive - fetchStart DOM Ready时间: domContentLoadEventEnd - fetchStart 页面完全加载时间: loadEventStart - fetchStart","categories":[{"name":"experience","slug":"experience","permalink":"https://zxffan.github.io/categories/experience/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://zxffan.github.io/tags/Nodejs/"},{"name":"网络","slug":"网络","permalink":"https://zxffan.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"vue3-依赖注入","slug":"sourcecode/vue3-依赖注入","date":"2021-03-07T16:00:00.000Z","updated":"2021-06-29T14:07:29.056Z","comments":true,"path":"posts/dafb6b4a.html","link":"","permalink":"https://zxffan.github.io/posts/dafb6b4a.html","excerpt":"","text":"如何使用在setup中使用： 123456789101112131415161718// 生产组件import &#123; defineComponent, provide, inject, ref &#125; from &quot;vue&quot;;defineComponent(&#123; setup() &#123; const name = ref(&quot;name&quot;); provide(&quot;name&quot;, name); &#125;,&#125;);// 消费组件defineComponent(&#123; setup() &#123; const name = inject(&quot;name&quot;); // 会保留响应式 return &#123; name &#125;; &#125;,&#125;); 全局provide 12345import &#123; createApp &#125; from &quot;vue&quot;;const app = createApp()app.provide(name, &#x27;ZXFAN&#x27;) 处理过程在父组件的setup中使用provide函数，会在放在组件实例上的provides对象上。注意：每个组件实例上的provides对象的原型对象都是其父组件的provides对象，根组件的原型对象为null。这样在查找时，就会自动在原型链上寻找。 在子组件的setup中使用inject函数，会在组件实例上找，实例上没有就去原型链（父组件的provides对象）去找。 全局provide即app.provide(xx, xx)的形式，会将注入的内容存放在上下文对象的providers上 provides原型链的形成具有嵌套的组件的provides对象构成了原型链，这是为了方便做查找操作 原型链的最顶是null，这是在创建应用上下文对象时初始化的。 1234567891011121314151617181920// runtime-core/src/apiCreateApp.tsexport function createAppContext(): AppContext &#123; return &#123; app: null as any, config: &#123; isNativeTag: NO, performance: false, globalProperties: &#123;&#125;, optionMergeStrategies: &#123;&#125;, isCustomElement: NO, errorHandler: undefined, warnHandler: undefined &#125;, mixins: [], components: &#123;&#125;, directives: &#123;&#125;, provides: Object.create(null) &#125;&#125; Object.create(null)会创建并返回一个空对象，并且将这个空对象的原型对象设置为参数null。 然后是组件实例创建时，会自动初始化provides对象。 12345678910111213141516export function createComponentInstance( vnode: VNode, parent: ComponentInternalInstance | null, suspense: SuspenseBoundary | null) &#123; // ... const instance: ComponentInternalInstance = &#123; // ... provides: parent ? parent.provides : Object.create(appContext.provides), // ... &#125; //... return instance&#125; 显示判断是否存在父组件，若存在直接取父组件的provides对象若没有父组件，则说明是根组件，则取上下文对象的provides对象 provide函数123456789101112131415161718192021// runtime-core/src/apiInject.tsexport function provide&lt;T&gt;(key: InjectionKey&lt;T&gt; | string | number, value: T) &#123; if (!currentInstance) &#123; if (__DEV__) &#123; warn(`provide() can only be used inside setup().`) &#125; &#125; else &#123; let provides = currentInstance.provides // 默认，实例会继承其父组件的原型对象 // 当组件本身需要provide，它会创建自己的provides对象，并将父组件的provides对象设为其原型对象 // 这样在使用inject函数注入时，就能利用原型链自动向父组件查找。 const parentProvides = currentInstance.parent &amp;&amp; currentInstance.parent.provides if (parentProvides === provides) &#123; provides = currentInstance.provides = Object.create(parentProvides) &#125; // TS doesn&#x27;t allow symbol as index type provides[key as string] = value &#125;&#125; 当parentProvides === provides为true时，说明这是当前组件第一次调用provide函数。因为如果一个组件不需要provide，那么实例的provides就指向其父组件的provides对象。这样就缩短了原型链的长度。 inject函数12345678910111213141516171819202122232425262728293031export function inject( key: InjectionKey&lt;any&gt; | string, defaultValue?: unknown, treatDefaultAsFactory = false) &#123; // fallback to `currentRenderingInstance` so that this can be called in // a functional component const instance = currentInstance || currentRenderingInstance if (instance) &#123; // #2400 // to support `app.use` plugins, // fallback to appContext&#x27;s `provides` if the intance is at root const provides = instance.parent == null ? instance.vnode.appContext &amp;&amp; instance.vnode.appContext.provides : instance.parent.provides if (provides &amp;&amp; (key as string | symbol) in provides) &#123; // TS doesn&#x27;t allow symbol as index type return provides[key as string] &#125; else if (arguments.length &gt; 1) &#123; return treatDefaultAsFactory &amp;&amp; isFunction(defaultValue) ? defaultValue() : defaultValue &#125; else if (__DEV__) &#123; warn(`injection &quot;$&#123;String(key)&#125;&quot; not found.`) &#125; &#125; else if (__DEV__) &#123; warn(`inject() can only be used inside setup() or functional components.`) &#125;&#125; inject就是去provides对象找对应key的过程。注意：这里判断instance.parent == null是来判断当前组件是不是根组件。","categories":[{"name":"源码","slug":"源码","permalink":"https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://zxffan.github.io/tags/vue/"}]},{"title":"vue3-指令","slug":"sourcecode/vue3-指令","date":"2021-03-06T16:00:00.000Z","updated":"2021-06-29T14:07:31.738Z","comments":true,"path":"posts/c445157e.html","link":"","permalink":"https://zxffan.github.io/posts/c445157e.html","excerpt":"","text":"如何使用在根实例上注册全局指令 12345678import &#123; createApp &#125; from &quot;vue&quot;import App from &#x27;app.vue&#x27;const app = createApp(App)app.derectives(&quot;focus&quot;, &#123; // ...&#125;) 通过选项来注册局部指令 1234567891011import &#123; defineComponent &#125; from &quot;vue&quot;defineComponent(&#123; // ... directives: &#123; focus: &#123; // ... &#125; &#125; //...&#125;) 在template中使用： 123&lt;template&gt; &lt;input v-focus &#x2F;&gt;&lt;&#x2F;template&gt; 在render函数中使用 123456789101112import &#123; defineComponent, h, withDirectives, vShow &#125; from &quot;vue&quot;defineComponent(&#123; // ... data: &#123; value: true &#125;, render() &#123; return withDirectives(h(&quot;input&quot;), [vShow, this.value]) &#125; //...&#125;) withDirectives的函数签名： 第一个参数是VNode 第二个参数是指令（可以是自定义指令） 123function withDirectives&lt;T extends VNode&lt;RendererNode, RendererElement, &#123; [key: string]: any;&#125;&gt;&gt;(vnode: T, directives: DirectiveArguments): T 指令生命周期指令有两种类型——对象和函数 1234567891011121314151617export type Directive&lt;T = any, V = any&gt; = | ObjectDirective&lt;T, V&gt; | FunctionDirective&lt;T, V&gt;export interface ObjectDirective&lt;T = any, V = any&gt; &#123; created?: DirectiveHook&lt;T, null, V&gt; beforeMount?: DirectiveHook&lt;T, null, V&gt; mounted?: DirectiveHook&lt;T, null, V&gt; beforeUpdate?: DirectiveHook&lt;T, VNode&lt;any, T&gt;, V&gt; updated?: DirectiveHook&lt;T, VNode&lt;any, T&gt;, V&gt; beforeUnmount?: DirectiveHook&lt;T, null, V&gt; unmounted?: DirectiveHook&lt;T, null, V&gt; getSSRProps?: SSRDirectiveHook&#125;export type FunctionDirective&lt;T = any, V = any&gt; = DirectiveHook&lt;T, any, V&gt; 对象就是声明指令的每个生命周期 函数，只会生命mounted和update 一个指令定义对象可以提供如下几个钩子函数 (均为可选)： created：在绑定元素的 attribute 或事件监听器被应用之前调用。在指令需要附加须要在普通的 v-on 事件监听器前调用的事件监听器时，这很有用。 beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用。 mounted：在绑定元素的父组件被挂载后调用。 beforeUpdate：在更新包含组件的 VNode 之前调用。 updated：在包含组件的 VNode 及其子组件的 VNode 更新后调用。 beforeUnmount：在卸载绑定元素的父组件之前调用 unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次。 处理过程全局注册指令，会在上下文对象上的directives（Array类型）中添加指令 局部指令注册，会将指令存放在组件实例 在template中使用指令，构建工具将其转换成render函数。 运行时，先去app上下文或者组件实例上寻找指令。然后将指令绑定到VNode。每个VNode都会有一个dirs数组，用来存放绑定到该VNode的全部指令。 最后在各个阶段执行指令相应的生命周期函数 注册流程全局注册12345678import &#123; createApp &#125; from &quot;vue&quot;import App from &#x27;app.vue&#x27;const app = createApp(App)app.derectives(&quot;focus&quot;, &#123; // ...&#125;) 指令全局注册是通过createApp函数返回的app对象上的directives方法来注册的 观察一下createApp函数 1234567891011121314151617181920212223242526272829303132333435// runtime-core/src/apiCreateApp.tsexport function createAppAPI&lt;HostElement&gt;( render: RootRenderFunction, hydrate?: RootHydrateFunction): CreateAppFunction&lt;HostElement&gt; &#123; return function createApp(rootComponent, rootProps = null) &#123; const context = createAppContext() const installedPlugins = new Set() let isMounted = false const app: App = (context.app = &#123; // 省略其它代码... directive(name: string, directive?: Directive) &#123; if (__DEV__) &#123; validateDirectiveName(name) &#125; if (!directive) &#123; return context.directives[name] as any &#125; if (__DEV__ &amp;&amp; context.directives[name]) &#123; warn(`Directive &quot;$&#123;name&#125;&quot; has already been registered in target app.`) &#125; context.directives[name] = directive return app &#125; // 省略其它代码... &#125;) return app &#125;&#125; directive函数做了三件事 通过validateDirectiveName函数吗，判断是否是内置指令(v-if、v-show等)。如果是，在开发环境下会报一个警告 如果只传了name，认为是取指令操作并返回对应name的指令。如果传了directive则认为是注册指令操作 注册指令：在context.directives对象上保存指令 context是一个上下文对象。通过createAppContext函数创建的 局部注册选择局部注册的方式，指令写在directives选项中。单文件组件会通过构建工具生成组件实例，也等价于defineComponent。在生成VNode时，将组件实例绑定到VNode的type属性上。 局部注册的指令存放在组件实例上。后续会通过VNode.type.directives来访问指令 绑定与执行在template模版上使用指令，如： 123&lt;template&gt; &lt;input v-focus &#x2F;&gt;&lt;&#x2F;template&gt; 构建工具编译生成render函数： 12345678910import &#123; resolveDirective as _resolveDirective, createVNode as _createVNode, withDirectives as _withDirectives, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;export function render(_ctx, _cache, $props, $setup, $data, $options) &#123; const _directive_focus = _resolveDirective(&quot;focus&quot;) return _withDirectives((_openBlock(), _createBlock(&quot;input&quot;, null, null, 512 /* NEED_PATCH */)), [ [_directive_focus] ])&#125; 可以看出，render内调用了两个方法： _resolveDirective：接受指令名称作为参数。该函数的作用是去app上下文或者组件实例上寻找指令 _withDirectives：将指令绑定到VNode上。 解析指令解析指令找到需要使用的指令，也就是resolveDirective的过程。分析源码，发现resolveDirective调用resolveAsset。 123456789101112131415161718192021222324252627282930313233343536373839// runtime-core/helpers/resolveAssets.tsconst COMPONENTS = &#x27;components&#x27;const DIRECTIVES = &#x27;directives&#x27;export function resolveDirective(name: string): Directive | undefined &#123; return resolveAsset(DIRECTIVES, name)&#125;function resolveAsset( type: typeof COMPONENTS | typeof DIRECTIVES, name: string, warnMissing = true) &#123; const instance = currentRenderingInstance || currentInstance if (instance) &#123; const Component = instance.type // 省略 组件处理... const res = // 局部注册 // check instance[type] first for components with mixin or extends. resolve(instance[type] || (Component as ComponentOptions)[type], name) || // 全局注册 resolve(instance.appContext[type], name) return res &#125;&#125;function resolve(registry: Record&lt;string, any&gt; | undefined, name: string) &#123; return ( registry &amp;&amp; (registry[name] || registry[camelize(name)] || registry[capitalize(camelize(name))]) )&#125; instance是组件实例，instance.type等于VNode.type即组件实例（也就是注册局部指令的地方）。instance.appContext是全局上下文（也就是注册全局指令的地方） 解析组件的过程： 先寻找局部注册的指令，在组件实例instance上寻找，找不到去组件实例（instance.type）去找。 如果找不到局部注册指令，就寻找全局注册指令。直接在上下文对象intance.appContext上找 可以发现，局部注册的指令会覆盖全局注册指令。 绑定指令绑定指令到VNode是通过withDirectives函数实现的 123456789101112131415161718192021222324252627282930313233343536373839404142// runtime-cor/src/directives.tsexport type DirectiveArguments = Array&lt; | [Directive] | [Directive, any] | [Directive, any, string] | [Directive, any, string, DirectiveModifiers]&gt;/** * Adds directives to a VNode. */export function withDirectives&lt;T extends VNode&gt;( vnode: T, directives: DirectiveArguments): T &#123; const internalInstance = currentRenderingInstance if (internalInstance === null) &#123; __DEV__ &amp;&amp; warn(`withDirectives can only be used inside render functions.`) return vnode &#125; const instance = internalInstance.proxy const bindings: DirectiveBinding[] = vnode.dirs || (vnode.dirs = []) for (let i = 0; i &lt; directives.length; i++) &#123; let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i] if (isFunction(dir)) &#123; dir = &#123; mounted: dir, updated: dir &#125; as ObjectDirective &#125; bindings.push(&#123; dir, instance, value, oldValue: void 0, arg, modifiers &#125;) &#125; return vnode&#125; withDirectives函数遍历了directives数组，并将其元素绑定到VNode.dirs上。 特别注意：如果指令是一个函数，只会给mounted和updated赋值，并且执行逻辑是一样的。 指令对象的结构： instance：使用指令的组件实例。 value：传递给指令的值。例如，在 v-my-directive=&quot;1 + 1&quot; 中，该值为 2。 oldValue：先前的值，仅在 beforeUpdate 和 updated 中可用。值是否已更改都可用。 arg：参数传递给指令 (如果有)。例如在 v-my-directive:foo 中，arg 为 &quot;foo&quot;。 modifiers：包含修饰符 (如果有) 的对象。例如在 v-my-directive.foo.bar 中，修饰符对象为 &#123;foo: true，bar: true&#125;。 dir：一个对象，在注册指令时作为参数传递。例如，在以下指令中 执行指令指令绑定到VNode后，就会在相应的时候调用指令 观察指令的类型签名，有两种——对象指令，和函数指令。其中对象指令声明了很多hook(钩子函数)，这些是指令的生命周期。 比如，在mountElement函数中就有很多触发指令的代码，例如： 1234567// runtime-core/src/render.ts// function mountElementif (dirs) &#123; invokeDirectiveHook(vnode, null, parentComponent, &#x27;created&#x27;)&#125; invokeDirectiveHook是用来触发指令，它和withDirectives都位于runtime-core/src/directives.ts文件中。 123456789101112131415161718192021222324export function invokeDirectiveHook( vnode: VNode, prevVNode: VNode | null, instance: ComponentInternalInstance | null, name: keyof ObjectDirective) &#123; const bindings = vnode.dirs! const oldBindings = prevVNode &amp;&amp; prevVNode.dirs! for (let i = 0; i &lt; bindings.length; i++) &#123; const binding = bindings[i] if (oldBindings) &#123; binding.oldValue = oldBindings[i].value &#125; const hook = binding.dir[name] as DirectiveHook | undefined if (hook) &#123; callWithAsyncErrorHandling(hook, instance, ErrorCodes.DIRECTIVE_HOOK, [ vnode.el, binding, vnode, prevVNode ]) &#125; &#125;&#125; 每个生命周期钩子的执行都会传入4个参数 el： vnode对应的element元素 binding：当前vnode绑定的所有指令对象 vnode：虚拟节点 prevVNode：上一个虚拟节点，仅在 beforeUpdate 和 updated 钩子中可用 v-model指令vue内置了众多指令，其中v-model用来实现双向绑定。 v-model不是单指一个指令当在template中使用v-model: 123456&lt;input v-model&#x3D;&quot;username&quot;&#x2F;&gt;&lt;input type&#x3D;&quot;radio&quot; v-model&#x3D;&quot;gender&quot;&#x2F;&gt;&lt;input type&#x3D;&quot;checkbox&quot; v-model&#x3D;&quot;gender&quot;&#x2F;&gt;&lt;!-- 自定义组件 --&gt;&lt;my-component v-model&#x3D;&quot;isShow&quot;&#x2F;&gt; 被构建工具编译后的渲染函数 12345678910111213141516171819202122232425262728293031import &#123; vModelText as _vModelText, createVNode as _createVNode, withDirectives as _withDirectives, vModelRadio as _vModelRadio, vModelCheckbox as _vModelCheckbox, resolveComponent as _resolveComponent, Fragment as _Fragment, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;export function render(_ctx, _cache, $props, $setup, $data, $options) &#123; const _component_my_component = _resolveComponent(&quot;my-component&quot;) return (_openBlock(), _createBlock(_Fragment, null, [ _withDirectives(_createVNode(&quot;input&quot;, &#123; &quot;onUpdate:modelValue&quot;: $event =&gt; (_ctx.username = $event) &#125;, null, 8 /* PROPS */, [&quot;onUpdate:modelValue&quot;]), [ [_vModelText, _ctx.username] ]), _withDirectives(_createVNode(&quot;input&quot;, &#123; type: &quot;radio&quot;, &quot;onUpdate:modelValue&quot;: $event =&gt; (_ctx.gender = $event) &#125;, null, 8 /* PROPS */, [&quot;onUpdate:modelValue&quot;]), [ [_vModelRadio, _ctx.gender] ]), _withDirectives(_createVNode(&quot;input&quot;, &#123; type: &quot;checkbox&quot;, &quot;onUpdate:modelValue&quot;: $event =&gt; (_ctx.gender = $event) &#125;, null, 8 /* PROPS */, [&quot;onUpdate:modelValue&quot;]), [ [_vModelCheckbox, _ctx.gender] ]), _createVNode(_component_my_component, &#123; modelValue: _ctx.isShow, &quot;onUpdate:modelValue&quot;: $event =&gt; (_ctx.isShow = $event) &#125;, null, 8 /* PROPS */, [&quot;modelValue&quot;, &quot;onUpdate:modelValue&quot;]) ], 64 /* STABLE_FRAGMENT */))&#125;// Check the console for the AST 可以观察到，渲染函数使用withDirectives分别给三个input元素绑定了三个指令vModelText、vModelRadio、vModelCheckbox。然而并未给组件绑定指令。 不同元素的v-model行为不一样针对不同元素，实现双向绑定的方式不同。默认情况下: 针对组件，传递modelValue，并监听update:modelValue事件 针对文本输入框，vModelText会将值绑定到value属性，并监听input或chang(有lazy修饰符)事件 针对单选按钮和复选框，vModelRadio和vModelCheckobx都会将值绑定到checked属性，并监听其change事件 针对下拉框，vModelSelect会遍历所有option并对比option的value属性与v-model的值是否一致，若一致给该option添加selected=true。并监听change事件响应更改。 这些v-model指令的源码位于runtime-dom/src/directives/vModel.ts，看一下vModelText的源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// v-model和其它指令一样会绑定到VNode上// 如果不使用v-model，这部分代码会被tree-shakingexport const vModelText: ModelDirective&lt; HTMLInputElement | HTMLTextAreaElement&gt; = &#123; created(el, &#123; modifiers: &#123; lazy, trim, number &#125; &#125;, vnode) &#123; el._assign = getModelAssigner(vnode) const castToNumber = number || el.type === &#x27;number&#x27; addEventListener(el, lazy ? &#x27;change&#x27; : &#x27;input&#x27;, e =&gt; &#123; if ((e.target as any).composing) return let domValue: string | number = el.value if (trim) &#123; domValue = domValue.trim() &#125; else if (castToNumber) &#123; domValue = toNumber(domValue) &#125; el._assign(domValue) &#125;) if (trim) &#123; addEventListener(el, &#x27;change&#x27;, () =&gt; &#123; el.value = el.value.trim() &#125;) &#125; if (!lazy) &#123; addEventListener(el, &#x27;compositionstart&#x27;, onCompositionStart) addEventListener(el, &#x27;compositionend&#x27;, onCompositionEnd) // Safari &lt; 10.2 &amp; UIWebView doesn&#x27;t fire compositionend when // switching focus before confirming composition choice // this also fixes the issue where some browsers e.g. iOS Chrome // fires &quot;change&quot; instead of &quot;input&quot; on autocomplete. addEventListener(el, &#x27;change&#x27;, onCompositionEnd) &#125; &#125;, // set value on mounted so it&#x27;s after min/max for type=&quot;range&quot; mounted(el, &#123; value &#125;) &#123; el.value = value == null ? &#x27;&#x27; : value &#125;, beforeUpdate(el, &#123; value, modifiers: &#123; trim, number &#125; &#125;, vnode) &#123; el._assign = getModelAssigner(vnode) // avoid clearing unresolved text. #2302 if ((el as any).composing) return if (document.activeElement === el) &#123; if (trim &amp;&amp; el.value.trim() === value) &#123; return &#125; if ((number || el.type === &#x27;number&#x27;) &amp;&amp; toNumber(el.value) === value) &#123; return &#125; &#125; const newValue = value == null ? &#x27;&#x27; : value if (el.value !== newValue) &#123; el.value = newValue &#125; &#125;&#125; vModelTest声明了三个生命周期函数——created、mounted和beforeUpdate created 根据lazy来判断绑定input和change事件。在该事件下触发VNode上的onUpdate:modelValue事件来更新数据 如果绑定trim修饰符，每次input后修改value属性 如果没有lazy修饰符，会做组合键输入优化，这对中文输入很有效。在compositionend上触发input元素的input事件 mounted：将v-model的值绑定到input的value属性上 beforeUpdate：主要是对标签的一些属性进行更新","categories":[{"name":"源码","slug":"源码","permalink":"https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://zxffan.github.io/tags/vue/"}]},{"title":"手撕Promise","slug":"JavaScript/手撕Promise","date":"2021-03-02T16:00:00.000Z","updated":"2021-06-29T14:05:17.332Z","comments":true,"path":"posts/d884e9d5.html","link":"","permalink":"https://zxffan.github.io/posts/d884e9d5.html","excerpt":"","text":"Promise快速回顾Promise是一个用来处理异步任务的强大的API。 三种状态Promise有三种状态: pending: 等待状态 fulfilled: 完成状态（终态） rejected: 拒绝状态（终态） promise的状态只会改变一次，从pending-&gt;fullfilled或者从pending-&gt;rejected。状态是不可逆的。 Promise原型方法一个Promise对象的原型有三个方法，它们都接受一个回调函数作为参数 Promise.prototype.then(onFulfilled, onRejected)：当pending-&gt;fullfilled时触发then的onFulfilled Promise.prototype.catch(onRejected)：当pending-&gt;rejected时出发catch Promise.prototype.finally(onFinally)：当状态为终态时，最后一定会触发finally then和catch的回调函数一定会返回一个Promise 当直接reutrn a; 相当于 return Promise.resolve(a) 当直接throw err; 相当于 return Promise.reject(err) 当直接return pormise；那么就返回这个promise对象 Promise的方法 Promise.all(iterable) all接受一个可迭代对象（例如数组）。每个迭代元素可以是Promise也可以不是Promise 如果迭代元素是Promise会被依次执行。 如果所有Promise成功执行，则状态修改成fulfilled，并将可迭代对象的所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致。 如果这个新的promise对象触发了失败状态（rejected），它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息 无论最终状态是fulfilled还是rejected，iterable中所有Promise都会被执行。因为Promise被定义时就会执行。 Promise.allSettled(iterable) 与Promise.all十分类似，区别在于： 当发生rejected时，promise.all直接把第一个失败的promise对象的错误信息返回而promise.allSettled会等所有promise全部执行后在返回 结果数组不是promise执行结果的集合，而是状态集合 [fulfilled, rejected, fulfilled] Promise.any(iterable) 接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。 Promise.race(iterable) 当iterable参数里的任意一个子promise被成功或失败后，以这个promise返回 Promise.reject(reason) 返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法 Promise.resolve(value) 返回一个状态由给定value决定的Promise对象。 如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定； 否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。 通常而言，如果不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。 手写Promise我们要写一个符合Promise/A+规范的Promise 基础结构先看一个如何使用的Demo 123456789101112new FakePromise&lt;any&gt;((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&quot;进入setTimeout&quot;) resolve() &#125;, 1000) console.log(&quot;FakePromise&quot;)&#125;).then((res) =&gt; &#123; console.log(res) throw &quot;发生错误了&quot;&#125;).catch(err =&gt; &#123; console.log(err)&#125;) 根据api，先写出基础结构 12345678910111213141516171819202122232425262728293031323334interface IPromiseCallback &#123; (resolve: Function, reject: Function): void;&#125;// Promise的三种状态const PENDING = &quot;pending&quot;;const FULFILLED = &quot;fulfilled&quot;;const REJECTED = &quot;rejected&quot;;class FakePromise&lt;T&gt; &#123; private state: string; // 保存promise状态 private value!: T; // resolve的值 private reason: any; // reject的值 constructor(executor: IPromiseCallback) &#123; this.state = PENDING; const resolve = (value: T) =&gt; &#123; &#125;; const reject = (reason?: any) =&gt; &#123; &#125;; try &#123; executor(resolve, reject); &#125; catch (err) &#123; reject(err); &#125; &#125; then(onFulfilled: Function, onRejected: Function) &#123;&#125; catch(onRejected: Function) &#123;&#125;&#125; 当执行new FakePromise时，立即修改状态（Pending）。然后执行回调（可以看出Promise一旦被创建就会立即执行），并传入两个参数resolve和reject FakePromise的回调中会调用resolve或者reject函数，接下来完善resolve和reject 123456789101112131415161718// ...const resolve = (value: T) =&gt; &#123; setTimeout(() =&gt; &#123; if (this.state !== PENDING) return; this.value = value; this.state = FULFILLED &#125;)&#125;;const reject = (reason?: any) =&gt; &#123; setTimeout(() =&gt; &#123; if (this.state !== PENDING) return; this.reason = reason; this.state = REJECTED &#125;)&#125;;// ... 此处目前做了三个工作： resolve和reject应该都是异步的，所以这里用setTimout来模拟。 保存value和reason的值 更改promise的状态 then由于resolve的执行是异步的，此时应该先调用同步的then 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class FakePromise&lt;T&gt; &#123; //... private onFulfilledFns: Function[] = []; private onRejectedFns: Function[] = []; // ... then(onFulfilled?: (res: T) =&gt; any, onRejected?: Function) &#123; onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : (x) =&gt; x; onRejected = typeof onRejected === &quot;function&quot; ? onRejected : (x: any) =&gt; &#123; throw x; &#125;; const promise = new FakePromise((resolve, reject) =&gt; &#123; switch (this.state) &#123; case FULFILLED: setTimeout(() =&gt; &#123; try &#123; resolve(onFulfilled!(this.value)) &#125; catch (err) &#123; reject(err); &#125; &#125;); break; case REJECTED: setTimeout(() =&gt; &#123; try &#123; resolve(onRejected(this.reason)); &#125; catch (err) &#123; reject(err); &#125; &#125;); break; case PENDING: // store and wait this.onFulfilledFns.push(() =&gt; &#123; try &#123; resolve(onFulfilled(this.value)); &#125; catch (err) &#123; reject(err); &#125; &#125;); this.onRejectedFns.push(() =&gt; &#123; try &#123; resolve(onRejected(this.reason)); &#125; catch (err) &#123; reject(err); &#125; &#125;); break; &#125; &#125;); return promise; &#125; // ...&#125; then函数： 第一步，对两个参数进行处理，如果不是函数就赋一个默认值（函数） 然后定义了一个FakePromise并最终将其返回，因为then就是应该返回一个Promise，这样才能挂载多个then从而链式调用 分别对每个状态进行处理，无论什么状态都是异步的 fulfilled：直接调用onFulfilled，传入value并捕获起异常 rejected：直接调用onRejected，传入reason并捕获起异常 pending：说明当执行then时，（异步）promise还在执行。那我们就需要把回调存下来，存到onFulfilledFns和onRejectedFns中，注意它们必须是数组，因一个为FakePromise可以有多个then。等到（异步）promise执行完毕（resolve或者rejected）时再去调用。 pending状态的回调已经保存下来了。我们需要再resolve和reject中去处理 1234567891011121314151617181920// ...const resolve = (value: T) =&gt; &#123; setTimeout(() =&gt; &#123; if (this.state !== PENDING) return; this.value = value; this.state = FULFILLED this.onFulfilledFns.forEach((fn) =&gt; fn()); // 添加这一行 &#125;)&#125;;const reject = (reason?: any) =&gt; &#123; setTimeout(() =&gt; &#123; if (this.state !== PENDING) return; this.reason = reason; this.state = REJECTED this.onRejectedFns.forEach((fn) =&gt; fn()); // 添加这一行 &#125;)&#125;;// ... 就是遍历数组，执行每一个函数。 then的两个回调参数——onFulfilled和onRejected。的返回值有很多情况。我们目前没有对这些情况判断而是直接resolve(x)或者reject(x)（见上方代码） Promise/A+规范规定: 情况 1： x 等于 promise（当前的promise对象） 抛出一个 TypeError 错误，拒绝 promise。 情况 2：x 为 Promise 的实例 如果 x 处于等待状态，那么 promise 继续等待至 x 执行或拒绝，否则根据 x 的状态执行/拒绝 promise。 情况 3：x 为对象或函数 该情况的核心是取出 x.then 并调用，在调用的时候将 this 指向 x。将 then 回调函数中得到结果 y 传入新的 Promise 解决过程中，形成一个递归调用。其中，如果执行报错，则以对应的错误为原因拒绝 promise。 这一步是处理拥有 then() 函数的对象或函数，这类对象或函数我们称之为“thenable”。注意，它只是拥有 then() 函数，并不是 Promise 实例。 情况 4：如果 x 不为对象或函数 以 x 作为值，执行 promise。 接下来根据Promise/A+规范来实现resolvePromise函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class FakePromise&lt;T&gt; &#123; // ... private resolvePromise( promise: FakePromise&lt;any&gt;, x: any, resolve: Function, reject: Function ) &#123; // 情况1: x等于当前promise对象，直接抛出TypeError if (promise === x) &#123; return reject(new TypeError(&quot;x can not be equal to promise&quot;)); &#125; // 情况2：x是 FakePromise的实例 // 取决于x的状态 else if (x instanceof FakePromise) &#123; if (x.state === FULFILLED) &#123; resolve(x.value); &#125; else if (x.state === REJECTED) &#123; reject(x.reason); &#125; else &#123; // PENDING x.then((y) =&gt; &#123; this.resolvePromise(promise, y, resolve, reject); &#125;, reject); &#125; &#125; // 情况3: x是对象或者函数 else if ( x !== null &amp;&amp; (typeof x === &quot;object&quot; || typeof x === &quot;function&quot;) ) &#123; // excute记录是否执行过，防止重复执行 let executed: boolean = false; try &#123; // 取出 对象或函数（也是对象）的then属性 const then = x.then; // then是函数，执行 if (typeof then === &quot;function&quot;) &#123; // 然后执行 then.call( x, (y: any) =&gt; &#123; if (executed) return; executed = true; this.resolvePromise(promise, y, resolve, reject); &#125;, (e: any) =&gt; &#123; if (executed) return; executed = true; reject(e); &#125; ); &#125; // then不是函数，直接resolve else &#123; resolve(x); &#125; &#125; catch (e) &#123; if (executed) return; executed = true; reject(e); &#125; &#125; // 情况4: 其他情况，直接resolve else &#123; resolve(x); &#125; &#125; // ...&#125; 然后修改then函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778class FakePromise&lt;T&gt; &#123; //... private onFulfilledFns: Function[] = []; private onRejectedFns: Function[] = []; // ... then(onFulfilled?: (res: T) =&gt; any, onRejected?: Function) &#123; onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : (x) =&gt; x; onRejected = typeof onRejected === &quot;function&quot; ? onRejected : (x: any) =&gt; &#123; throw x; &#125;; const promise = new FakePromise((resolve, reject) =&gt; &#123; switch (this.state) &#123; case FULFILLED: setTimeout(() =&gt; &#123; try &#123; this.resolvePromise( promise, onFulfilled!(this.value), resolve, reject ); &#125; catch (err) &#123; reject(err); &#125; &#125;); break; case REJECTED: setTimeout(() =&gt; &#123; try &#123; this.resolvePromise( promise, onRejected!(this.reason), resolve, reject ); &#125; catch (err) &#123; reject(err); &#125; &#125;); break; case PENDING: // store and wait this.onFulfilledFns.push(() =&gt; &#123; try &#123; this.resolvePromise( promise, onFulfilled!(this.value), resolve, reject ); &#125; catch (err) &#123; reject(err); &#125; &#125;); this.onRejectedFns.push(() =&gt; &#123; try &#123; this.resolvePromise( promise, onRejected!(this.reason), resolve, reject ); &#125; catch (err) &#123; reject(err); &#125; &#125;); break; &#125; &#125;); return promise; &#125;&#125; 把之前所有resolve和reject的地方改成调用resolvePromise函数，该函数接受四个参数：当前then返回的promise对象，onFulfilled或onRejected的执行结果，resolve还有reject函数 catchcatch和then的第二个参数一样，用于捕获异常。 当then第二个参数没传，它会被默认赋值一个异常处理函数(x: any) =&gt; &#123; throw x &#125;，这里直接抛出异常。 12345678910111213141516new FakePromise((resolve, reject) =&gt; &#123; // p0 setTimeout((() =&gt; &#123; reject(&#x27;hi&#x27;) &#125;, 1000))&#125;).then(() =&gt; &#123; // p1 console.log(&#x27;p1&#x27;) return &#x27;p1 done&#x27;&#125;).then(() =&gt; &#123; // p2 console.log(&#x27;p2&#x27;) return &#x27;p2 done&#x27;&#125;).catch(err =&gt; &#123; console.log(err)&#125;) 在p0中reject。由于p0的then没有传onRejected。所以当执行then函数时，会默认赋一个抛出异常的函数。这个异常被p1的try catch捕获到了，进而p1也reject了。进而执行p1的onRejected，不过也没传，继续抛异常再reject。继续执行p2的onRejected。p2没有调用then函数了但是调用了catch函数。所以此时catch函数只要将其回调绑定到then函数的第二个参数（onRejected）上就可以被执行了。 123456789class FakePromise&lt;T&gt; &#123; // ... catch(onRejected: Function) &#123; return this.then(undefined, onRejected); &#125; // ...&#125; 调用catch会给当前Promise对象添加一个then函数并且传递了onRejected。 当promise链中有一个环节reject了。他就会一直向下寻找onRejected，直到找到为止。 如果catch执行之后返回一个fulfilled的promise，catch之后的then继续执行 如果catch执行之后返回一个rejected的promise，继续往后寻找onRejected finally无论promise最终状态是fulfilled还是rejected。finally都会执行。那我们在Promise链的最后去执行finally即可 123456789101112131415161718class FakePromise&lt;T&gt; &#123; // ... finally(onFinally: Function) &#123; this.then( (value: T) =&gt; &#123; onFinally(); return value; &#125;, (reason: any) =&gt; &#123; onFinally(); throw reason; &#125; ); &#125; // ...&#125; Promise.resolveresolve用来讲一个普通的变量包装成fulfilled的promise对象，处理过程需要符合Promise/A+规范，也就是那四种情况。 1234567891011121314class FakePromise&lt;T&gt; &#123; // ... static resolve(value: any) &#123; const promise = new FakePromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; this.prototype.resolvePromise(promise, value, resolve, reject); &#125;); &#125;); return promise; &#125; // ...&#125; Promise.rejectreject用来将一个普通的变量包装成rejected的promise对象，处理过程需要符合Promise/A+规范，也就是那四种情况。 123456789101112class FakePromise&lt;T&gt; &#123; // ... static reject(value: any) &#123; const promise = new FakePromise((resolve, reject) =&gt; &#123; reject(value); &#125;); return promise; &#125; // ...&#125; Promise.all直接上代码 12345678910111213141516171819class FakePromise&lt;T&gt; &#123; // ... static all(it: Array&lt;any&gt;) &#123; const result: Array&lt;any&gt; = []; let count = 0; return new FakePromise&lt;Array&lt;any&gt;&gt;((resolve, reject) =&gt; &#123; it.forEach((cb, index) =&gt; &#123; FakePromise.resolve(cb).then((res) =&gt; &#123; count++; result[index] = res; if (count === it.length) resolve(result); &#125;, reject); &#125;); &#125;); &#125; // ...&#125; 参数it应该是一个可迭代对象，为了简化就用数组来模拟。循环中使用FakePromise.resolve来将cb包装成Promise对象。当发生错误直接调用reject，。如果没有错误，当count等于it的长度（即it所有元素处理完毕）时，将结果result给resolve出去。 Promise.racerace就更简单了，当第一个promise执行后就直接resolve 123456789101112131415class FakePromise&lt;T&gt; &#123; // ... static race(it: Array&lt;any&gt;) &#123; return new FakePromise&lt;any&gt;((resolve, reject) =&gt; &#123; it.forEach((cb) =&gt; &#123; FakePromise.resolve(cb).then(res =&gt; &#123; resolve(res) &#125;, reject); &#125;); &#125;); &#125; // ...&#125; 十分重要：无论all还是race。传入的所有promise都会执行。只是有些promise可能不会添加then或者catch来处理 源码 async和await谁的语法糖？async和await是 ES2017 标准推出的用于处理异步操作的关键字。它是Generator函数（生成器函数）的语法糖 Generator函数是 ES6 提出的除 Promise 之外的另一种异步解决方案。 12345678910111213function* gen() &#123; console.log(&quot;first&quot;); yield 1; console.log(&quot;second&quot;); yield 2; console.log(&quot;third&quot;);&#125;const iterator = gen() // 返回一个迭代器对象iterator.next() // 返回 &#123; value: 1, done: false &#125;iterator.next() // 返回 &#123; value: 2, done: false &#125;iterator.next() // 返回 &#123; value: undefined, done: true &#125; async和await原理async/await 做的事情就是将 Generator函数转换成 Promise 123456789101112131415161718192021222324function generatorToPromise(generator: GeneratorFunction) &#123; return function () &#123; const iterator = generator.apply(this, Array.of(arguments)); return new Promise((resolve, reject) =&gt; &#123; function step(action: keyof typeof iterator, arg?: any): any &#123; try &#123; const &#123; value, done &#125; = iterator[action](arg); if (done) &#123; resolve(value); &#125; else &#123; return Promise.resolve(value).then( (val) =&gt; step(&quot;next&quot;, value), (err) =&gt; step(&quot;throw&quot;, err) ); &#125; &#125; catch (err) &#123; return reject(err); &#125; &#125; return step(&quot;next&quot;); &#125;); &#125;;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"https://zxffan.github.io/tags/Promise/"}]},{"title":"vue3-Emit分析","slug":"sourcecode/vue3-Emit分析","date":"2021-02-19T16:00:00.000Z","updated":"2021-06-29T14:07:35.682Z","comments":true,"path":"posts/9c1e6144.html","link":"","permalink":"https://zxffan.github.io/posts/9c1e6144.html","excerpt":"","text":"如何使用template中绑定自定义事件 123&lt;template&gt; &lt;child-component @show-info&#x3D;&quot;showInfo&quot; @delete.once&#x3D;&quot;deleteItem&quot;&#x2F;&gt;&lt;&#x2F;template&gt; 在child-component子组件中使用emit this.emit(&quot;show-info&quot;) 处理过程vue会将所有v-on指令绑定的事件全部存放到组件实例的props中，并对其改名, show-info会变成onShowInfo。这部分工作由构建工具完成。 如果没有使用template，而使用渲染函数，需要手动写成onShowInfo的形式 当在子组件中使用emit时，也是会先修改名称再去props中寻找相应事件并执行。 Emit函数emit函数用来触发事件，其源码位于rumtime-core/src/componentEmits.ts下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// ...export function emit( instance: ComponentInternalInstance, event: string, ...rawArgs: any[]) &#123; const props = instance.vnode.props || EMPTY_OBJ let args = rawArgs // ---------------------- // 此处是处理 update:xxx 事件的(v-model) const isModelListener = event.startsWith(&#x27;update:&#x27;) const modelArg = isModelListener &amp;&amp; event.slice(7) if (modelArg &amp;&amp; modelArg in props) &#123; const modifiersKey = `$&#123; modelArg === &#x27;modelValue&#x27; ? &#x27;model&#x27; : modelArg &#125;Modifiers` const &#123; number, trim &#125; = props[modifiersKey] || EMPTY_OBJ if (trim) &#123; args = rawArgs.map(a =&gt; a.trim()) &#125; else if (number) &#123; args = rawArgs.map(toNumber) &#125; &#125; // ---------------------- // 如果 event是 custom-event let handlerName = toHandlerKey(camelize(event)) // handlerName 变成 onCustomEvent let handler = props[handlerName] // 如果v-model update:xxx的事件，处理则不同 if (!handler &amp;&amp; isModelListener) &#123; // 如果 event是 update:modelValue handlerName = toHandlerKey(hyphenate(event)) // handlerName 变成 update:model-value handler = props[handlerName] &#125; if (handler) &#123; // 执行 函数 callWithAsyncErrorHandling( handler, instance, ErrorCodes.COMPONENT_EVENT_HANDLER, args ) &#125; // 寻找有没有 once修饰符的事件， // 如果有判断是否执行过，用emmited记录 // 如果有则直接返回，没有记录emited并执行 const onceHandler = props[handlerName + `Once`] if (onceHandler) &#123; if (!instance.emitted) &#123; ;(instance.emitted = &#123;&#125; as Record&lt;string, boolean&gt;)[handlerName] = true &#125; else if (instance.emitted[handlerName]) &#123; return &#125; callWithAsyncErrorHandling( onceHandler, instance, ErrorCodes.COMPONENT_EVENT_HANDLER, args ) &#125;&#125;//... 源码中有3种处理：v-model的update:xxx、自定义事件、once事件 v-model的update:xxx： 自定义事件：先修改event，再去props里寻找对应事件，调用 once：在instance.emited中记录调用次数，并在事件名称后加上Once emit函数会在组件实例创建是被挂载在组件实例上 1234567891011// runtime-core/src/componentsexport function createComponentInstance( vnode: VNode, parent: ComponentInternalInstance | null, suspense: SuspenseBoundary | null) &#123; // ... instance.emit = emit.bind(null, instance) // ...&#125; v-on事件处理通过vue-template-explore来观察一下如何处理自定义事件 &lt;child-component @show-info=&quot;showInfo&quot; @delete.once=&quot;deleteItem&quot;&gt;Hello&lt;/child-component&gt; 1234567891011121314151617import &#123; createTextVNode as _createTextVNode, resolveComponent as _resolveComponent, withCtx as _withCtx, createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;export function render(_ctx, _cache, $props, $setup, $data, $options) &#123; const _component_child_component = _resolveComponent(&quot;child-component&quot;) return (_openBlock(), _createBlock(_component_child_component, &#123; onShowInfo: _ctx.showInfo, onDeleteOnce: _ctx.deleteItem &#125;, &#123; default: _withCtx(() =&gt; [ _createTextVNode(&quot;Hello&quot;) ]), _: 1 /* STABLE */ &#125;, 8 /* PROPS */, [&quot;onShowInfo&quot;, &quot;onDeleteOnce&quot;]))&#125;// Check the console for the AST createBlock函数位于runtime-core/src/vnode.ts中。用来创建区块根节点。它的第二个参数就是props。可以观察到show-info变成了onShowInfo，delete变成了onDeleteOnce。 下面是createBlock的函数签名。 1234567function createBlock( type: VNodeTypes | ClassComponent, props?: Record&lt;string, any&gt; | null | undefined, children?: any, patchFlag?: number | undefined, dynamicProps?: string[] | undefined): VNode 与vue2的区别vue2的emit是挂载在vue.prototype上的方法 vue3的emit是挂载在实例上的方法","categories":[{"name":"源码","slug":"源码","permalink":"https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://zxffan.github.io/tags/vue/"}]},{"title":"Nodejs搭建vue服务端渲染","slug":"Server/Nodejs搭建vue srr框架","date":"2021-02-14T16:00:00.000Z","updated":"2021-06-29T14:07:15.738Z","comments":true,"path":"posts/af3ae610.html","link":"","permalink":"https://zxffan.github.io/posts/af3ae610.html","excerpt":"","text":"何为服务端渲染与服务端渲染相对应的是客户端渲染。区别他们的方法就是判断网页（具有完整HTML结构）是由服务端生成的还是由客户端生成。以vue为例： 客户端渲染：用户输入网址，服务端返回一个html文件（没有完整的HTML结构，通常只有&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;）。浏览器解析HTML，遇到许多script外链，进而请求这些脚本。然后再执行这些脚本，最终在生成相应dom节点。 服务端渲染：用户输入网址，服务端收到请求后。在服务端执行相关脚本，生成相应的dom节点。最后将渲染后的具有完整HTML结构的html文件直接发送给客户端浏览器。这时，浏览器就可以展示页面了，之后再解析HTML文件，请求外链脚本。比较重要的是客户端需要激活服务端生成的那些节点。 由此，服务端渲染相对于客户端有以下好处： 比客户端更快的首屏速度，快了请求下载脚本和执行脚本的时间 更好的SEO，服务器返回的是一个完整的HTML页面。 技术选型服务端渲染必须有一个服务端来担任渲染网页的职责。nodejs是最好的选择。 中间件系统：Koa Vue相关：vue、vuex、vue-router、vue-server-renderer 构建：webpak相关 开发语言：TypeScript 实现蓝图 首先项目是由webpack打包构建的，项目有两个入口文件server entry和client entry。一个用于服务端一个用于客户端。把服务端和客户端的公共逻辑（例如创建vue、vuex、vue-router实例）抽离出来放入app.js。 webpack构建后会生成两份bundle——server bundle和client bundle(manifest)。这两个文件会传递给vue-server-renderer用来创建render（渲染器），从而在服务端渲染出html。 源码地址 vue-server-renderer这是vue官方提供的一个服务端渲染工具。vue的ssr实现是基于它的。 配置webpack生成所需要的bundle和manifest 123456789101112131415import VueSSRServerPlugin from &quot;vue-server-renderer/server-plugin&quot;;import VueSSRClientPlugin from &quot;vue-server-renderer/client-plugin&quot;;// clientexport default &#123; // ...省略 plugins: [new VueSSRClientPlugin()], // ...省略&#125;// serverexport default &#123; // ...省略 plugins: [new VueSSRServerPlugin()], // ...省略&#125; vue-server-renderer提供两个plugin——server plugin和client plugin。前者会在打包过程中生成bundle文件，后者会生成manifest文件 使用例子： 1234567891011121314151617181920import &#123; createBundleRenderer &#125; from &quot;vue-server-renderer&quot;;// 这两个文件是webpack打包后自动生成的const bundle = require(&quot;../dist/vue-ssr-server-bundle.json&quot;);const clientManifest = require(&quot;../dist/vue-ssr-client-manifest.json&quot;);// 传入clientManifest和bundleconst renderer = createBundleRenderer( bundle, &#123; clientManifest, template: readFileSync(ab(&quot;./src/index.html&quot;))?.toString(), runInNewContext: false, basedir: ab(&quot;./dist&quot;), &#125;);// 使用// async functionconst html = await renderer.renderToString(context)// html 即 渲染后的html结构 一旦bundle和manifest配置完毕，vue-server-render会自动帮我们做很多工作，例如客户端激活。 还有需要在html模版文件中的body标签哪加上****，这样vue-server-renderer就会将生成的vue实例挂载在对应位置。 集成vue-router从两个角度来说： 一是服务端，当一个路由请求发送到服务端，这是路由匹配发生在服务端 12345678910111213141516171819202122232425262728293031323334353637// server entryimport &#123; createApp &#125; from &quot;./app&quot;;interface IServerContext &#123; url: string; state: any, meta: any&#125;export default function (ctx: IServerContext) &#123; const &#123; app, router, store &#125; = createApp(); // 此处创建vue实例 return new Promise&lt;typeof app&gt;((resolve, reject) =&gt; &#123; router.push(ctx.url); // 匹配路由 // 在onReady做一些处理操作 router.onReady(() =&gt; &#123; // 获得所有以已经匹配的组件 const matchedComponents = router.getMatchedComponents(); if (matchedComponents.length &lt;= 0) &#123; return reject(&#123; code: 404 &#125;); &#125;// 没有说明 没有匹配此路由的组件，返回404 // 我们约定存在 asyncData选项 // 它返回Promise，并且在服务端执行 // 当 asyncData执行完毕后才会生成html返回给客户端 Promise.all( matchedComponents.map((com: any) =&gt; &#123; if (com.asyncData !== undefined) &#123; return com.asyncData(&#123; store, router: router.currentRoute &#125;); &#125; &#125;) ).then(() =&gt; &#123; resolve(app); &#125;); &#125;, reject); &#125;);&#125; 二是客户端，当在客户端使用router跳转时，也需要去先执行asyncData，待其执行完毕后在返回页面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// client entry// ...// 处理路由 update的情况Vue.mixin(&#123; beforeRouteUpdate(to, from, next) &#123; Promise.all( to.matched.map((c) =&gt; &#123; const options = c.components.$options; const asyncData = (options as any).asyncData; if (asyncData) &#123; return asyncData(&#123; store: store, route: to, &#125;); &#125; &#125;) ).finally(next); &#125;,&#125;);router.onReady(() =&gt; &#123; router.beforeResolve((to, from, next) =&gt; &#123; const matched = router.getMatchedComponents(to); const prevMatched = router.getMatchedComponents(from); // 对比 两条路由下的组件有否有不同，若都相同就就直接跳转 let diffed = false; const activated = matched.filter((c, i) =&gt; &#123; return diffed || (diffed = prevMatched[i] !== c); &#125;); if (activated.length &lt;= 0) next(); // 这里可以显示加载器 const render = createLoading(); render .mount() .then(() =&gt; Promise.all( activated.map((c: any) =&gt; &#123; if (c.asyncData) return c.asyncData(&#123; store, router: to &#125;); &#125;) ) ) .then((res) =&gt; &#123; // TODO 将结果 合并到data选项 &#125;) .finally(() =&gt; &#123; // 这里可以关闭加载器 render.hide(); next(); &#125;); &#125;); app.$mount(&quot;#app&quot;);&#125;); 上面这种路由策略，是必须先asyncData执行完毕，再展示画面，这通常会有一个全屏的loading页。 还有一种策略是，直接显示页面，当aysncData执行完毕再将其填充组件，这样对于每一个组件都应该有一个loading状态。 集成vuex服务端收到路由请求，先匹配路由，执行asyncData，其可能会修改store的值。待所有路由组件的asyncData执行完毕后。会在返回给客户端的html中插入一段script 12345&lt;script&gt;window.__INITIAL_STATE__ = &#123; // state的值&#125;&lt;/script&gt; 客户端需要将**__INITIAL_STATE__**的值插入store实例中。 12345// client entryconst initalState = (window as any).__INITIAL_STATE__;if (initalState) &#123; store.replaceState(initalState);&#125; 在服务端中需要加上一段 1234567891011121314151617181920212223242526export default function (ctx: IServerContext) &#123; const &#123; app, router, store &#125; = createApp(); return new Promise&lt;typeof app&gt;((resolve, reject) =&gt; &#123; router.push(ctx.url); ctx.meta = app.$meta() router.onReady(() =&gt; &#123; const matchedComponents = router.getMatchedComponents(); if (matchedComponents.length &lt;= 0) &#123; return reject(&#123; code: 404 &#125;); &#125; Promise.all( matchedComponents.map((com: any) =&gt; &#123; if (com.asyncData !== undefined) &#123; return com.asyncData(&#123; store, router: router.currentRoute &#125;); &#125; &#125;) ).then(() =&gt; &#123; // 在上下文加上 state ctx.state = store.state resolve(app); &#125;); &#125;, reject); &#125;);&#125; 在服务端入口文件中导出的这个function，会在使用render.renderToString(context)是自动调用，其ctx对于传入的context参数。这个context也会被vue-server-render使用到。 开发环境的构建生产环境直接打包启用服务即可。 在开发环境下，需要实现热更新。当用户代码发生修改时，重新打包，并通过socket通知浏览器更新相应内容。 客户端的热更新：由于我们使用的是koa，所以这里使用koa-webpack插件，它集成了两个插件：webpack-dev-middleware：打包项目到内存中，并允许客户端访问到webpack-hot-client：实现热更新 12345678910// 获取webpack配置const clientConfig = createClientConfig();// 生成compilerconst clientCompiler = webpack(clientConfig);koaWebpack(&#123; compiler: clientCompiler, devMiddleware: &#123; publicPath: clientConfig.output?.publicPath, &#125;,&#125;).then((middleware) =&gt; app.use(middleware)); // 注册中间件 服务端的热更新，直接用webpack watch模式来打包。但是注意需要修改文件输出的文件系统，我们需要将打包后的文件放在内存中而不是磁盘上。 12345678910111213141516// * 处理服务端 更新获取bundleconst serverConfig = createServerConf();const serverCompiler = webpack(serverConfig);// 使用 memory-fs 来修改 webpack默认的文件系统const mfs = new MemoryFs();serverCompiler.outputFileSystem = mfs;// watch模式 打包serverCompiler.watch(&#123;&#125;, (err, stats) =&gt; &#123; if (err) throw err; const result = stats.toJson(); if (result.errors.length) return; // TODO 打包成功&#125;); css支持css的支持只需要有正确的webpack loader配置即可。 需要注意的是，使用vue-style-loader来代替style-loader。前者支持服务端渲染。 还有一个坑是，css-loader的默认配置与vue-style-loader冲突，需要关闭esModule 1234567891011121314151617181920export default &#123; // 省略 module: &#123; rules: [ &#123; test: /\\.css$/, use: [ isDev ? &quot;vue-style-loader&quot; : extractLoader, &#123; loader: &quot;css-loader&quot;, options: &#123; esModule: false, // 关闭 esModule &#125;, &#125;, ], &#125;, ], &#125;, // 省略&#125;; 还可以加上postcss-loader、sass-loader等 HEAD支持为了更好得支持SEO。提供了自定义head的能力。我们通过vue-meta来实现。 先注册插件 1234import Vue from &#x27;vue&#x27;import VueMeta from &#x27;vue-meta&#x27;Vue.use(VueMeta) 在服务端入口文件 123456789export default function (ctx: IServerContext) &#123; const &#123; app, router, store &#125; = createApp(); return new Promise&lt;typeof app&gt;((resolve, reject) =&gt; &#123; router.push(ctx.url); // 加上这句 ctx.meta = app.$meta() // 省略...&#125; 最后修改html模版文件 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &#123;&#123;&#123; meta.inject().title ? meta.inject().title.text() : &#x27;&#x27; &#125;&#125;&#125; &#123;&#123;&#123; meta.inject().meta ? meta.inject().meta.text() : &#x27;&#x27; &#125;&#125;&#125;&lt;/head&gt;&lt;body&gt; &lt;!--vue-ssr-outlet--&gt;&lt;/body&gt;&lt;/html&gt; 使用：在metaInfo选项中配置 123456export default &#123; metaInfo: &#123; title: &quot;Home页面&quot;, meta: [&#123; charset: &quot;utf-8&quot; &#125;, &#123; name: &quot;description&quot;, content: &quot;foo&quot; &#125;], &#125;,&#125; 客户端激活客户端激活的工作已经由vue-server-renderer完成了。我们分析一下它是如何实现的。 在服务端，由vue-server-renderer生成html。会在相应的html上打上标记，例如&lt;div id=&quot;app&quot; data-server-rendered=&quot;true&quot;&gt;。客户端识别到data-server-rendered属性，就会知道这部分html是由服务端如渲染而来的，随后客户端就会激活这些静态的HTML 缓存每次请求，服务端都需要创建组件实例，这会有一定的性能损耗。对于非用户特定的页面（对不同的用户展示相同内容的页面），我们可以进行缓存 缓存页面以页面为单位，缓存html文本 1234567891011121314151617181920212223242526272829303132333435363738import LRU from &quot;lru-cache&quot;;const pageCache = new LRU(&#123; max: 100, maxAge: 1000, // 重要提示：条目在 1 秒后过期。&#125;);async function renderPage(ctx: Context) &#123; console.log(&quot;路由匹配:&quot;, ctx.url); try &#123; // 判断 是否命中缓存 const cacheable = isCacheable(ctx.url); if (cacheable &amp;&amp; pageCache.get(ctx.url)) &#123; ctx.status = 200; ctx.body = pageCache.get(ctx.url); return; &#125; const context: any = &#123; url: ctx.url, &#125;; const html = await renderer.renderToString(context); ctx.res.setHeader(&quot;Content-Type&quot;, &quot;text/html&quot;); ctx.status = 200; ctx.body = html; // 设置缓存 if (cacheable) &#123; pageCache.set(ctx.url, html); &#125; &#125; catch (err) &#123; // 省略 &#125;&#125;function isCacheable(url: string) &#123; return [&quot;/about&quot;, &quot;/profiles&quot;].indexOf(url) &gt;= 0;&#125; 缓存组件一组件为单位来缓存。vue-server-renderer 内置支持组件级别缓存。只需要在创建renderer时传递cache参数。 12345678import LRU from &quot;lru-cache&quot;;const renderer = createRenderer(&#123; cache: LRU(&#123; max: 10000, maxAge: 1000 &#125;)&#125;) 在组件内，设置serverCacheKey选项来启用缓存。 12345678export default &#123; name: &#x27;item&#x27;, // 必填选项 props: [&#x27;item&#x27;], serverCacheKey: props =&gt; props.item.id, render (h) &#123; return h(&#x27;div&#x27;, this.item.id) &#125;&#125; 注意： serverCacheKey的返回值表示缓存，当前发生变化缓存失效。若返回常量表示组件将被永久缓存 name唯一 通常来说，组件缓存比较适用于一种场景。v-for渲染大组件列表。通常数据都会有个id和最后更新时间。通过这两个属性可以决定缓存是否有效 123export default &#123; serverCacheKey: props =&gt; props.item.id + &#x27;::&#x27; + props.item.last_updated&#125;","categories":[{"name":"Server","slug":"Server","permalink":"https://zxffan.github.io/categories/Server/"}],"tags":[{"name":"vue2","slug":"vue2","permalink":"https://zxffan.github.io/tags/vue2/"},{"name":"ssr","slug":"ssr","permalink":"https://zxffan.github.io/tags/ssr/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://zxffan.github.io/tags/Nodejs/"}]},{"title":"Nodejs搭建服务端","slug":"Server/Nodejs搭建服务端","date":"2021-01-11T16:00:00.000Z","updated":"2021-06-29T14:07:12.838Z","comments":true,"path":"posts/9e0c0ca5.html","link":"","permalink":"https://zxffan.github.io/posts/9e0c0ca5.html","excerpt":"","text":"服务端服务端顾名思义就是提供服务的一方。 先回顾一下四层模型：应用层（最顶层）-&gt; 传输层 -&gt; 网络层 -&gt; 数据链路层（最底层） 其中传输层使用的是TCP/UDP协议应用层使用的协议有http、ftp等 任何一种网络服务都必须遵从一种协议。 nodejs内置了若干模块，实现了常见的网络协议，并向用户提供了便利的接口。 四层模型只是理论模型 Net模块net模块在认识RPC中提到过，当时是用来搭建RPC通道。 它可以建立基于流的TCP服务端和客户端。简单的说，就是建立两端——服务端和客户端，两者之间通过TCP连接。数据以流的方式传输（Buffer） 123456789101112131415161718192021222324252627282930313233// server.tsimport &#123; createServer &#125; from &quot;net&quot;;const server = createServer((socket) =&gt; &#123; // socket.on(&quot;data&quot;, (buffer) =&gt; &#123; console.log(&quot;server: receive data from server: &quot;, buffer.toString()); &#125;); socket.write(&quot;hello client!&quot;);&#125;);server.listen(8081);// ---------------------------------------------// client.tsimport &#123; createConnection &#125; from &quot;net&quot;;const socket = createConnection(&#123; host: &quot;localhost&quot;, port: 8081,&#125;);socket.on(&quot;data&quot;, (buffer) =&gt; &#123; console.log(&quot;client: receive data from server: &quot;, buffer.toString()); socket.write(&quot;hello server!&quot;)&#125;);socket.on(&quot;close&quot;, () =&gt; &#123; console.log(&quot;client: close connection&quot;);&#125;); 服务端通过createServer创建一个TCP服务，其回调函数接受socket作为参数。客户端通过createConnection来连接服务端，其返回socket sokect是服务端和客户端用来通信的工具 123456789101112// 通过on来监听data事件// 有消息发送过来 就会触发该事件// 参数为buffer，使用toString toJSON等方法来获取原始值，参考nodejs buffer模块socket.on(&quot;data&quot;, buffer =&gt; &#123; // TODO // buffer.toString() // buffer.toJSON()&#125;)// socket.write(data[, encoding][, callback])// write方法用来发送数据socket.write(&quot;hello&quot;) buffer的编解码可以使用Protocol Buffers HTTP模块http模块实现了HTTP协议。HTTP协议是基于TCP协议的，所以nodejs的http模块是基于net模块的。 传统的web网站主要使用的就是http协议 12345678910import &#123; createServer &#125; from &quot;http&quot;;import &#123; readFileSync &#125; from &quot;fs&quot;;const buffer = readFileSync(&quot;./index.html&quot;);const server = createServer((req, res) =&gt; &#123; res.end(buffer);&#125;);server.listen(&quot;8080&quot;); 在浏览器输入localhost:8080就可以访问index.html。一个极简的http服务就搭建成了。 http模块也提供了客户端方法——request 123456789101112131415161718192021222324252627282930313233343536import &#123; request &#125; from &#x27;http&#x27;const postData = querystring.stringify(&#123; &#x27;msg&#x27;: &#x27;Hello World!&#x27;&#125;);const options = &#123; hostname: &#x27;www.google.com&#x27;, port: 80, path: &#x27;/upload&#x27;, method: &#x27;POST&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;, &#x27;Content-Length&#x27;: Buffer.byteLength(postData) &#125;&#125;;const req = http.request(options, (res) =&gt; &#123; console.log(`STATUS: $&#123;res.statusCode&#125;`); console.log(`HEADERS: $&#123;JSON.stringify(res.headers)&#125;`); res.setEncoding(&#x27;utf8&#x27;); res.on(&#x27;data&#x27;, (chunk) =&gt; &#123; console.log(`BODY: $&#123;chunk&#125;`); &#125;); res.on(&#x27;end&#x27;, () =&gt; &#123; console.log(&#x27;No more data in response.&#x27;); &#125;);&#125;);req.on(&#x27;error&#x27;, (e) =&gt; &#123; console.error(`problem with request: $&#123;e.message&#125;`);&#125;);// Write data to request bodyreq.write(postData);req.end(); HTTPS模块在HTTP和TCP之间有加了一层TLS/SSL，以解决明文传输的安全问题 HTTPS在HTTP基础上添加了TLS/SSL加密功能。在nodejs中TLS/SSL也是一个独立的模块。HTTPS模块基于HTTP模块和TLS/SSL模块。 对于开发者，使用HTTPS就是多了一步——配置私钥和证书。 生成私钥和证书首选确认正确安装openssl。将通过命令行来生成私钥和证书 第一步，生成私钥key , ryans-key.pem 1openssl genrsa -out ryans-key.pem 2048 第二步，根据私钥，生成证书注册请求（Certificate Signing Request， CSR）, ryans-csr.pem，会提问一堆问题（密码记住） 1openssl req -new -sha256 -key ryans-key.pem -out ryans-csr.pem 第三步，把CSR发给CA机构签名，我们这一步采用自签名的方式，获得证书ryans-cert.pem 1openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem 至此，我们获得了私钥和cer证书。 我们还可以进一步获取pfx证书,ryans.pfx 1openssl pkcs12 -export -in ryans-cert.pem -inkey ryans-key.pem -out ryans.pfx https模块使用123456789101112131415import &#123; createServer &#125; from &quot;https&quot;;import &#123; fstat, readFileSync &#125; from &quot;fs&quot;;const options = &#123; key: readFileSync(&quot;./certs/ryans-key.pem&quot;), cert: readFileSync(&quot;./certs/ryans-cert.pem&quot;),&#125;;const html = readFileSync(&#x27;../index.html&#x27;)const server = createServer(options, (req, res) =&gt; &#123; res.end(html)&#125;);server.listen(443) // https默认是443端口 使用Chrome来测试，首先需要允许localhost使用无效证书（没有经过CA签名）。chrome://flags/#allow-insecure-localhost，设为Enabled即可 在浏览器中输入https://localhost:443。就可以看到页面了 还可以使用pfx证书，pfx证书相对于cer证书： cer证书只包含公钥 pfx证书包含公钥和私钥 123456789101112131415import &#123; createServer &#125; from &quot;https&quot;;import &#123; fstat, readFileSync &#125; from &quot;fs&quot;;const options = &#123; pfx: readFileSync(&#x27;./certs/ryans.pfx&#x27;), passphrase: &#x27;&#x27; // pfx证书的密码&#125;;const html = readFileSync(&#x27;../index.html&#x27;)const server = createServer(options, (req, res) =&gt; &#123; res.end(html)&#125;);server.listen(443) https模块也有https.request方法用来发起https请求 HTTP/2HTTP/2 特点http通常指http/1.1。http/2相较于http/1.1做了很多提升: TLS/SSL加密：和https一样。所以也需要配置证书和私钥 二进制传输：http/1.1传输的是文本，http/2传输的是二进制流 多路复用：http/2有两个概念——帧和流。http/2将数据报文分成一个个二进制帧（Frame），在一个TCP连接中，不同的帧组合在一起发送（二进制分帧）形成流（Stream）。在接收方根据帧首部信息在组合起来。HTTP/1.1只能一个个请求报文排队发送。 header压缩：http请求有这繁多冗长的首部，http/2会对首部进行压缩 服务端推送：能够主动给客户端推送资源 http/1.1加载网页的顺序：请求html，解析html，再请求js、css等文件 http/2：当服务端收到html请求时，服务端就主动吧html、css、js以及图片等资源发送给客户端 前4个都是http/2自动实现的。服务端推送需要开发者手动配置。 Nodejs实现nodejs内置了http2模块，实现了http/2协议。 123456789101112131415161718192021import &#123; createSecureServer &#125; from &quot;http2&quot;;import &#123; readFileSync &#125; from &quot;fs&quot;;const options = &#123; pfx: readFileSync(&quot;./certs/ryans.pfx&quot;), passphrase: &quot;&quot;,&#125;;const html = readFileSync(&quot;../index.html&quot;);const server = createSecureServer(options);server.on(&quot;stream&quot;, (stream, headers) =&gt; &#123; stream.respond(&#123; &quot;content-type&quot;: &quot;text/html; charset=utf-8&quot;, &quot;:status&quot;: 200, &#125;); stream.end(html);&#125;);server.listen(443); http2模块有两个创建服务的方法——createServer和createSecureServer。前者是不带TLS/SSL加密的，后者带加密。目前主流浏览器只支持带TLS/SSL加密的HTTP/2 监听http2Server的stream事件，当请求发来就来触发该事件（http2数据是以二进制流的形式传输） http2Stream是一个双工流。既可以发送数据也可以接受数据。ServerHttp2Stream是其实现，其： http2stream.pushStream(headers[, options], callback)：实现服务端主动推送 http2stream.respond([headers[, options]])：发送回应，可以在这设置响应头 stream是一个流，使用stream.write()向其写入内容或stream.end(content)结束这个流 服务端推送(Server Push)这是http/2的一大特点。nodejs中实现通过pushStream方法即可实现 12345678910111213141516171819202122232425262728import &#123; createSecureServer &#125; from &quot;http2&quot;;import &#123; readFileSync &#125; from &quot;fs&quot;;const options = &#123; pfx: readFileSync(&quot;./certs/ryans.pfx&quot;), passphrase: &quot;&quot;,&#125;;const html = readFileSync(&quot;../index.html&quot;);const png = readFileSync(&quot;../hello.jpg&quot;);const server = createSecureServer(options);server.on(&quot;stream&quot;, (stream, headers) =&gt; &#123; stream.respond(&#123; &quot;content-type&quot;: &quot;text/html; charset=utf-8&quot;, &quot;:status&quot;: 200, &#125;); stream.pushStream(&#123; &quot;:path&quot;: &quot;/hello.jpg&quot; &#125;, (err, pushStream, headers) =&gt; &#123; if (err) throw err; pushStream.respond(&#123; &quot;:status&quot;: 200 &#125;); pushStream.end(png); &#125;); stream.end(html);&#125;);server.listen(443); 上例在用户请求https://localhost时，将index.html和https://localhost/hello.jpg一起发送给客户端。 客户端http2模块也提供了客户端实现。 12345678910111213141516171819202122232425import &#123; connect &#125; from &quot;http2&quot;;import &#123; readFileSync &#125; from &quot;fs&quot;;const client = connect(&quot;https://www.zxffan.com:443&quot;, &#123; ca: readFileSync(&quot;./certs/ryans-cert.pem&quot;),&#125;);const req = client.request(&#123; &quot;:path&quot;: &quot;/&quot; &#125;);req.on(&quot;response&quot;, (headers, flags) =&gt; &#123; for (const name in headers) &#123; console.log(`$&#123;name&#125;: $&#123;headers[name]&#125;`); &#125;&#125;);req.setEncoding(&quot;utf8&quot;);let data = &quot;&quot;;req.on(&quot;data&quot;, (chunk) =&gt; &#123; data += chunk;&#125;);req.on(&quot;end&quot;, () =&gt; &#123; console.log(`\\n$&#123;data&#125;`); client.close();&#125;);req.end(); 客户端需要配置ca证书 ExpressExpress是ndoejs的第三方库，它对网络模块做了增强。来个例子： 1234567891011121314151617import express from &quot;express&quot;;import &#123; createServer &#125; from &#x27;http&#x27;const app = express();const server = createServer(app)app.get(&quot;/&quot;, (req, res) =&gt; &#123; // TODO res.send(&#x27;hello express!&#x27;)&#125;);app.use((req, res, next) =&gt; &#123; console.log(&#x27;Time: %d&#x27;, Date.now()) next()&#125;)server.listen(3000); 将app传给createServer。这样express就拦截了所有请求，在收到请求到响应之间就可以添加很多中间件。 中间件系统，app.use来注册一个中间件，所有请求回按照中间件注册顺序依次调用。 路由系统，express新增了路由，app.get、app.post。路由本质上也是中间件 中间件——洋葱模型123456789101112131415161718192021222324252627282930import express from &quot;express&quot;;import &#123; createServer &#125; from &quot;http&quot;;const app = express();const server = createServer(app);app.use( function m1(req, res, next) &#123; console.log(&#x27;m1 start&#x27;); next() console.log(&#x27;m1 end&#x27;) &#125;, function m2(req, res, next) &#123; console.log(&#x27;m2 start&#x27;); next() console.log(&#x27;m2 end&#x27;) &#125;, function m3(req, res, next) &#123; console.log(&#x27;m3 start&#x27;); next() console.log(&#x27;m3 end&#x27;) &#125;,);app.get(&quot;/&quot;, (req, res) =&gt; &#123; // TODO res.send(&quot;hello express!&quot;);&#125;);server.listen(3000); 上例注册了3个中间件——m1,m2和m3 输出顺序： 123456m1 startm2 startm3 startm3 endm2 endm1 end 中间件就像一个洋葱，m1是外表皮，m2是中间表皮，m2是内表皮。从洋葱的一层穿透到另一个，经过顺序必然是：m1-&gt;m2-&gt;m3-&gt;m3-&gt;m2-&gt;m1。、 但是express的洋葱模型又个问题——异步支持不好。如果m2中进行一个异步操作（RPC，查数据库等），其它中间件不会等待操作结果。Koa的出现弥补了这个缺点。 https和http2https 1234567891011121314151617181920import express from &quot;express&quot;;import &#123; createServer &#125; from &quot;https&quot;;import &#123; readFileSync &#125; from &quot;fs&quot;;const options = &#123; pfx: readFileSync(&quot;./certs/ryans.pfx&quot;), passphrase: &quot;&quot;,&#125;;const app = express();const server = createServer(options, app);const html = readFileSync(&quot;../index.html&quot;, &quot;utf-8&quot;);app.get(&quot;/&quot;, (req, res) =&gt; &#123; // TODO res.send(html);&#125;);server.listen(3000); 使用方法和http模块类似。 至于http2模块，express目前还无法与其兼容。参见官方issue如果想在http2模块中使用express的路由，可以使用router，它是从express独立出来的并且兼容http2，参考issue搜索资料，发现可以使用spdy这个库来结合express实现http2 KoaKoa是express原班人马打造的。koa就是一个中间件系统。他的中间件支持两种函数——普通函数和异步函数 123456789101112import Koa from &quot;koa&quot;;import &#123; createServer &#125; from &quot;http&quot;;const app = new Koa();const server = createServer(app.callback());app.use(async (ctx, next) =&gt; &#123; await next(); ctx.body = &#x27;hello koa!&#x27;&#125;);server.listen(3000); 我这里的写法都是通过原生http模块，这是为了体现koa、express只不过是一套中间件层。底层的网络服务还是nodejs提供的。 也可以简写 12345678910import Koa from &quot;koa&quot;;const app = new Koa();app.use(async (ctx, next) =&gt; &#123; await next(); ctx.body = &#x27;hello koa!&#x27;&#125;);app.listen(3000); koa中间件支持nodejs的async和await语法，从而优雅的实现异步。 https使用https，也就是更换底层网络协议。 1234567891011121314151617181920import Koa from &quot;koa&quot;;import &#123; createServer &#125; from &quot;https&quot;;import &#123; readFileSync &#125; from &quot;fs&quot;;const options = &#123; pfx: readFileSync(&quot;./certs/ryans.pfx&quot;), passphrase: &quot;&quot;,&#125;;const app = new Koa();const server = createServer(options, app.callback());const html = readFileSync(&quot;../index.html&quot;, &quot;utf-8&quot;);app.use(async (ctx, next) =&gt; &#123; await next(); ctx.body = html;&#125;);server.listen(3000); http/2Koa是兼容http2模块的： 123456789101112131415161718192021import Koa from &quot;koa&quot;;import &#123; createSecureServer &#125; from &quot;http2&quot;;import &#123; readFileSync &#125; from &quot;fs&quot;;const options = &#123; pfx: readFileSync(&quot;./certs/ryans.pfx&quot;), passphrase: &quot;&quot;,&#125;;const html = readFileSync(&quot;../index.html&quot;, &quot;utf-8&quot;);const app = new Koa();const server = createSecureServer(options, app.callback());app.use(async (ctx, next) =&gt; &#123; await next(); ctx. ctx.body = html;&#125;);server.listen(443); koa如何使用服务端推送，目前还没有查到😂。 查了下官方issue，开发者只提到兼容HTTP/2。没提server push，不过有人建议通过ctx.stream的形式获得流，进而使用stream.pushStream() HTTP/3HTTP/1.x、HTTPS以及HTTP/2.0都离不开底层的TCP协议。 HTTP/2.0采用多路复用，多个数据包使用一个TCP连接。TCP是可靠连接，但发生丢包时，会进行重传。所以网络状态差的情况下，某些数据包频繁重传，从而导致拥塞，后面的HTTP包都穿不出去。这叫做头部阻塞（Head of line Blocking） HTTP/3.0就开始考虑放弃TCP转向UDP协议。起初Google搞出来个QUIC协议，后来IETF标准化了QUIC协议形成HTTP/3。其底层采用UDP，基于UDP实现做了众多增强： 0RTT：TPC建立连接每次都需要三次握手，就存在数据包的三次往返即3RTT。而QUIC首次建立连接只需要1RTT。其后的连接可以直接复用，只需要0RTT 连接迁移：当源IP、源端口、目的IP、目的端口其中一个发生变化就需要重新建立TCP连接。只要Connection ID没有变化。HTTP/3可以继续复用连接 头部阻塞：由于使用UDP，发生丢包时，也不会立即重传，阻塞连接。 拥塞控制 前向纠错 更多特性 请参考文章 nodejs目前未支持HTTP/3。 chrome只支持 Google QUIC。对IETF QUIC的支持处于WIP状态","categories":[{"name":"Server","slug":"Server","permalink":"https://zxffan.github.io/categories/Server/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://zxffan.github.io/tags/Nodejs/"},{"name":"服务","slug":"服务","permalink":"https://zxffan.github.io/tags/%E6%9C%8D%E5%8A%A1/"}]},{"title":"Nginx","slug":"Server/Nginx","date":"2021-01-05T16:00:00.000Z","updated":"2021-06-29T14:07:09.955Z","comments":true,"path":"posts/d0156050.html","link":"","permalink":"https://zxffan.github.io/posts/d0156050.html","excerpt":"","text":"nginx [engine x] is an HTTP and reverse proxy server, a mail proxy server, and a generic TCP/UDP proxy server nginx是一个HTTP服务器、反向代理服务器、邮件代理服务器、通用TCP/UDP代理服务器 总而言之，nginx能够在你的机器上跑起HTTP服务，我们可以在这个服务上部署传统的Web系统。 Nginx配置安装什么的就不提了。nginx的配置框架如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#user nobody;worker_processes 1; #配置工作进程数目#配置全局错误日志及类型 [debug|info|notice|warn|error|crit(致命错误)] 默认error#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#配置进程pid文件#pid logs/nginx.pid;#配置工作模式和连接数events &#123; #配置每个worker的最大连接数 #nginx最大连接数 = worker_process * worder_connections worker_connections 1024;&#125;#配置httphttp &#123; #include 用来引入其他文件的配置 #当收到静态资源请求时，会根据资源的后缀名去mime.types里找对应的mime类型，再根据mime来设置响应头中的Content-Type include mime.types; default_type application/octet-stream; #设置默认响应类型 #设置日志格式 #log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; # &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; # &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; #access_log logs/access.log main; #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件， #对于普通应用，必须设为 on, #如果用来进行下载等应用磁盘IO重负载应用，可设置为 off， #以平衡磁盘与网络I/O处理速度，降低系统的uptime. sendfile on; #tcp_nopush on; #累计一定量的数据包一起发送 #tcp_nodelay on; #默认延后0.2s后发送整合数据包（避免频繁发送小数据包）。on则关闭这个特性 #连接超时时间 #keepalive_timeout 0; keepalive_timeout 65; #开启gzip压缩 gzip on; server &#123; listen 8080; #配置监听端口 server_name localhost; #配置服务名 #编码 #charset koi8-r; #设置日志存放路径，格式为 main（在http中定义的） access_log logs/host.access.log main; #默认的匹配规则 location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # 代理所有url中含有api的请求，并转发到 http://127.0.0.1 location /api/ &#123; proxy_pass http://127.0.0.1:8080; &#125; # 拒接所有ht文件请求 location ~ /\\.ht &#123; deny all; &#125; &#125; include servers/*;&#125; 虚拟主机虚拟主机技术可以将一台物理服务器划分成多个虚拟主机。可以在每个虚拟主机部署网站。 基于端口server下的listen字段可以设置所需监听的端口 12345678server &#123; listen 8080; root /project1/ location / &#123; index index.html &#125;&#125; localhost:8080即可访问到虚拟主机（server）上部署的网站 基于虚拟主机名server_name：配置虚拟主机的名称。可以配置成访问的域名 12345678910111213# Aserver &#123; listen 80; server_name www.test1.com; # ...&#125;# Bserver &#123; listen 80; server_name www.test2.com; # ...&#125; 虚拟主机A和B监听同一个端口，但是通过配置不同的server_name来区分 http://www.test1.com/index.html将访问到虚拟主机A http://www.test2.com/index.html将访问到虚拟主机B location匹配规则location [=|~|~*|^~] /uri/ &#123; … &#125; = 开头表示精确匹配 ^~ 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~ /static/ /aa匹配到（注意是空格）。 ~ 开头表示区分大小写的正则匹配 ~* 开头表示不区分大小写的正则匹配 !~和!~*分别为区分大小写不匹配及不区分大小写不匹配 的正则 / 通用匹配，任何请求都会匹配到。 root和aliasrooot和alias都是用来指定文件路径的 123location ^~ /public/ &#123; root /www/root/html;&#125; 当访问/public/index.html时会在/www/root/html/public/index.html路径下寻找文件 123location ^~ /public/ &#123; alias /www/root/html/;&#125; 当访问/public/index.html时会在/www/root/html/index.html路径下寻找文件 所以，区别就是在查找文件时，root会加上location配置路径，而alias不会 初始页123456789server &#123; listen 80; server_name www.test.com; location / &#123; root /website/project1; index index.html welcome.html &#125;&#125; 当访问www.test.com时，会在/website/project1/目录下寻找index.html文件，有则返回否则继续寻找welcome.html 错误页对于一些错误页面（404，500等），可以通过以下配置来访问 123456789error_page 404 =200 /404.html;location = /404.html &#123; root /website;&#125;error_page 500 502 503 =200 /50x.html;location = /50x.html &#123; root /website;&#125; 当请求发生404时（访问到不存在的页面），会跳转到/404.html。为了防止找不到，加了个location指定文件所在位置（/website/404.html）。 对于单页面应用，通常只有一个index.html。在配置404等错误时，需要返回index.html 12345error_page 404 =200 /404.html;location = /404.html &#123; root /website; try_files $uri $uri/ /index.html;&#125; 解释：发生404时，重定向到/404.html。匹配到/404.html的location。然后遇到try_files指令 try_files $uri $uri/ /index.html; 访问/public/somepage.html时，会前去找$uri(就是/public/somepage.html)，找不到寻找$uri/。找不到最后返回/index.html 代理反向代理和正向代理都需要通过proxy_pass指令来实现。 需要代理的场景一般有三种角色： 客户端：一般指浏览器 代理服务器：指nginx 服务端：真正需要访问的服务器 12345678910111213server &#123; listen 80; root /websites/demo; location / &#123; try_files $uri $uri/ /index.html; index index.html; &#125; location ^~ /api &#123; proxy_pass http://localhost:8081/ #末尾加/ 转发就不会包含/api(location的路径配置) &#125;&#125; 客户端访问/api/get-user-info。请求到达代理服务器，匹配到/api转发给http://localhost:8081/get-user-info。 反向代理和正向代理本质上都是请求和响应的转发。根据代理的目的来划分它们。 代理一般都是指正向代理，目的是帮助内网的客户端访问外网。比如通过科学上网访问google，它在国外假设一台没有被禁的代理服务器。国内访问这台代理服务器，代理服务器再去访问google。 反向代理正好相反。它是帮助外网的客户端访问内网。比如访问baidu。客户端（浏览器）访问百度，会访问到baidu的代理服务器，通过代理服务器来访问baidu的内网服务器。 nginx的反向代理常常被提到。因为它的性能真的很好。最重要的是反向代理可以来做负载均衡。 负载均衡还以访问百度为例，当代理服务器收到客户端的请求时，代理服务器根据负载均衡规则（算法）来选择百度的内网服务器（百度的服务器肯定不止一台）来转发请求。 配置1234567891011121314http &#123; upstream backend &#123; server 127.0.0.1:3000 weight=3; # weight权重 越大访问的机率越高 server 127.0.0.1:5000 weight=1; &#125; server &#123; listen 80; root /websites/demo location / &#123; proxy_pass http://backend; &#125; &#125;&#125; 所有请求都会代理转发到upstream中配置的服务器。按照权重分配 策略1.轮询（默认）1234upstream backserver &#123; server 127.0.0.1:3000; server 127.0.0.1:5000; &#125; 每个请求都会按照时间循序依次分配到所配置的后端服务器，如果服务器宕机则自动剔除 2.权重1234upstream backend &#123; server 127.0.0.1:3000 weight=3; # weight权重 越大访问的机率越高 server 127.0.0.1:5000 weight=1; &#125; 指定轮询机率，weight和访问比率成正比，用于后端服务器性能不均的情况。 3.IP哈希服务端可能需要访问session，如果每一次处理请求的服务端不同，是无法获取正确的session的。IP哈希是指每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，从而解决session的问题。 12345upstream backserver &#123; ip_hash; server 127.0.0.1:3000; server 127.0.0.1:5000; &#125; 4.fair按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream backserver &#123; server 127.0.0.1:3000; server 127.0.0.1:5000; fair;&#125; 5.URL哈希根据请求URL的hash来分配，相同hash分配至同一台服务器 123456upstream backserver &#123; server 127.0.0.1:3000; server 127.0.0.1:5000; hash $request_uri; hash_method crc32;&#125; 其它配置123456upstream backserver &#123; server 127.0.0.1:3000 down; # down表示服务宕机，不参与分配 server 127.0.0.1:5000; server 127.0.0.1:6000; server 127.0.0.1:7000 backup; # backup表示这是备用服务，只有当其它服务全部down，才会启用备用服务&#125; 设置头信息设置响应头有两个指令——add_header和proxy_set_header。 add_header key value [always]：设置响应头给浏览器，对20x和30x的响应码有效，加上always强制生效 proxy_set_header key value：设置请求头给上游服务器 1234567891011# nginx 设置cors跨域add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;;add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS, PUT, DELETE&#x27;;add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Content-Type&#x27;;location ^~ /api &#123; if ($request_method = &#x27;OPTIONS&#x27;) &#123; return 200; &#125; proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:8081/;&#125; 变量参数nginx内置了很多变量，使用形式$变量名 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960$args #请求中的参数值$query_string #同 $args$arg_NAME #GET请求中NAME的值$is_args #如果请求中有参数，值为&quot;?&quot;，否则为空字符串$uri #请求中的当前URI(不带请求参数，参数位于$args)，可以不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改，$uri不包含主机名，如&quot;/foo/bar.html&quot;。$document_uri #同 $uri$document_root #当前请求的文档根目录或别名$host #优先级：HTTP请求行的主机名&gt;&quot;HOST&quot;请求头字段&gt;符合请求的服务器名.请求中的主机头字段，如果请求中的主机头不可用，则为服务器处理请求的服务器名称$hostname #主机名$https #如果开启了SSL安全模式，值为&quot;on&quot;，否则为空字符串。$binary_remote_addr #客户端地址的二进制形式，固定长度为4个字节$body_bytes_sent #传输给客户端的字节数，响应头不计算在内；这个变量和Apache的mod_log_config模块中的&quot;%B&quot;参数保持兼容$bytes_sent #传输给客户端的字节数$connection #TCP连接的序列号$connection_requests #TCP连接当前的请求数量$content_length #&quot;Content-Length&quot; 请求头字段$content_type #&quot;Content-Type&quot; 请求头字段$cookie_name #cookie名称$limit_rate #用于设置响应的速度限制$msec #当前的Unix时间戳$nginx_version #nginx版本$pid #工作进程的PID$pipe #如果请求来自管道通信，值为&quot;p&quot;，否则为&quot;.&quot;$proxy_protocol_addr #获取代理访问服务器的客户端地址，如果是直接访问，该值为空字符串$realpath_root #当前请求的文档根目录或别名的真实路径，会将所有符号连接转换为真实路径$remote_addr #客户端地址$remote_port #客户端端口$remote_user #用于HTTP基础认证服务的用户名$request #代表客户端的请求地址$request_body #客户端的请求主体：此变量可在location中使用，将请求主体通过proxy_pass，fastcgi_pass，uwsgi_pass和scgi_pass传递给下一级的代理服务器$request_body_file #将客户端请求主体保存在临时文件中。文件处理结束后，此文件需删除。如果需要之一开启此功能，需要设置client_body_in_file_only。如果将次文件传 递给后端的代理服务器，需要禁用request body，即设置proxy_pass_request_body off，fastcgi_pass_request_body off，uwsgi_pass_request_body off，or scgi_pass_request_body off$request_completion #如果请求成功，值为&quot;OK&quot;，如果请求未完成或者请求不是一个范围请求的最后一部分，则为空$request_filename #当前连接请求的文件路径，由root或alias指令与URI请求生成$request_length #请求的长度 (包括请求的地址，http请求头和请求主体)$request_method #HTTP请求方法，通常为&quot;GET&quot;或&quot;POST&quot;$request_time #处理客户端请求使用的时间,单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。$request_uri #这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI，不包含主机名，例如：&quot;/cnphp/test.php?arg=freemouse&quot;$scheme #请求使用的Web协议，&quot;http&quot; 或 &quot;https&quot;$server_addr #服务器端地址，需要注意的是：为了避免访问linux系统内核，应将ip地址提前设置在配置文件中$server_name #服务器名$server_port #服务器端口$server_protocol #服务器的HTTP版本，通常为 &quot;HTTP/1.0&quot; 或 &quot;HTTP/1.1&quot;$status #HTTP响应代码$time_iso8601 #服务器时间的ISO 8610格式$time_local #服务器时间（LOG Format 格式）$cookie_NAME #客户端请求Header头中的cookie变量，前缀&quot;$cookie_&quot;加上cookie名称的变量，该变量的值即为cookie名称的值$http_NAME #匹配任意请求头字段；变量名中的后半部分NAME可以替换成任意请求头字段，如在配置文件中需要获取http请求头：&quot;Accept-Language&quot;，$http_accept_language即可$http_cookie #请求的所有cookie$http_host #请求地址，即浏览器中你输入的地址（IP或域名）$http_referer #url跳转来源,用来记录从那个页面链接访问过来的$http_user_agent #用户终端浏览器等信息$http_x_forwarded_for #客户端的IP和代理服务器的IP，以逗号隔开；可伪造$http_x_forwarded_proto #请求的协议$sent_http_NAME #可以设置任意http响应头字段；变量名中的后半部分NAME可以替换成任意响应头字段，如需要设置响应头Content-length，$sent_http_content_length即可$sent_http_cache_control$sent_http_connection$sent_http_content_type$sent_http_keep_alive$sent_http_last_modified$sent_http_location https在nginx中使用https，配置一下证书就可以 1234567891011121314151617181920# HTTPS server#server &#123; listen 443 ssl; server_name localhost; ssl_certificate cert.pem; # 公钥，会被发送给每一个访问的客户端 ssl_certificate_key cert.key; # 私钥，用来解密客户端发送的数据 ssl_session_cache shared:SSL:1m; # 设置ssl/tls会话缓存的类型和大小 ssl_session_timeout 5m; # ssl参数的过期时间 ssl_ciphers HIGH:!aNULL:!MD5; # 选择加密套件 ssl_prefer_server_ciphers on; # on代表 设置协商加密算法时，优先使用服务端的加密套件，而不是客户端的加密套件 location / &#123; root html; index index.html index.htm; &#125;&#125; HTTP/2在https的例子上，做一处改动：在listen后加上http2即可 1listen 443 ssl http2; Nginx日志切割如果把所有日志都打在一个日志文件中，当文件很大时，读写就会变慢从而影响nginx性能 可以通过shell脚本按大小来切割日志文件。 在nginx中，也可以按照时间来切割文件 123456if ($time_iso8601 ~ &quot;^(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)&quot;) &#123; set $year $1; set $month $2; set $day $3;&#125;access_log /var/log/nginx/$year-$month-$dayaccess.log json; 上例是把同一天的日志放在一个日志文件中。 实现重定向重定向分为两种 301：永久重定向 302：临时重定向 1234567server &#123; listen 8080; if($host != &#x27;www.aaa.com&#x27;) &#123; rewrite ^/(.*)$ &#x27;http://www.bbb.com&#x27; permanent &#125;&#125; 使用rewirte命令可以实现重定向功能 1rewrite 正则 重定向地址 flag flag有一下值 标记符号 说明 last 本条规则匹配完成后继续向下匹配新的location URI规则 break 本条规则匹配完成后终止，不在匹配任何规则 redirect 返回302临时重定向 permanent 返回301永久重定向","categories":[{"name":"Server","slug":"Server","permalink":"https://zxffan.github.io/categories/Server/"}],"tags":[{"name":"Server","slug":"Server","permalink":"https://zxffan.github.io/tags/Server/"},{"name":"Nginx","slug":"Nginx","permalink":"https://zxffan.github.io/tags/Nginx/"},{"name":"Web","slug":"Web","permalink":"https://zxffan.github.io/tags/Web/"}]},{"title":"JavaScript沙箱","slug":"JavaScript/JavaScript沙箱","date":"2020-12-27T16:00:00.000Z","updated":"2021-06-29T14:05:29.975Z","comments":true,"path":"posts/72bec40a.html","link":"","permalink":"https://zxffan.github.io/posts/72bec40a.html","excerpt":"","text":"沙盒（英语：sandbox，又译为沙箱）是一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具破坏力或无法判定程序意图的程序提供实验之用 by wikipedia 简单的说，沙箱就是一个隔离的环境。沙箱里外互不影响。 Node的沙箱环境nodejs内置了一个vm模块，他可以让我们直接在 V8 虚拟机上下文中编译和运行代码，使用方法如下： 12345678910111213141516const vm = require(&quot;vm&quot;);// 创建需要运行的脚本const script = new vm.Script(&quot;a + b&quot;);// 创建上下文 contextconst context = vm.createContext(&#123;a: 1, b: 2&#125;);// 在上下文context下运行脚本const result = script.runInContext(context)console.log(result) // 输出：3// 或者直接vm.runInContext(&quot;a + b&quot;, context) // 输出：3 在nodejs中创建一个沙箱还是挺容易的。 但是值得注意的是，vm模块并非绝对安全，由它创建的的沙箱内部通过一些手段还是可以访问到外部环境的。所以nodejs官方文档明确标注： vm 模块不是安全的机制。 不要使用它来运行不受信任的代码。 也有一些社区模块：比如vm2，它内部使用vm模块，并且使用Proxy来阻止沙箱脚本逃逸。 Safeify是一个基于vm2的第三方库，它创建了个进程池，把代码放入进程池中执行。进程间通过IPC通讯。 浏览器的沙箱环境浏览器环境没有vm这个API，实现将有所不同。 eval这是一个令人诟病的api，eval(&quot;window&quot;)是能够访问到window对象的，所以它并不能隔离。 new Function()1fn = new Function(...args, &#x27;functionBody&#x27;); new Function依然能够访问到全局作用域。 with这个冷门的API，可能大多数JS开发者都没听说过 1234567function createRuntimeSandbox(src) &#123; src = &#x27;with (context) &#123;&#x27; + src + &#x27;&#125;&#x27; return new Function(&#x27;context&#x27;, src)&#125;const func = createRuntimeSandbox(&quot;console.log(window)&quot;)func(&#123;window: 123&#125;) // 输出 123 with关键字会使用in运算符来判断是否在context中。如果context存在就去context取。反之去全局作用域中取。 Proxy在with的例子上做些改动 1234567891011121314151617181920function createRuntimeSandbox(src) &#123; src = &#x27;with (context) &#123;&#x27; + src + &#x27;&#125;&#x27; const func = new Function(&#x27;context&#x27;, src) return context =&gt; &#123; const fakeContext = &#123;&#125; const proxy = new Proxy(fakeContext, &#123; has() &#123; return true &#125;, // 确保 xx in fakeContext 永远为true，不去全局作用域找 get(target, param) &#123; return target[param] || context[param] &#125; &#125;) return func(proxy) &#125;&#125;const func = createRuntimeSandbox(&quot;console.log(name);name=&#x27;hello&#x27;;console.log(name)&quot;)const context = &#123; name: &quot;zxffan&quot;, console &#125;func(context) // 输出：zxffan helloconsole.log(context.name) // 输出：zxffan 上例使用了proxy，将上下文（context）做了代理。在沙箱里修改context的name属性不会影响到沙箱外。 还有个问题，proxy只代理了context，如果context里又包含对象，那么在沙箱里是可以修改的。写一个通用的代理方法来解决 1234567891011121314151617181920212223242526function createProxySandbox(context, handler = &#123;&#125;) &#123; const fakeContext = &#123;&#125;; return new Proxy(fakeContext, Object.assign(&#123; get(target, param) &#123; return Reflect.get(target, param) || Reflect.get(context, param) &#125; &#125;, handler))&#125;function createRuntimeSandbox(src) &#123; src = &#x27;with (context) &#123;&#x27; + src + &#x27;&#125;&#x27; const func = new Function(&#x27;context&#x27;, src) return context =&gt; &#123; const proxy = createProxySandbox(context, &#123; has() &#123; return true &#125; &#125;) return func(proxy) &#125;&#125;const func = createRuntimeSandbox(&quot;window.aa=&#x27;zxffan&#x27;;console.log(window.aa)&quot;)const fakeWindow = createProxySandbox(window)fakeWindow.window = fakeWindowfunc(fakeWindow) // 输出：zxffanconsole.log(window.aa) // 输出：undefined 这样使用，可以自定义需要暴露给沙箱的全局对象。 createProxySandbox相当于代理提供的对象，并返回一个代理后的对象。对代理后的对象的修改不影响原对象，这本身就是一个数据沙箱。 createRuntimeSandbox提供了一个指定上下文的JS执行环境。该环境确保不会直接访问和修改沙箱外的作用域的数据，这相当于一个运行时沙箱。 总结沙箱的作用是隔离上下文环境，保证不会造成JS污染。 应用场景： 在微前端场景下，可以利用沙箱来保证各个微应用之间以及微应用和主应用之间不会造成JS污染。 通常也可以将不受信（存在安全隐患）的代码放在沙箱中运行，以阻止其破坏主程序。 推荐使用with、new Function以及Proxy构成的沙箱实现","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"}]},{"title":"云计算的发展","slug":"Server/云计算发展历程","date":"2020-12-23T16:00:00.000Z","updated":"2021-06-29T14:07:04.626Z","comments":true,"path":"posts/8aa364dc.html","link":"","permalink":"https://zxffan.github.io/posts/8aa364dc.html","excerpt":"","text":"最近对serverless提起了兴趣，于是提笔写几篇学习笔记。 时代历程总的来说云计算的发展经过了物理机时代、虚拟机时代、容器时代以及当下的Serverless。 物理机时代发布一个网站，需要购买一台物理机服务器。然后手动安装操作系统和许多的软件环境。那时服务器发生故障时，服务迁移是一件很痛苦的事。而且购买物理机的成本也很高。 虚拟机时代2001年后虚拟化技术日渐成熟。虚拟化技术可以将一台物理机分割成多台虚拟机供多名用户使用，充分利用硬件资源。比如阿里云的ECS，我上学的时候就买了一台虚拟机。相对于直接购买一台物理机，虚拟机可以大大降低成本。 容器时代容器技术。目前比较流行的如Docker。在服务器上安装容器，将软件服务部署在容器中。这样，在做迁移的时候可以将容器内的软件环境打包成镜像。再拷贝到另一台服务器上部署。大大降低了迁移成本 有了容器，在服务器上部署的就不再是应用而是一个个容器。当容器多了就比较难以管理。Kubernetes(K8S)是Google的用来进行容器编排的开源工具。有了K8S就可以实现网站的自动弹性伸缩。但是这一切的配置都需要专业的运维知识。 ServerlessServerless是指构建和运行不需要服务器管理的一种模式。目前Serverless实现方式主要是基于FaaS和BaaS FaaS(函数即服务)：将应用切割成一个个独立的函数，每个函数有自己独立的业务，这些函数再组成复杂的应用。 Baas(后端即服务)：将数据库、文件存储等后端能力封装成服务，并以接口的形式提供。在FaaS中可以调用各种后端服务。 一个Serverless的网站架构大致如下： XaaS梳理一些一些名词：IaaS、PaaS、SaaS、FaaS与BaaS IaaS（基础设施即服务）：虚拟化技术成熟后，出现众多云厂商和产品。例如AWS 的 EC2、阿里云 ECS。这些都属于IaaS。 PaaS（平台即服务）：随着业务形态发展，云厂商发现可以抽象出一些通用的平台，比如中间件、数据库等，于是就把这些功能做成服务，也放在云上去卖，这些属于PaaS。 SaaS（软件即服务）：SaaS很常见。比如邮箱服务，软件环境部署在开发者服务器中。用户只需要一个账户，打开浏览器即可使用。 FaaS与BaaS上文讨论过。 Serverless什么是Serverless广义的 Serverless 是指：构建和运行软件时不需要关心服务器的一种架构思想 狭义的 Serverless 是 FaaS 和 BaaS 的组合，这是当前主流的实现 Serverless的主要特点 服务无关：开发者无需关心服务器资源（配置，磁盘大小等），只需要提供一份代码。 弹性伸缩：资源的分配完全由云服务来计算，会根据请求量自动调整资源占用 按量计费：在 Serverless 架构中，计费方式按实际使用量计费（比如函数调用次数、运行时长）。 PaaS、Kubernetes 、云原生等技术是不是 Serverless？按照Serverless的特点来看，它们都不是PaaS是按照服务收费并非按量收费K8S是一种容器编排技术，它可以实现弹性伸缩。但是具体的编排规则需要专业运维来设置，不符合服务无关云原生是指原生为云设计的一种架构模式。Serverless是云原生的一种实现，K8S是另一种实现 Serverless的缺点 依赖第三方：使用Serverless就必须使用云厂商提供的Serverless的产品。这样就与云厂商绑定。一旦选定一个云厂商，在想做迁移就十分复杂。这是因为当前国内Serverless实现没有一个公共的标准。 底层硬件多样性：同一个云函数可能运行在不同硬件资源下。如果你的服务依赖于具体的硬件资源（比如只有某个CPU/GPU能够使用），这就要云厂商提供相应服务。 性能瓶颈：Serverless的云函数不是一直运行的，只有需要的时候才会执行。每次执行前会初始化函数执行环境，这需要一定时间。而这个时间需要云厂商自己去优化。 通信效率低：Serverful中函数掉函数都是在内存中进行的。而Serverless中函数都是独立的，之间调用（HTTP，RPC）肯定效率没有内存高 开发调试复杂：目前Serverless还处于发展阶段，各厂商的标准不一，开发和调试工具不完善。","categories":[{"name":"Server","slug":"Server","permalink":"https://zxffan.github.io/categories/Server/"}],"tags":[{"name":"Serverless","slug":"Serverless","permalink":"https://zxffan.github.io/tags/Serverless/"},{"name":"云计算","slug":"云计算","permalink":"https://zxffan.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"}]},{"title":"js实现选中与复制粘贴","slug":"JavaScript/js实现选中与复制粘贴","date":"2020-12-13T16:00:00.000Z","updated":"2021-06-29T14:05:34.966Z","comments":true,"path":"posts/82fa4d6c.html","link":"","permalink":"https://zxffan.github.io/posts/82fa4d6c.html","excerpt":"","text":"选中两个对象 selection range Selection对象所对应的是用户所选择的 ranges （区域），俗称拖蓝 by MDN Firefox中可以通过按住ctrl同时选中不同区域，每个区域都对应一个range对象（chrome禁用了该功能，即只能选中一个区域）。selection代表文本选区（网页中可选择的区域），所以selection包含若干个range。可以通过selection.getRangeAt(index)来获取选区(range)。index是要获取的range的索引（chrome中只能是0）。 应用：获取选中文本12const selection = window.getSelection()selection.toString() 应用：取消选中12const selection = window.getSelection()selection.removeAllRanges() 应用：全选某个节点的内容1234567const range = document.createRange() // 创建range对象const node = document.getElementById(&#x27;dom&#x27;) // 获取要全选的dom节点range.selectNodeContents(node)const selection = window.getSelection()selection.removeAllRanges() // 清空其它选中内容selection.addRange(range) // 添加选中区域 应用：截取位置选中1234567891011121314const range = document.createRange()const node = document.getElementById(&#x27;dom&#x27;) // 获取要截取的dom节点/* * * 如果起始节点类型是 Text， Comment, or CDATASection之一, 那么 startOffset指的是从起始节点算起字符的偏移量。 * * 对于其他 Node 类型节点， startOffset 是指从起始结点开始算起子节点的偏移量。 */const [startOffset, endOffset] = [1, 7]range.setStart(node, startOffset)range.setEnd(node, endOffset)const selection = window.getSelection()selection.removeAllRanges() // 清空其它选中内容selection.addRange(range) // 添加选中区域 复制与粘贴复制与粘贴的实现需要使用Clipboard，它首先会通知用户是否赋予读写剪贴板权限。 系统剪贴板暴露在全局属性navigator.clipboard之下 它有四个API，他们都是返回Promise read() 从剪贴板读取数据（比如图片）。 readText() 从剪贴板读取文本 write() 写数据 writeText() 写文本 注意：document.execCommand已经被废弃了，不建议使用。clipboard在非HTTPS环境下不可用","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"}]},{"title":"JavaScript函数式编程","slug":"books/JavaScript函数式编程","date":"2020-12-10T16:00:00.000Z","updated":"2021-06-29T14:03:59.321Z","comments":true,"path":"posts/1690d21b.html","link":"","permalink":"https://zxffan.github.io/posts/1690d21b.html","excerpt":"","text":"函数式编程要素 声明式 纯函数 不可变性 声明式声明式是将程序的描述与求值分离开来的。它关注于如何用各种表达式来描述程序逻辑。与其相对的是命令式。 123456789101112// demo：求数组的每个元素（数值类型）的平方const arr = [1, 2, 3, 4, 5]// 命令式for (let i = 0; i &lt; arr.length; i++) &#123; arr[i] = Math.pow(arr[i], 2);&#125;// 声明式const square = num =&gt; Math.pow(num, 2)arr.map(square) 纯函数纯函数要求： 对于同一组输入必然有相同的输出。 不依赖于外部环境也不改变外部环境。 123456789101112// 具有副作用的函数let count1 = 0;function increment1() &#123; return ++count1 // 引用了全局变量&#125;// 纯函数function increment2(count) &#123; return count + 1&#125; 实际上，纯函数是很难得的。我们要做的就是尽可能地把具有副作用地部分抽离出来，让逻辑结构更加清晰。 不可变数据处理数据时不要修改原数据，尽可能得基于原数据来构造新数据。 123456789101112131415// demo: 数组排序const arr = [4, 6, 2, 3, 8, 5];// mutablefunction sort1() &#123; return arr.sort()&#125;// immutablefunction sort1() &#123; return [].concat(arr).sort()&#125; 函数式编程鼓励将复杂的任务分成成一个个纯函数。再将这些函数进行组合。这样使得任务流更加清晰，更易于维护 柯里(curry)化柯里化可以缩减函数参数。 一个向节点插入参数的demo 12345function insertText(dom, text) &#123; document.querySelector(dom).innerText = text&#125;insertText(&quot;container&quot;, &quot;hello world&quot;) 经过柯里化后就变成了 12345678function insertText(dom) &#123; return function (text) &#123; document.querySelector(dom).innerText = text &#125;&#125;const insertToContainer = insertText(&quot;container&quot;)insertToContainer(&quot;hello world&quot;) 组合组合是函数式编程的一个重要概念。将一个复杂的逻辑拆分成一个个函数后，需要将这些函数组合起来执行。 链式组合在组合纯函数时，通过链式的方式比较容易被理解，例如: 1234arr.filter(/** .. **/) .map(/** .. **/) .reduce(/** .. **/) //... 真的打算使用链式组合法的话，推荐lodash.js这个工具库。 123456789101112131415var users = [ &#123; &#x27;user&#x27;: &#x27;barney&#x27;, &#x27;age&#x27;: 36 &#125;, &#123; &#x27;user&#x27;: &#x27;fred&#x27;, &#x27;age&#x27;: 40 &#125;, &#123; &#x27;user&#x27;: &#x27;pebbles&#x27;, &#x27;age&#x27;: 1 &#125;]; var youngest = _ .chain(users) .sortBy(&#x27;age&#x27;) .map(function(o) &#123; return o.user + &#x27; is &#x27; + o.age; &#125;) .head() .value();// =&gt; &#x27;pebbles is 1&#x27; 管道组合方法链的一个缺点就是：它与方法所属的对象紧紧地耦合在一起，限制链中可以使用的方法数量，也就限制了代码的表现力。 12345678910111213function first() &#123;&#125;function getName() &#123;&#125;function reverse() &#123;&#125;function sort() &#123;&#125;const task = pipe(first, getName, reverse, sort) // pipe 用来组合函数task(params) pipe将函数组合起来。task执行后，将params传递给first。first函数执行完成后再将结果传递给getName。由此类推，将所有函数组合起来，形如一条管道。 上例中，pipe的参数都是函数声明，如果某个函数需要提前传入一些参数可以使用柯里化 这里推荐一下Ramda.js这个工具库。它与lodash相似但却又不相同，它内置pipe方法以及其它组合方法。 管道组合处理程序流上面的例子，都没有涉及到 逻辑分支。在命令式代码中，我们很容易就会写if/else，而函数式编程是不建议直接使用if/else的。 在Ramda.js中pipe是用来组合函数的，叫做组合器。除了pipe还有其它组合器 R.composecompose与pipe功能一样，只是组合的方向相反。R.compose(f1, f2, f3), 他会先执行f3，然后执行f2，最后f1 R.tapcompose和pipe组合函数时，存在参数传递。每个函数的返回值都给传给管道中的下一个函数。如果中间有一个函数没有返回值（比如 日志埋点）就无法构成管道。 tap能够将一个无返回值的函数插入管道中，因为tap会将参数原样返回。 123const debug = R.tap(debugLog);const cleanInput = R.compose(normalize, debug, trim);const isValidSsn = R.compose(debug, checkLengthSsn, debug, cleanInput); alternation12345678910const alt = function (...fns) &#123; return function (val) &#123; let result for (let fn of fns) &#123; result = fn(val); if (result) break; &#125; return result &#125;&#125; alt(fn1, fn2, fn3, ...)，如果fn1的返回值不是false、null和undefined则返回fn1的返回值。否则执行fn2的，再判断其返回值。所以alt能够提供简单的逻辑条件判断 sequence实现如下 12345678const seq = function(...funcs) &#123; const funcs = Array.prototype.slice.call(arguments); return function (val) &#123; funcs.forEach(function (fn) &#123; fn(val); &#125;); &#125;;&#125;; seq(fn1, fn2, fn3, ...), 会顺序执行所有函数，这些函数在管道中时平行的，它们都接受管道中上一个函数的返回值作为参数。通常放在管道的末尾。 fork-join1234567function fork (join, ...fns) &#123; return function (val) &#123; let result = [] fns.forEach(fn =&gt; result.push(fn(val))); join(...result) &#125;&#125; fork相对于seq增加了一步，将所有函数的执行结果传递给join，再做一次处理。 未完… Functorfunctor是实现了map函数并遵守一些特定规则的容器类型。比如下面这个Just容器 123456789101112class Just&lt;T&gt; &#123; private _value: T; constructor(value: T) &#123; this._value = value &#125; map(fn: (...args: any[]) =&gt; any): Wrapper &#123; return Just.of(fn(this._value)) &#125; static of&lt;U&gt;(value: U) &#123; return new Monad(value); &#125;&#125; 这个Just容器就是一个Functor（函子） 封装了value，容器外无法修改_value。从而保护数据 提供map函数，该函数将原始值传给参数函数，并将结果再次封装。map函数将方便链式调用 of是一个静态函数。用于封装数据 从本质上讲，Functor 只是一个可以将函数应用到它包裹的值上，并将结果再包裹起来的数据结构。 MaybeMaybe也属于Functor，它在Just上增加了错误处理 123456789101112131415class Maybe&lt;T&gt; &#123; private _value: T; constructor(value: T) &#123; this._value = value &#125; isNothing(): boolean &#123; return this._value === undefined || this._value === null &#125; map(fn: (...args: any[]) =&gt; any) &#123; return this.isNothing() ? Maybe.of(null) : Maybe.of(fn(this._value)) &#125; static of&lt;U&gt;(value: U) &#123; return new Monad(value); &#125;&#125; 当出现null，undefined时，调用不会抛出异常。 12Maybe.of(null).map((a) =&gt; a + 3)// Maybe &#123; _value: null &#125; Monad使用functor可能会造成嵌套封装的情况 12const num = Maybe.of(Maybe.of(3))num.map(v =&gt; v + 1) // error 这时，map的参数函数接受的参数v实际上还是一个Functor，它并不能直接参与运算。 Monad可以使functor扁平化。 提供一个join函数，其意是将所有嵌套的Functor合并成一个。 identity用来获取原始值，之前所有this._value替换成this.identity() 12345678910111213141516171819202122232425262728class Monad&lt;T&gt; &#123; private _value: T; constructor(value: T) &#123; this._value = value; &#125; isNothing(): boolean &#123; const value = this.identity() return value === undefined || value === null; &#125; join() &#123; if (this._value instanceof Monad) &#123; return this.isNothing() ? Monad.of(null) : this._value.join(); &#125; else return this; &#125; map(fn: (...args: any[]) =&gt; any) &#123; return this.isNothing() ? Monad.of(null) : Monad.of(fn(this.identity())); &#125; static of&lt;U&gt;(value: U) &#123; return new Monad(value); &#125; identity() &#123; return this.join()._value; &#125;&#125;const num = Monad.of(Monad.of(3));num.map((v) =&gt; v + 1); // Monad &#123;_value: 4&#125; Applicative上面的例子都是封装数据。如果函数也是一个functor，就需要提供一个apply方法。 123456789class Applicative&lt;T&gt; &#123; // ... apply(container: Applicative&lt;any&gt;) &#123; return container.map(this._value) &#125; // ...&#125;const plus3 = v =&gt; v + 3;Applicative.of(plus3).apply(Applicative.of(2)) // Applicative &#123;_value: 5&#125; 结合上面的所有例子，梳理一下code 123456789101112131415161718192021222324252627class Monad&lt;T&gt; &#123; private _value: T; constructor(value: T) &#123; this._value = value; &#125; isNothing(): boolean &#123; return this._value === undefined || this._value === null; &#125; join() &#123; if (this._value instanceof Monad) &#123; return this.isNothing() ? Monad.of(null) : this._value.join(); &#125; else return this; &#125; map(fn: (...args: any[]) =&gt; any) &#123; return this.isNothing() ? Monad.of(null) : Monad.of(fn(this.identity())); &#125; apply(container: Monad&lt;any&gt;) &#123; console.log(this.identity()) return container.map(this.identity()) &#125; static of&lt;U&gt;(value: U) &#123; return new Monad(value); &#125; private identity() &#123; return this.join()._value; &#125;&#125;","categories":[{"name":"读书","slug":"读书","permalink":"https://zxffan.github.io/categories/%E8%AF%BB%E4%B9%A6/"}],"tags":[{"name":"functional programing","slug":"functional-programing","permalink":"https://zxffan.github.io/tags/functional-programing/"}]},{"title":"Webpack5","slug":"engineering/Webpack5","date":"2020-11-24T16:00:00.000Z","updated":"2021-06-29T14:04:48.925Z","comments":true,"path":"posts/46109b3a.html","link":"","permalink":"https://zxffan.github.io/posts/46109b3a.html","excerpt":"","text":"Webpack5正式版距V4发布已经过去2年了。新版做了许多API和底层的改动，这会导致一些现有的plugin或者loader无法在V5版本运行。 先贴一下官方文档 本文梳理一些webpck所做出的比较重要的改动 功能清除 new URL 长期缓存 持久化缓存 tree-shaking 联邦模块 功能清除首先，所有在V4标记为废弃的api都被移除。升级前先检查是否使用了被废弃的API（看控制台是否有警告） V5取消默认nodejs的polyfill在V4中可以使用一部分nodejs的API（例如:crypto模块）。在V5中不会对这些API进行polyfill，所以需要手动polyfill 原因：官方认为在绝大数情况下这些polyfill都是不必要的，而且它增大了bundle的体积 Crypto当使用如下代码： 123import CryptoJS from &quot;crypto-js&quot;;const md5Password = CryptoJS.MD5(&quot;123123&quot;);console.log(md5Password); wepack5会自动报错 根据提示操作即可。 processnodejs的process模块无法直接使用。 使用process是，webpack5会报错，提示引入process模块的polyfill。 如果使用process.env.NODE_ENV则不会报错，因为webpack在解析过程中将其值替换成对应mode的值可以使用 DefinePlugin 或 EnvironmentPlugin 在配置中定义这些变量。 其它模块path模块需要手动polyfillurl模块可以直接使用。 new URL引入资源方式webpack5对资源模块提供了内置支持 V4中使用import img from &#39;./picture.png，需要在module.rules中做相应的配置 V5中可以直接使用new URL(&#39;./picture.png&#39;, import.meta.url) import.meta.url 是当前文件的 file: url(类似于__filename)使用URL会向 javascript 注入一个 DataURI Worker由上，可以这么使用worker：new Worker(new URL(&quot;./worker.js&quot;, import.meta.url)) 这样就可以更好地在webpack中使用 webWorker 长期缓存长期缓存的目的是当应用重新打包后尽可能保持文件不变，这样浏览器就可以直接使用缓存。 name id hashwebpack最终输出的文件称为bundle(与chunk一一对应)。其文件名取决于webpack的配置，例如filename: [name].[id].[hash] name 为chunk的名称，name一般取文件名或者或者开发者通过魔法注释指定 id 为chunkId，id是webpack自动生成的（V4是递增的） hash 有分为三种 hash chunkhash contenthash 有时候name等于id？当开发者没有指定name时，name默认取id的值例如：当使用动态import，却没用魔法注释指定chunkName(/* webpackChunkName: “home” */) chunkId 和 moduleId 不稳定在V4中，chunkId和moduleId默认都是递增的：1.js -&gt; 2.js -&gt; 3.js -&gt; 4.js但是当删除2.js后，原来的3就变成2，导致无法直接使用缓存内容，这种现象也被称为chunkId和moduleId不稳定 如何稳定V4中使用外部插件解决 chunkId：可安装NamedChunksPlugin插件来稳定chunkId；或者配置optimization.chunkIds=&#39;named&#39;。 moduleId：可安装HashedModuleIdsPlugin插件覆盖默认的moduleId规则，使用模块路径生成的hash作为moduleId。 V5中对moduleId和chunkId的生成策略进行了优化，从而无需引入任何插件（生产模式下是默认启用的） moduleId改为根据上下文模块路径计算 chunkId根据chunk内容计算 配置optimization 123456789101112export default &#123; // ... optimization: &#123; chunkIds: &#x27;deterministic&#x27;, moduleIds: &#x27;deterministic&#x27; &#125;, //...&#125; 持久化缓存持久化缓存是指第一次全量构建，利用磁盘缓存后续构建会 读取缓存，然后进行校验。 V4中也有类似的手段，比如cache-loader。babel-loader也有cacheDirectory: true。 V5内置了磁盘持久化缓存功能 123456789export default &#123; cache: &#123; // 1. 将缓存类型设置为文件系统 type: &#x27;filesystem&#x27;, // 默认是memory // 2. 将缓存文件夹命名为 .temp_cache, // 默认路径是 node_modules/.cache/webpack cacheDirectory: path.resolve(__dirname, &#x27;.temp_cache&#x27;) &#125;,&#125;; Tree-Shaking优化V5的tree-shaking支持了更多的场景。 嵌套tree-shaking1234567891011// inner.jsexport const a = 1;export const b = 2;// module.jsexport * as inner from &#x27;./inner&#x27;;// 或 import * as inner from &#x27;./inner&#x27;; export &#123; inner &#125;;// user.jsimport * as module from &#x27;./module&#x27;;console.log(module.inner.a); V5 能将b给tree-shaking掉。 内部tree-shaking123456789import &#123; something &#125; from &#x27;./something&#x27;;function usingSomething() &#123; return something;&#125;export function test() &#123; return usingSomething();&#125; 当设置&quot;sideEffects&quot;: false时并且 test 导出未被使用时，不但会删除test也会删除something。 Commonjs tree-shakingV5现在支持CommonJS模块的tree-shaking 联邦模块（Module Federation）概述联邦模块应该是V5中较为亮眼的更新。联邦模块是为了解决应用间模块共享的问题。 换句话说，现在有A、B两个应用。A应用中写了一个工具库，现在B应用也想用。怎么办？首先把工具库抽离出来 发布到npm。应用install来使用 或者打包成UMD，通过CDN类似方式使用 但是这种方式就会有版本问题，A，B应用使用的版本可能不一致。 联邦模块如何做的呢？ 联邦模块可以让B应用直接使用A应用的工具库。 使用场景：两个应用：app1和app2。后者需要使用前者utils.ts app1配置如下： 12345678910111213141516171819202122232425import &#123; ModuleFederationPlugin &#125; from &quot;webpack&quot;export default &#123; // other webpack configs... plugins: [ new ModuleFederationPlugin(&#123; // name 当前应用名称，不能与其它应用冲突 name: &quot;app1&quot;, // UMD标准导出，和name保持一致即可 library: &#123; type: &quot;var&quot;, name: &quot;app_two&quot; &#125;, // 远程应用时被其他应用引入的js文件名称 filename: &quot;remoteEntry.js&quot;, // exposes 表示导出的模块，只有在此申明的模块才可以作为远程依赖被使用 exposes: &#123; utils: &quot;./src/libs/utils.ts&quot; &#125;, // shared可以让远程加载的模块对应依赖改为使用本地项目的 React或ReactDOM。 shared: [&quot;vue&quot;, &quot;vue-router&quot;, &quot;vuex&quot;] &#125;), new HtmlWebpackPlugin(&#123; template: &quot;./public/index.html&quot;, chunks: [&quot;main&quot;] &#125;) ]&#125;; app2配置如下： 12345678910111213141516171819import &#123; ModuleFederationPlugin &#125; from &quot;webpack&quot;export default &#123; // other webpack configs... plugins: [ new ModuleFederationPlugin(&#123; name: &quot;app2&quot;, // remotes 可以将其他项目的 name 映射到当前项目中 remotes: &#123; app1: &quot;app1&quot;, &#125;, shared: [&quot;vue&quot;, &quot;vue-router&quot;, &quot;vuex&quot;] &#125;), new HtmlWebpackPlugin(&#123; template: &quot;./public/index.html&quot;, chunks: [&quot;main&quot;] &#125;) ]&#125;; 在app2中引入模块 1234&lt;head&gt; &lt;!-- remoteEntry.js 是 filename字段的值 --&gt; &lt;script src=&quot;http://localhost:3001/remoteEntry.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 在app2中使用 1import utils from &#x27;app1/utils&#x27; import 的内容是远程应用名/暴露的模块名，对应webpack配置里面的name和expose 玩法微前端联邦模块不仅支持导出应用的某个模块，也支持expose整个应用（expose entry） 对于 主从应用（一个主应用 + 多个子/微应用）这种微前端架构 微应用暴露自己，主应用管理路由并使用微应用 公共模块写在主应用中并暴露出来，微应用再使用 公共组件服务如果团队内部有组件库或工具库。现在不用发布到npm上。可以单独部署一个 公共组件服务。","categories":[{"name":"工程化","slug":"工程化","permalink":"https://zxffan.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"https://zxffan.github.io/tags/webpack/"},{"name":"架构","slug":"架构","permalink":"https://zxffan.github.io/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"HTTP首部","slug":"Network/HTTP首部","date":"2020-11-10T16:00:00.000Z","updated":"2021-06-29T14:06:21.352Z","comments":true,"path":"posts/8b77beaa.html","link":"","permalink":"https://zxffan.github.io/posts/8b77beaa.html","excerpt":"","text":"http首部分为四部分——请求行/状态行、请求/响应首部字段、通用首部字段、实体首部字段组成。 梳理一下当作字典，以便日后查阅。 首部一览HTTP/1.1 规范定义了如下 47 种首部字段。 首部字段名 说明 Cache-Control （强）缓存控制，1.0还有个Expired Connection 通用首部字段通用首部字段是指，请求报文和响应报文双方都会使用的首部。 Cache-Control场景：浏览器第一次请求服务器时，服务端返回资源并再response header加上Cache-Control: max-age=56700000。浏览器接受资源并把资源和相关头信息缓存下来。当第二次请求改资源时，先从缓存中找，计算第一次请求的时间和max-age来判断是否过期。若没过期则取缓存内容，若过期再向服务器请求。 这个字段既可以出现在请求头中也可以出现在响应头中，但参数不太一样 请求头参数 指令 参数 说明 no-cache 无 不使用强缓存，强制向源服务器再次验证（使用协商缓存） no-store 无 不使用缓存 max-age=[ 秒] 秒 缓存的时间 max-stale=[ 秒] 秒 可省略，可容忍的最大过期时间, 接受age+stale时间内的缓存数据 min-fresh=[ 秒] 秒 min-fresh=60要求（缓存）服务器返回缓存时间未过60s的资源 no-transform 无 缓存不能改变实体主体的媒体类型 only-if-cached 无 完全使用缓存，若未命中返回504 Gateway Timeout cache-extension 无 新指令标记（token） cache-extension token可以扩展Cache-Control首部字段内的指令例如：Cache-Control: private, community=&quot;UCI&quot;其中community属于扩展指令 响应头参数 指令 参数 说明 public 无 可以被任意方缓存 private 无 仅可被特定用户缓存 no-cache 无 可省略，使用缓存前先向服务端验证有效性（协商） no-store 无 不缓存请求和响应内容 no-transform 无 缓存不能改变实体主体的媒体类型 must-revalidate 无 可缓存但必须再向源服务器进行确认 proxy-revalidate 无 要求中间缓存服务器对缓存的响应有效性再进行确认 max-age=[ 秒] 秒 缓存的时间 s-maxage=[ 秒] 秒 公共缓存服务器响应的最大Age值 cache-extension 无 新指令标记（token） ConnectionConnection首部字段有两个作用 控制不再转发给代理的首部字段 管理持久化连接 控制不再转发给代理的首部字段使用方式：再请求头加上Connection: 不再转发的首部字段名当请求发送给代理服务器时，代理服务器会剔除指定首部字段，然后再转发给源服务器 持久化连接HTTP/1.1默认全部都是持久化连接，当服务端想断开连接时，在响应头中指定字段Connection: close HTTP/1.0默认是非持久化连接。若想建立持久化连接，请求双方都要在头信息中加上Connection: Keep-Alive DateDate表示创建HTTP报文的日期和时间，格式如：Date: Tue, 03 Jul 2012 04:40:59 GMT PragmaPragma: no-cache与Cache-Control: no-cache作用相同。是为了兼容HTTP/1.0而存在的 Trailer响应首部。Trailer字段指明在报文主体后记录了哪些首部字段，允许发送方在分块发送的消息后面添加额外的元信息使用：Trailer: Expires Transfer-Encoding指定报文主体的传输编码，HTTP/1.1 的传输编码方式仅对分块传输编码有效。使用：Transfer-Encoding: chunk Upgrade用于检测能否升级通信协议，其参数值可以用来指定一个完全不同的通信协议。使用： 12Upgrade: TLS/1.0, HTTP/1.1Connection: Upgrade 通常配合Connection使用，因为Upgrade字段不需要转发 Via用于追踪客户端和服务端之间的请求和响应报文的传输路径 Warning返回与缓存相关的警告，例如：Warning: 113 gw.hackr.jp:8080 &quot;Heuristic expiration&quot; Tue, 03格式：Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间]) 请求首部字段请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。 Accept告知服务器，客户端所期望的媒体类型或媒体类型优先顺序，用q表示权重（取0~1，默认1）使用：Accept: text/html,application/xhtml+xml,application/xml;q=0.9 常见媒体类型: 文本文件 text/html、text/plain、text/css application/xhtml+xml、application/xml 图片文件 image/jpeg、image/gif、image/png 视频文件 video/mpeg、video/quicktime 应用程序使用的二进制文件 application/octet-stream、application/zip Accept-Charset告知服务器，客户端所期望的字符集或字符集的优先顺序，也可以用q来表示权重使用：Accept-Charset: iso-8859-5, unicode-1-1;q=0.8 Accept-Encoding告知服务器，客户端所期望的内容编码或内容编码优先级顺序使用: Accept-Encoding: gzip, deflate 常见编码方式： gzip由文件压缩程序 gzip（GNU zip）生成的编码格式（RFC1952），采用 Lempel-Ziv 算法（LZ77）及 32 位循环冗余校验（Cyclic Redundancy Check，通称 CRC）。 compress由 UNIX 文件压缩程序 compress 生成的编码格式，采用 Lempel-Ziv-Welch 算法（LZW）。 deflate组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法（RFC1951）生成的编码格式。 identity不执行压缩或不会变化的默认编码格式 采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。另外，也可使用星号（*）作为通配符，指定任意的编码格式。 Accept-Language告知服务器客户端所期望的自然语言集（指中文或英文等），以及自然语言集的相对优先级。 使用：Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3 Authorization告知服务器客户端的认证信息。当客户端未携带认证信息，服务端会返回401 Unauthorized使用：Authorization: Basic dWVub3NlbjpwYXNzd29yZA== Expect发送一个POST请求，请求头携带Expect: 100-continue，会先去询问Server是否愿意接受数据接收到Server返回的100-continue应答以后，才能把数据POST给Server From该字段用来记录用户的电子邮件地址，使用：From: yourname@outlook.com Host（重要概念）先明确虚拟主机的概念——一台服务器对应一个公网IP地址，一个IP又可以对应多个域名，那么如何通过不同域名访问对应服务器上不同的站点呢？答案是，将服务器划分成多个虚拟主机，在请求头上加上Host字段指定对应虚拟主机名称，这样就能访问到对应的站点 nginx 划分虚拟主机很简单，直接设置不同的server_name即可 If-Match形如If-*的字段称之为条件请求，只有判断指定条件为真时，才会执行请求。 客户端发送请求，携带If-Match: &quot;123456&quot;。服务端为实体资源生成实体标记ETag，然后判断If-Match和ETag的值。若相同，则返回实体资源；若不同，则返回412 Precondition Failed If-match的取值还可以时*，表示让服务端忽略ETag If-Modified-Since这个请求头与协商缓存有关 客户端第一次发送请求。服务端收到请求后，返回实体资源并加上响应头Last-Modified其值为该资源最后一次修改时间。客户端收到响应后缓存该资源和Last-Modified 客户端第二次发送请求，在请求头上携带If-Modified-Since，其值为上一次服务端返回的Last-Modified值。当服务端收到请求后，检查对应实体资源最新的Last-Modified并与If-Modified-Since对比判断是否过期。若未过期，则返回304 Not Modified表示客户端可以使用缓存；若过期，返回新的实体资源和Last-Modified If-None-Match这个字段与If-Match作用相反 待续… 响应首部字段响应首部字段是服务器返回给客户端的响应报文中所使用的字段 Accept-Ranges用来告知客户端能否处理范围请求 Accept-Ranges: bytes 支持 Accept-Ranges: none 不支持 Age告知客户端，源服务器在多久前创建了响应 Age: 600 单位：s ETagETag是响应资源的唯一性标识，当资源改变，ETag也会变化 强ETag：不论实体发生多么细微的变化都会改变其值 ETag: &quot;usagi-1234&quot; 弱ETag：只有资源发生了根本改变，产生差异时才会改变 ETag 值 ETag: W/&quot;usagi-1234&quot; LocationLocation: http://www.usagidesign.jp/sample.html 引导客户端去指定位置请求资源，配合 3XX: Redirection Proxy-AuthenticateProxy-Authenticate: Basic realm=&quot;Usagidesign Auth&quot; 没搞懂 Retry-AfterRetry-After: 120，单位s，也可以是具体时间 告知客户端，在多久后再次发送请求。配合 503 Service Unavailable或3xx Redirect使用 Server告知客户端，服务器上安装的HTTP服务器应用程序的信息。 Server: Apache/2.2.17 (Unix) Server: Apache/2.2.6 (Unix) PHP/5.2.5 Vary","categories":[{"name":"NetWork","slug":"NetWork","permalink":"https://zxffan.github.io/categories/NetWork/"}],"tags":[{"name":"NetWork","slug":"NetWork","permalink":"https://zxffan.github.io/tags/NetWork/"},{"name":"HTTP Header","slug":"HTTP-Header","permalink":"https://zxffan.github.io/tags/HTTP-Header/"}]},{"title":"HTTP梳理","slug":"Network/HTTP梳理","date":"2020-11-03T16:00:00.000Z","updated":"2021-06-29T14:06:24.591Z","comments":true,"path":"posts/3b531846.html","link":"","permalink":"https://zxffan.github.io/posts/3b531846.html","excerpt":"","text":"HTTP工作模型一次HTTP请求涉及到两个角色——客户端和服务端。 客户端发送请求（报文） 服务端收到请求开始处理 然后把响应（报文）发送回客户端 持久化连接和管线化持久化连接传输层的TCP协议，规定通信双方必须先建立连接再通信。 在HTTP的初始版本，每进行一次HTTP通信就要断开一次TCP，多个HTTP请求不能复用一个TCP连接 在HTTP1.1中，默认开启持久化连接，是多个HTTP请求可以复用同一个TCP连接。只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。 管线化持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。 无状态和Cookie无状态协议HTTP协议自身不具备保存之前发送过的请求或响应的功能每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。 但是无状态也会导致新的问题——用户登陆状态如何保存？ 于是引入了Cookie CookieCookie 是通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。 客户端发送请求报文 服务端收到请求，处理。在响应报文中添加一个Set-Cookie的首部字段 客户端收到响应，取出Set-Cookie的信息 客户端以后发送的请求，在请求报文首部加上Cookie。这样服务端就能识别客户端了。 HTTP 报文用于 HTTP 协议交互的信息被称为 HTTP 报文。请求端（客户端）的HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。 HTTP报文由报文首部（header）和报文主体（body）构成，两者以空行（CR+LF）分隔 报文：是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。 提升传输速率压缩内容编码保持实体信息原样压缩，内容编码后的实体由客户端接收并负责解码。 常用的内容编码有以下几种。 gzip（GNU zip） compress（UNIX 系统的标准压缩） deflate（zlib） identity（不进行编码） 分块分块传输编码会将实体主体分成多个部分（块）。使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。 多部分对象集合HTTP协议发送的报文主体可以包含多个类型实体。多部分对象集合包含的对象如下： multipart/form-data: Content-Type: multipart/form-data; boundary=AaB03x multipart/byteranges: Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES Content-Type定义资源类型boundary定义不同类型实体之间的分隔符 范围请求指定范围发送的请求叫做范围请求byte 范围的指定形式如下。 5001~10 000 字节：Range: bytes=5001-10000 从 5001 字节之后全部的: Range: bytes=5001- 从一开始到 3000 字节和 5000~7000 字节的多重范围: Range: bytes=-3000, 5000-7000 针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文。 内容协商内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。 比如说，客户端浏览器是英文的，服务器返回的网页也会是英文的。 相关首部字段如下： Accept Accept-Charset Accept-Encoding Accept-Language Content-Language HTTP状态码 类别 说明 1XX Informational(信息性状态码) 接收到的请求正在处理 2XX Success(成功状态吗) 请求正常处理完毕 3XX Redirection(重定向状态吗) 需要进行附加操作已完成请求 4XX Client Error(客户端错误状态码) 服务器无法处理请求 5XX Server Error(服务器错误状态吗) 服务器处理请求出错 2XX200 OK表示客户端发来的请求在服务端被正常处理了 204 No Content请求处理成功，但是没有资源课返回 206 Partial Content客户端进行了范围请求，服务器成功执行了这部分请求。响应报文中包含由 Content-Range 指定范围的实体内容。 3XX301 Moved Permanently表示所请求的资源已转移到了新的URI 302 Found临时重定向，该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。 和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI 将来还有可能发生改变。 303 See Other该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。 303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。 304 Not Modified服务端返回304，表示资源没有改动。浏览器可以从本地缓存中读取资源。 307 Temporary Redirect临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。 4XX400 Bad Request表示请求报文存在错误 401 Unauthorized没有通过HTTP认证，当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。 403 Forbidden该状态码表明对请求资源的访问被服务器拒绝了 404 Not Found所请求的资源不存在。 5XX500 Internal Server Error该状态码表明服务器端在执行请求时发生了错误 503 Service Unavailable该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入RetryAfter 首部字段再返回给客户端。","categories":[{"name":"NetWork","slug":"NetWork","permalink":"https://zxffan.github.io/categories/NetWork/"}],"tags":[{"name":"NetWork","slug":"NetWork","permalink":"https://zxffan.github.io/tags/NetWork/"},{"name":"HTTP","slug":"HTTP","permalink":"https://zxffan.github.io/tags/HTTP/"}]},{"title":"Web网络基础","slug":"Network/Web网络基础","date":"2020-11-02T16:00:00.000Z","updated":"2021-06-29T14:06:30.580Z","comments":true,"path":"posts/4e5b3a92.html","link":"","permalink":"https://zxffan.github.io/posts/4e5b3a92.html","excerpt":"","text":"TCP/IPTCP/IP是互联网相关的各类协议族的总称TCP/IP具有分层结构，分为：应用层、传输层、网络层和数据链路层 应用层应用层决定了向用户提供应用服务时通信的活动。相关协议：FTP、DNS以及HTTP 传输层传输层提供处于网络连接中的两台计算机之间的数据传输相关协议：TCP和UDP 网络层网络层规定了数据包通过怎样的传输线路到达对方计算机相关协议：IP 数据链路层数据链路是用来处理连接网络的硬件部分例如：NIC(网卡)、光纤等物理可见部分 通信传输流 发送端再每一层都会打上包含该层所属的一个首部。当接收端接收到数据时，会依次拆开首部。 与HTTP有关的协议IP**网际协议(Internet Protocol, IP)**位于网络层，其作用是把数据包传送给对方。具体如何规定传送呢？ 每个网络节点都有一个IP地址，每一台计算机的网卡都有一个固定的MAC地址。IP地址又可以通过ARP协议转换成MAC地址 数据包发送过程如下： 网关（一般为路由器）的 IP 地址被 ARP 协议解析为 MAC 地址。根据该 MAC 地址，源主机将数据包发送到网关。 网关根据数据包中的网段 ID 寻找目标网络。如果找到，将数据包发送到目标网段；如果没找到，重复步骤（1）将数据包发送到上一级网关。 数据包经过网关被发送到正确的网段中。目标IP地址被ARP协议解析为 MAC 地址。根据该 MAC 地址，数据包被发送给目标地址的主机。 TCP传输控制协议( Transport Control Protocol, TCP)位于传输层，提供可靠的字节流服务即将大块数据分割成报文段为单位的数据包进行管理。 三次握手 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，会回传一个带有SYN/ACK标志的数据包以表示传达确认信息。最后，发送端再发送一个带有ACK标志的数据包，代表“握手”结束 DNS**域名解析服务(Domain Name System, DNS)**位于应用层，提供通过域名查找IP地址，或者逆向从IP地址查找域名的服务 HTTP协议与其它协议的关系 URL与URI区别统一资源标识符（Uniform Resource Identifier, URI）统一资源定位符（Uniform Resource Locator， URL）统一资源名称（Uniform Resource Name， URN） URL和URN都是URI的子集。比如说人们的身份证号码就是URN（能够唯一标识），一个网站http://zxffan.github.io/就是URL。它们都属于URI URI格式 协议方案名诸如：HTTP、HTTPS 登录信息可选项，指定用户名和密码 服务器地址服务器地址可以是域名，也可以是IP地址 服务器端口号可选，没有取默认端口号，不同协议有不同的默认端口号。HTTP是80；HTTPS是443 带层次的文件路径指定服务器上的文件路径来定位特指的资源 查询字符串可选，使用查询字符串向指定资源传入任意参数 片段标识符可选，标记已获取资源的子资源","categories":[{"name":"NetWork","slug":"NetWork","permalink":"https://zxffan.github.io/categories/NetWork/"}],"tags":[{"name":"NetWork","slug":"NetWork","permalink":"https://zxffan.github.io/tags/NetWork/"},{"name":"HTTP","slug":"HTTP","permalink":"https://zxffan.github.io/tags/HTTP/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://zxffan.github.io/tags/TCP-IP/"}]},{"title":"CSS Review","slug":"CSS/CSS Review","date":"2020-10-27T16:00:00.000Z","updated":"2021-06-29T14:04:05.447Z","comments":true,"path":"posts/6e1418c.html","link":"","permalink":"https://zxffan.github.io/posts/6e1418c.html","excerpt":"","text":"浏览器渲染浏览器解析一个页面会按照以下流程： 根据HTML构建DOM Tree 根据CSS构建CSSOM Tree DOM Tree和CSSOM Tree合并生成Render Tree 布局：计算元素的大小及位置 绘制：将Render Tree中的每个节点转换成屏幕上的实际像素 如何从HTML到DOM Tree？读取HTML文档的字节(Bytes)将字节转换成字符(Chars)依据字符确定标签(Tokens)将标签转换成节点(Nodes)以节点为基准构建DOM树。 如何从CSS到CSSOM Tree？与DOM树的构建过程类似。 阻塞渲染在生成Dom Tree的过程中，script标签会阻塞渲染线程工作。此时，控制权交给了JS引擎线程， JavaScript脚本执行完成之后再交由渲染引擎继续解析。 为什么要阻塞？JS是能够操作DOM的。JS开始工作后并不确定DOM的结构（因为会变），所以暂停渲染线程工作。 回流和重绘回流回流（重排）是指当DOM节点的几何属性（位置、大小等）发生改变后，渲染线程需要重新计算位置和形状的现象。换句话说，就是DOM节点的变化导致文档流变化。 重绘重绘是指当DOM节点的外观属性（颜色、透明度、文字等），渲染线程需要重新绘制的现象。换句话说，就是DOM节点的变化不会导致文档流变化。回流一定导致重绘，重绘不一定导致回流。尽可能的避免回流的发生。当需要改变元素位置时，使用transform代替top bottom left right。前者只会引发图层重绘，还会间接启动GPU加速。 习惯：CSS属性排序书写比较好的书写顺序是按照类型排序。 按照布局 → 尺寸 → 界面 → 文字 → 交互的方式顺序书写CSS属性 布局属性 显示：display visibility 溢出：overflow overflow-x overflow-y 浮动：float clear 定位：position left right top bottom z-index 列表：list-style list-style-type list-style-position list-style-image 表格：table-layout border-collapse border-spacing caption-side empty-cells 弹性：flex-flow flex-direction flex-wrap justify-content align-content align-items align-self flex flex-grow flex-shrink flex-basis order 多列：columns column-width column-count column-gap column-rule column-rule-width column-rule-style column-rule-color column-span column-fill column-break-before column-break-after column-break-inside 格栅：grid-columns grid-rows 尺寸属性 模型：box-sizing 边距：margin margin-left margin-right margin-top margin-bottom 填充：padding padding-left padding-right padding-top padding-bottom 边框：border border-width border-style border-color border-colors border-[direction]-&lt;param&gt; 圆角：border-radius border-top-left-radius border-top-right-radius border-bottom-left-radius border-bottom-right-radius 框图：border-image border-image-source border-image-slice border-image-width border-image-outset border-image-repeat 大小：width min-width max-width height min-height max-height 界面属性 外观：appearance 轮廓：outline outline-width outline-style outline-color outline-offset outline-radius outline-radius-[direction] 背景：background background-color background-image background-repeat background-repeat-x background-repeat-y background-position background-position-x background-position-y background-size background-origin background-clip background-attachment bakground-composite 遮罩：mask mask-mode mask-image mask-repeat mask-repeat-x mask-repeat-y mask-position mask-position-x mask-position-y mask-size mask-origin mask-clip mask-attachment mask-composite mask-box-image mask-box-image-source mask-box-image-width mask-box-image-outset mask-box-image-repeat mask-box-image-slice 滤镜：box-shadow box-reflect filter mix-blend-mode opacity, 裁剪：object-fit clip 事件：resize zoom cursor pointer-events touch-callout user-modify user-focus user-input user-select user-drag 文字属性 模式：line-height line-clamp vertical-align direction unicode-bidi writing-mode ime-mode 文本：text-overflow text-decoration text-decoration-line text-decoration-style text-decoration-color text-decoration-skip text-underline-position text-align text-align-last text-justify text-indent text-stroke text-stroke-width text-stroke-color text-shadow text-transform text-size-adjust 字体：src font font-family font-style font-stretch font-weight font-variant font-size font-size-adjust color 内容：overflow-wrap word-wrap word-break word-spacing letter-spacing white-space caret-color tab-size content counter-increment counter-reset quotes page page-break-before page-break-after page-break-inside 交互属性 模式：will-change perspective perspective-origin backface-visibility 变换：transform transform-origin transform-style 过渡：transition transition-property transition-duration transition-timing-function transition-delay 动画：animation animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction animation-play-state animation-fill-mode 盒模型老生常谈——盒模型 盒模型标准盒模型 （box-sizing为content-box）怪异（IE）盒模型（box-sizing为border-box） 视觉格式化模型块级元素：display声明为block、list-item、table、flex或grid时行内元素：display声明为inline、inline-block、inline-table、inline-flex或inline-grid时 格式化上下文 上下文 缩写 版本 说明 块格式化上下文 BFC 2 块级盒子容器 行内格式化上下文 IFC 2 行内盒子容器 弹性格式化上下文 FFC 3 弹性盒子容器 格栅格式化上下文 GFC 3 格栅盒子容器 BFC——块级格式上下文通常由一个父元素和若干子元素组成。同一个BFC的子元素以及相邻的父子元素会发生margin重叠现象，不同BFC的元素不会发生重叠。BFC可以自动撑开元素（包含浮动元素） 属性优先级!important： 10000内联样式、外联样式：1000ID选择器：100类选择器、伪类选择器、属性选择器：10元素选择器、伪元素选择器：1通配选择器、后代选择器、兄弟选择器：0 布局普通布局符合默认布局规则。块级元素占满一行。不够一行自动换行 浮动布局使用float: left | right使元素浮动（会脱离正常文档流）。 定位布局使用position: relative | absolute | fixed设置相对/绝对定位。top | left | right | bottom设置位置 表格布局（不要使用）使用table特性来布局很小的改动就会导致table发生回流。 弹性布局使用display: flex | inline-flex设置弹性盒子容器 多列布局使用column-width和column-count来设置列宽和列数（兼容IE10）可以使用columns: column-width column-count简写形式 column-rule属性规定了列与列之间的直线column-rule: column-rule-width column-rule-style column-rule-color与border属性类似 column-span: none | all，all表示跨越所有列。 栅格布局使用display: grid | inline-grid来设置栅格容器 响应式布局使用响应式单位：vw、vh、rem等使用媒体查询 12345@media screen and (max-width: 300px) &#123; body &#123; background-color: red; &#125;&#125; 内置函数Function颜色函数rgb()：RGB颜色函数，红绿蓝rgba()：RGBA颜色函数，A：透明度 hsl()：HSL颜色函数。H：色相（0-360deg），0deg和360deg为红色，120deg为绿色，240deg为蓝色。S：饱和度（0-100%），0%为灰色，100%为全色。L：亮度（0-100%），0%为最暗，100%为最亮。 hsla()：HSLA颜色函数 属性函数attr：获取节点属性，目前只能配合伪元素的content属性使用var：获取变量 12345--font-color: red;.warn-tip &#123; font-color: var(--font-color);&#125; 数学函数min()：最小值max()：最大值 clamp()：计算区间范围clamp(MIN, VAL, MAX)，最小值、首选值、最大值。相当于max(MIN, min(VAL, MAX)) calc()：计算。数值、长度、角度、时间和百分比都能作为参数 counter()/counters()：计数器，只能用于伪元素的content属性。需要结合counter-reset和counter-increment两个属性使用 counter-reset：重置计数器名称与初始值，编写形式为counter-reset:name val counter-increment：对指定计数器累计其计数值，编写形式为counter-increment:name，在使用到的地方声明就会累加 1234567counter-reset: times 1; /* 初始化times */counter-increment: times 1; /* time 加1 */.count::after &#123; content: counter(times);&#125; 背景函数url()：图像路径element()（only Firfox）：可以将网站中的某部分当作图片渲染，返回一个图像。结合background等属性使用 image-set()：图像集合，根据屏幕分辨率匹配合适图像渐变： linear-gradient()：线性渐变 radial-gradient()：径向渐变 conic-gradient()：锥形渐变 repeat-linear-gradient() repeat-radial-gradient() repeat-conic-gradient() 滤镜函数结合filter属性使用 blur(100)：模糊，具体值默认0brightness(%)：亮度contrast(%)：对比度drop-shadow(h-shadow v-shadow blur spread color)：阴影grayscale(%)：灰度hue-rotate(deg)：色相旋转invert(%)：反转opacity(%)：透明度saturate(%)：饱和度sepia(%)：褐色 图形函数结合clip-path使用，用来裁剪区域 circle(30% at 50% 50%)：圆形裁剪，半径 at 圆心ellipse(20px 10px at 50% 50%)：椭圆形裁剪，横轴 纵轴 at 圆心inset(100px 50px)：矩形，长宽path()：按照路径裁剪polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)：按照多边形裁剪（顺时针） 变换函数结合transform属性使用 rotate(deg | turn)translate(x, y)scale(x y)skew(x, y)perspective()：设置透视试图 缓动函数cubic-bezier()：贝塞尔曲线steps()：逐帧 变量VariableCSS有自己的一套变量系统。兼容性如下： ![css var](../../images/css var.jpg) 认识 声明：--变量名 读取：var(--变量名, 默认值) 类型 普通：只能用作属性值不能用作属性名 字符：与字符串拼接 &quot;Hello, &quot;var(--name) 数值：使用calc()与数值单位连用 var(--width) * 10px 作用域 范围：在当前节点块作用域及其子节点块作用域下有效 优先级别：内联样式 = 外联样式 &gt; ID选择器 &gt; 类选择器 = 伪类选择器 = 属性选择器 &gt; 元素选择器 = 伪元素选择器 &gt; 通配选择器 = 后代选择器 = 兄弟选择器 使用技巧主题换肤123456789101112131415161718192021&lt;template&gt; &lt;div ref&#x3D;&quot;container&quot; style&#x3D;&quot;--theme-color: white&quot;&gt;&lt;&#x2F;div&gt; &lt;button @click&#x3D;&quot;switchTheme&quot;&gt;换肤&lt;&#x2F;button&gt;&lt;&#x2F;template&gt; &lt;script&gt;export default &#123; methods: &#123; switchTheme() &#123; this.$refs.container.style.setProperty(&quot;--theme-color&quot;, &quot;red&quot;) &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;scss&quot;&gt; .container &#123; --bg-color: var(--theme-color); background-color: var(--bg-color); &#125;&lt;&#x2F;style&gt; 可见，css变量可以与JS进行交互。scss的变量做不到。 悬浮视差123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;template&gt; &lt;div ref&#x3D;&quot;bg&quot; class&#x3D;&quot;bruce flex-ct-x&quot; data-title&#x3D;&quot;悬浮视差按钮&quot;&gt; &lt;a ref&#x3D;&quot;btn&quot; class&#x3D;&quot;parallax-btn&quot; data-name&#x3D;&quot;妙用CSS变量，让你的CSS变得更心动&quot; @mousemove&#x3D;&quot;move&quot; @mouseup&#x3D;&quot;up&quot; @mousedown&#x3D;&quot;down&quot; @mouseleave&#x3D;&quot;leave&quot; &gt;&lt;&#x2F;a&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; mounted() &#123; this.bgStyle &#x3D; this.$refs.bg.style; this.btnRect &#x3D; this.$refs.btn.getBoundingClientRect(); &#125;, methods: &#123; down(e) &#123; this.bgStyle.setProperty(&quot;--tz&quot;, &quot;-25px&quot;); &#125;, leave(e) &#123; this.bgStyle.setProperty(&quot;--ty&quot;, &quot;0&quot;); this.bgStyle.setProperty(&quot;--rx&quot;, &quot;0&quot;); this.bgStyle.setProperty(&quot;--ry&quot;, &quot;0&quot;); &#125;, move(e) &#123; const dx &#x3D; e.offsetX - this.btnRect.width &#x2F; 2; const dy &#x3D; e.offsetY - this.btnRect.height &#x2F; 2; this.bgStyle.setProperty(&quot;--rx&quot;, &#96;$&#123;dy &#x2F; -1&#125;deg&#96;); this.bgStyle.setProperty(&quot;--ry&quot;, &#96;$&#123;dx &#x2F; 10&#125;deg&#96;); &#125;, up() &#123; this.bgStyle.setProperty(&quot;--tz&quot;, &quot;-12px&quot;); &#125;, &#125;,&#125;;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;scss&quot; scoped&gt;.bruce &#123; transform: perspective(800px); transform-style: preserve-3d; height: 100vh; display: flex; justify-content: center; align-items: center;&#125;.parallax-btn &#123; position: relative; width: 400px; height: 50px; cursor: pointer; user-select: none; line-height: 50px; text-align: center; font-size: 18px; color: #fff; &amp;::before &#123; position: absolute; left: 0; right: 0; top: 0; bottom: 0; border-radius: 4px; background: linear-gradient(135deg, #6e8efb, #a777e3); box-shadow: 0 2px 5px rgba(#000, 0.2); content: &quot;&quot;; will-change: transform; transform: translateY(var(--ty, 0)) rotateX(var(--rx, 0)) rotateY(var(--ry, 0)) translateZ(var(--tz, -12px)); transition: box-shadow 500ms ease, transform 200ms ease; &#125; &amp;::after &#123; display: inline-block; position: relative; font-weight: bold; content: attr(data-name); will-change: transform; transform: translateY(var(--ty, 0)) rotateX(var(--rx, 0)) rotateY(var(--ry, 0)); transition: transform 200ms ease; &#125; &amp;:hover::before &#123; box-shadow: 0 5px 15px rgba(#000, 0.3); &#125;&#125;&lt;&#x2F;style&gt; 选择器Selector基础选择器 选择器 别名 说明 版本 tag 标签选择器 指定类型的标签 1 #id ID选择器 指定身份的标签 1 .class 类选择器 指定类名的标签 1 * 通配选择器 所有类型的标签 2 层次选择器 选择器 别名 说明 版本 a b 后代选择器 元素的后代元素 1 a &gt; b 子代选择器 元素的子代元素 2 a + b 相邻同胞选择器 元素相邻的同胞元素 2 a ~ b 通用同胞选择器 元素后面的同胞元素 3 集合选择器 选择器 别名 说明 版本 a, b 并集选择器 多个指定的元素 1 a.class 交集选择器 指定类名的元素 1 条件选择器 选择器 说明 版本 :lang 指定标记语言的元素，例：p:lang(en) 2 :dir() 指定编写方向的元素 4 :has 包含指定元素的元素 4 :is 指定条件的元素 4 :not 非指定条件的元素 4 :where 指定条件的元素 4 :scope 指定元素作为参考点 4 :any-link 所有包含href的链接元素 4 :local-link 所有包含href且属于绝对地址的链接元素 4 上面许多选择器，目前主流浏览器都未实现 行为选择器 选择器 说明 版本 :active 鼠标激活的元素 1 :hover 鼠标悬浮的元素 1 ::selection 鼠标选中的元素 3 状态选择器 选择器 说明 版本 :target 当前锚点的元素 3 :link 未访问的链接元素 1 :visited 已访问的链接元素 1 :focus 输入聚焦的表单元素 2 :required 输入必填的表单元素 3 :valid 输入合法的表单元素 3 :invalid 输入非法的表单元素 3 :in-range 输入范围以内的表单元素 3 :out-of-range 输入范围以外的表单元素 3 :checked 选项选中的表单元素搭配appearance，可以自定义默认的单选、复选框 3 :optional 选项可选的表单元素，没有required的都是 3 :enabled 事件启用的表单元素，与disabled相对应 3 :disabled 事件禁用的表单元素 3 :read-only 只读的表单元素，与read-write相对应 3 :read-write 可读可写的表单元素 3 :target-within 内部锚点元素处于激活状态的元素 4 :focus-within 内部表单元素处于聚焦状态的元素 4 :focus-visible 输入聚焦的表单元素 4 :blank 输入为空的表单元素 4 :user-invalid 输入合法的表单元素 4 :indeterminate 选项未定的表单元素 4 :placeholder-shown 占位显示placeholder的表单元素(input) 4 :current() 浏览中的元素 4 :past() 已浏览的元素 4 :future() 未浏览的元素 4 :playing 开始播放的媒体元素 4 :paused 暂停播放的媒体元素 4 结构选择器 选择器 说明 版本 :root 文档的根元素，即html通常在这声明全局变量 3 :empty 无子元素的元素 3 :first-letter 元素的首字母 1 :first-line 元素的首行 1 :nth-child(n) 指定元素的父元素的第n个子元素 3 :nth-last-child(n) 指定元素的父元素的倒数第n个子元素 3 :first-child 指定元素的父元素的第一个子元素 2 :last-child 指定元素的父元素的最后一个子元素 3 :only-child 父元素仅有该元素的元素 3 :nth-of-type(n) 指定元素的父元素的第n个与指定元素相同标签的子元素 3 :nth-last-of-type(n) 指定元素的父元素的倒数第n个与指定元素相同标签的子元素 3 :first-of-type 指定元素的父元素的第一个与指定元素相同标签的子元素 3 :last-of-type 指定元素的父元素的最后一个与指定元素相同标签的子元素 3 :only-of-type 父元素仅有该标签的标签 3 属性选择器 选择器 说明 版本 [attr] 指定属性的元素 2 [attr=val] 属性等于指定值的元素 2 [attr*=val] 属性包含指定值的元素 3 [attr^=val] 属性以指定值开头的元素 3 [attr$=val] 属性以指定值结尾的元素 3 [attr~=val] 属性包含指定值(完整单词)的元素(不推荐使用) 2 `[attr =val]` 属性以指定值(完整单词)开头的元素(不推荐使用) 伪元素 选择器 说明 版本 ::before 在指定元素所有子元素前插入的内容 2 ::after 在指定元素所有子元素后插入的内容 2 背景Background所有属性background子属性众多，其属性取值也很多。 background-color：颜色 transparent：透明(默认) Keyword：颜色关键字 HEX：十六进制色彩模式 RGB或RGBA：RGB/A色彩模式 HSL或HSLA：HSL/A色彩模式 Color1/Color2：覆盖颜色，背景颜色可能是Color1，若背景图像无效则使用Color2代替Color1 background-image：图像 none：无图像(默认) url()：图像路径 background-repeat：图像平铺方式 repeat：图像在水平方向和垂直方向重复(默认) repeat-x：图像在水平方向重复 repeat-y：图像在垂直方向重复 no-repeat：图像仅重复一次 space：图像以相同间距平铺且填充整个节点 round：图像自动缩放直到适应且填充整个节点 background-attachment：图像依附方式 scroll：图像随页面滚动而移动(默认) fixed：图像不会随页面滚动而移动 background-position：图像起始位置 Position：位置，可用任何长度单位，第二个位置(Y轴)不声明默认是50%(默认0% 0%) Keyword：位置关键字left、right、top、bottom、center，可单双使用，第二个关键字不声明默认是center background-size：图像尺寸模式 auto：自动设置尺寸(默认) cover：图像扩展至足够大，使其完全覆盖整个区域，图像某些部分也许无法显示在区域中 contain：图像扩展至最大尺寸，使其宽度和高度完全适应整个区域 Size：尺寸，可用任何长度单位，第二个尺寸(高)不声明默认是auto background-origin：定位区域(与background-position结合使用) padding-box：图像相对填充定位(默认) border-box：图像相对边框定位 content-box：图像相对内容定位 background-clip：绘制区域 border-box：图像被裁剪到边框与边距的交界处(默认) padding-box：图像被裁剪到填充与边框的的交界处 content-box：图像被裁剪到内容与填充的交界处 background-blend-mode：混合模式 normal：正常(默认) color-burn：颜色加深 color-dodge：颜色减淡 color：颜色 darken：变暗 difference：差值 exclusion：排除 hard-light：强光 hue：色相 lighten：变亮 luminosity：亮度 multiply：正片叠底 overlay：叠加 saturation：饱和度 screen：滤色 soft-light：柔光 background属性可以连写。 background: color image repeat attachment position/size 支持多重背景：background-image: url($bg-4), url($bg-3); 背景渐变CSS渐变分为3种： 线性渐变：沿着指定方向从起点到终点逐渐改变颜色，渐变形状是一条直线 径向渐变：沿着任意方向从圆心往外面逐渐改变颜色，渐变形状是一个圆形或椭圆形 锥形渐变：沿着顺时针方向从圆心往外面逐渐改变颜色，渐变形状是一个圆锥体 相关属性有6个 **linear-gradient()**：线性渐变 **radial-gradient()**：径向渐变 **conic-gradient()**：锥形渐变 **repeating-linear-gradient()**：重复线性渐变 **repeating-radial-gradient()**：重复径向渐变 **repeating-conic-gradient()**：重复锥形渐变 线性渐变background-image: linear-gradient(direction, color-stop) direction：方向 Keyword：方向关键字to left/right/top/bottom/top left/top right/bottom left/bottom right(默认to bottom) Angle：角度，以顺时针方向的垂直线和渐变线的夹角计算，超出N圈则计算剩余角度 color-stop：色标 Color：颜色，可参考background-color取值，在指定位置产生渐变效果所使用的颜色 Position：位置，可参考background-position的Position取值，在指定位置产生渐变效果 12345678910.elem &#123; width: 400px; height: 200px; background-image: linear-gradient(to bottom, #f66, #66f); /* 等价于 */ background-image: linear-gradient(to bottom, #f66 0, #66f 100%); /* color start end */ /* background-image: linear-gradient(to bottom, #f66 0 50%, #66f 100%); */&#125; css的角度跟直角坐标系不同，正上方为0度，类似表盘 ![css degree](../../images/css degree.jpg) 径向渐变background-image: radial-gradient(shape size at position, color-stop) 径向渐变可以用来话饼图。 Shape：形状 ellipse：椭圆形(默认) circle：圆形 Size：尺寸 farthest-corner：从圆心到离圆心最远的角为半径(默认) farthest-side：从圆心到离圆心最远的边为半径 closest-corner：从圆心到离圆心最近的角为半径 closest-side：从圆心到离圆心最近的边为半径 Size：尺寸，可用任何长度单位，宽和高必须同时声明 Position：位置 Keyword：位置关键字left、right、top、bottom、center(默认center) Position：位置，可用任何长度单位 color-stop：色标 Color：颜色，可参考background-color取值，在指定位置产生渐变效果所使用的颜色 Position：位置，可参考background-position的Position取值，在指定位置产生渐变效果 1234567.elem &#123; width: 400px; height: 200px; background-image: radial-gradient(100px 100px, #f66, #66f); /* 等价于 */ background-image: radial-gradient(ellipse 100px 100px at center, #f66, #66f);&#125; 锥形渐变background-image: conic-gradient(color-stop) color-stop：色标 Color：颜色，可参考background-color取值，在指定位置产生渐变效果所使用的颜色 Position：位置，可参考background-position的Position取值，在指定位置产生渐变效果 1234567.elem &#123; width: 400px; height: 200px; background-image: conic-gradient(#f66, #66f); /* 等价于 */ background-image: conic-gradient(#f66 0, #66f 100%);&#125; 实现网格图层123456789101112131415161718192021222324&lt;template&gt; &lt;div class&#x3D;&quot;grid-box&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;style&gt; background-image: linear-gradient( to top right, #eee 25%, transparent 25%, transparent 75%, #eee 75%, #eee 100% ), linear-gradient( to top right, #eee 25%, transparent 25%, transparent 75%, #eee 75%, #eee 100% ); background-position: 0 0, 10px 10px; background-size: 20px 20px;&lt;&#x2F;style&gt; 遮罩遮罩或者说蒙版，就是在背景上再加一层。它可以实现诸如裁剪背景的效果。 mask子属性比background子属性差不多。 mask-mode：模式 match-source：根据图像类型采用合适的遮罩模式(默认) alpha：根据图像透明度采用合适的遮罩模式 luminance：根据图像亮度采用合适的遮罩模式 mask-image：图像 none：无图像(默认) url()：图像路径 mask-repeat：图像平铺方式 repeat：图像在水平方向和垂直方向重复(默认) repeat-x：图像在水平方向重复 repeat-y：图像在垂直方向重复 no-repeat：图像仅重复一次 space：图像以相同间距平铺且填充整个节点 round：图像自动缩放直到适应且填充整个节点 mask-position：图像起始位置 Position：位置，可用任何长度单位，第二个位置(Y轴)不声明默认是50%(默认0% 0%) Keyword：位置关键字left、right、top、bottom、center，可单双使用，第二个关键字不声明默认是center mask-size：图像尺寸模式 auto：自动设置尺寸(默认) cover：图像扩展至足够大，使其完全覆盖整个区域，图像某些部分也许无法显示在区域中 contain：图像扩展至最大尺寸，使其宽度和高度完全适应整个区域 Size：尺寸，可用任何长度单位，第二个尺寸(高)不声明默认是auto mask-origin：定位区域(与mask-position结合使用) padding-box：图像相对填充定位(默认) border-box：图像相对边框定位 content-box：图像相对内容定位 mask-clip：绘制区域 border-box：图像被裁剪到边框与边距的交界处(默认) padding-box：图像被裁剪到填充与边框的的交界处 content-box：图像被裁剪到内容与填充的交界处 mask-composite：混合模式 source-over：叠加，显示遮罩图像合并处 subtract：相减，不显示遮罩图像重合处 intersect：相交，显示遮罩图像重合处 exclude：排除，显示遮罩图像合并处但不显示重合处 阴影Shadow阴影三剑客——box-shadow、text-shadow、drop-shadow() 想要盒子轮廓产生阴影效果，使用box-shadow 想要文本轮廓产生阴影效果，使用text-shadow 想要透明图像的非透明部分轮廓产生阴影效果，使用fliter:drop-shadow() 三个方法参数类似： 123box-shadow: offset-x offset-y blur spread color positiontext-shadow: offset-x offset-y blur colorfilter: drop-shadow(offset-x, offset-y, blur, color) OffsetX：水平偏移，阴影的水平位置(必选) Offset：偏移，可用任何长度单位，允许负值，正值向右负值向左(默认0) OffsetY：垂直偏移，阴影的垂直位置(必选) Offset：偏移，可用任何长度单位，允许负值，正值向下负值向上(默认0) Blur：模糊半径，阴影的清晰程度(虚色) Length：长度，可用任何长度单位，值越大边缘越模糊(默认0) Spread：扩展距离，阴影的实体尺寸(实色) Length：长度，可用任何长度单位，允许负值，正值扩大负值缩小(默认0) Color：投影颜色 transparent：透明(默认) Keyword：颜色关键字 HEX：十六进制色彩模式 RGB或RGBA：RGB/A色彩模式 HSL或HSLA：HSL/A色彩模式 Position：投影位置 outset：阴影显示在外部(默认) inset：阴影显示在内部 滤镜Filtercss的filter属性提供了众多的图片处理效果。 blur()：模糊 Length：长度，可用任何长度单位，值为0显示原图，值越大越模糊 brightness()：亮度 Percentage：百分比，可用0~1代替，值为0显示全黑，值为100%显示原图 contrast()：对比度 Percentage：百分比，可用0~1代替，值为0显示全黑，值为100%显示原图 drop-shadow()：阴影 参考上述阴影 grayscale()：灰度 Percentage：百分比，可用0~1代替，值为0显示原图，值为100%显示全灰 hue-rotate()：色相旋转 Angle：角度，值为0显示原图，值为0~360deg减弱原图色彩，值超过360deg则相当绕N圈再计算剩余的值 invert()：反相 Percentage：百分比，可用0~1代替，值为0显示原图，值为100%完全反转原图色彩 opacity()：透明度 Percentage：百分比，可用0~1代替，值为0显示透明，值为100%显示原图 saturate()：饱和度 Percentage：百分比，可用0~1代替，值为0完全不饱和原图，值为100%显示原图 sepia()：褐色 Percentage：百分比，可用0~1代替，值为0显示原图，值为100%显示褐色 当节点声明不为none的filter时，若其子节点有position: absolute/fixed的元素。它会相对于filter节点进行定位 变换Transform变换分为2D和3D变换，通过transform-style属性来声明 flat：所有变换效果在平面上呈现(默认) preserve-3d：所有变换效果在空间上呈现 变换效果通过transform属性来声明： translate()：位移 **translate(x,y)**：2D位移 **translate3d(x,y,z)**：3D位移 **translateX(x)**：X轴位移，等同于translate(x,0)或translate3d(x,0,0) **translateY(y)**：Y轴位移，等同于translate(0,y)或translate3d(0,y,0) **translateZ(z)**：Z轴位移，等同于translate3d(0,0,z) 描述 单位：Length长度，可用任何长度单位，允许负值 默认：XYZ轴不声明默认是0 正值：沿X轴向右位移/沿Y轴向上位移/沿Z轴向外位移 负值：沿X轴向左位移/沿Y轴向下位移/沿Z轴向内位移 scale()：缩放 **scale(x,y)**：2D缩放 **scale3d(x,y,z)**：3D缩放 **scaleX(x)**：X轴缩放，等同于scale(x,1)或scale3d(x,1,1) **scaleY(y)**：Y轴缩放，等同于scale(1,y)或scale3d(1,y,1) **scaleZ(z)**：Z轴缩放，等同于scale3d(1,1,z) 描述 单位：Number数值或Percentage百分比，允许负值 默认：XYZ轴不声明默认是1或100% 正值：0&lt;(x,y,z)&lt;1沿X轴缩小/沿Y轴缩小/沿Z轴变厚，(x,y,z)&gt;1沿X轴放大/沿Y轴放大/沿Z轴变薄 负值：-1&lt;(x,y,z)&lt;0翻转沿X轴缩小/沿Y轴缩小/沿Z轴变厚，(x,y,z)&lt;-1翻转沿X轴放大/沿Y轴放大/沿Z轴变薄 skew()：扭曲 **skew(x,y)**：2D扭曲 **skewX(x)**：X轴扭曲，等同于skew(x,0) **skewY(y)**：Y轴扭曲，等同于skew(0,y) 描述 单位：Angle角度或Turn周 默认：XY轴不声明默认是0 正值：沿X轴向左扭曲/沿Y轴向下扭曲 负值：沿X轴向右扭曲/沿Y轴向上扭曲 rotate()：旋转 **rotate()**：2D旋转 **rotate3d(x,y,z,a)**：3D旋转，[x,y,z]是一个向量，数值都是0~1 **rotateX(a)**：X轴旋转，等同于rotate(1,0,0,a)，正值时沿X轴向上逆时针旋转，负值时沿X轴向下顺时针旋转 **rotateY(a)**：3D Y轴旋转，等同于rotate(0,1,0,a)，正值时沿Y轴向右逆时针旋转，负值时沿Y轴向左顺时针旋转 **rotateZ(a)**：3D Z轴旋转，等同于rotate(0,0,1,a)，正值时沿Z轴顺时针旋转，负值时沿Z轴逆时针旋转 描述 单位：Angle角度或Turn周 正值：2D旋转时顺时针旋转 负值：2D旋转时逆时针旋转 matrix()：矩阵(太过复杂，可放弃) **matrix(a,b,c,d,e,f)**：2D矩阵(位移、缩放、扭曲、旋转的综合函数) **matrix(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)**：3D矩阵(位移、缩放、扭曲、旋转的综合函数) perspective()：视距 Length：长度，可用任何长度单位 值越小，用户与空间Z轴距离越近，视觉效果越强 值越大，用户与空间Z轴距离越远，视觉效果越弱 使用Transform默认会使浏览器开启GPU加速，因此性能更好 过渡Transition属性transition-property：属性 all：全部属性过渡(默认) none：无属性过渡 String：某个属性过渡 transition-duration：时间 Time：秒或毫秒(默认0) transition-timing-function：缓动函数 ease：逐渐变慢，等同于cubic-bezier(.25,.1,.25,1)(默认) linear：匀速，等同于cubic-bezier(0,0,1,1) ease-in：加速，等同于cubic-bezier(.42,0,1,1) ease-out：减速，等同于cubic-bezier(0,0,.58,1) ease-in-out：先加速后减速，等同于cubic-bezier(.42,0,.58,1) cubic-bezier：贝塞尔曲线，(x1,y1,x2,y2)四个值特定于曲线上的点P1和P2，所有值需在[0,1]区域内 transition-delay：时延 Time：秒或毫秒(默认0) 由于duration和delay的取值都是时间，所以可能会发生混淆。 duration和delay作用于所有节点，包括自身的::before和::after transition中出现两个时间值时，第一个解析为duration，第二个解析为delay transition中出现一个时间值时，解析为duration 贝塞尔曲线通过cubic-bezier()来设置一个贝塞尔曲线值。transform-timing-function的值都是预设好的贝塞尔曲线值。 CubicBezier上可以查看具体效果 动画Animation属性animation可声明的两种动画： 关键帧动画： 在时间轴的关键帧上绘制关键状态并使之有效过渡组成动画 通过@keyframe声明 逐帧动画： 在时间轴的每一帧上绘制不同内容并使之连续播放组成动画 准备一张逐帧长图，在steps()里声明逐帧长图及其展示方式 animation-name：名称 none：无动画(默认) String：动画名称 animation-duration：时间 Time：秒或毫秒(默认0) animation-timing-function：缓动函数 ease：逐渐变慢，等同于cubic-bezier(.25,.1,.25,1)(默认) linear：匀速，等同于cubic-bezier(0,0,1,1) ease-in：加速，等同于cubic-bezier(.42,0,1,1) ease-out：减速，等同于cubic-bezier(0,0,.58,1) ease-in-out：先加速后减速，等同于cubic-bezier(.42,0,.58,1) cubic-bezier：贝塞尔曲线，(x1,y1,x2,y2)四个值特定于曲线上的点P1和P2，所有值需在[0,1]区域内 steps([,[start|end]]?)：把动画平均划分成n等分，直到平均走完该动画 step-start：等同于steps(1,start)，把动画分成一步，动画执行时以左侧端点0%为开始 step-end：等同于steps(1,end)，把动画分成一步，动画执行时以右侧端点100%为开始 animation-delay：时延 Time：秒或毫秒(默认0) animation-iteration-count：播放次数 Number：数值(默认1) infinite：无限次 animation-direction：轮流反向播放(播放次数为一次则该属性无效果) normal：正常播放(默认) alternate：轮流反向播放，奇数次数正常播放，偶数次数反向播放 animation-play-state：播放状态 running：正在播放(默认) paused：暂停播放 animation-fill-mode：播放前后其效果是否可见 none：不改变默认行为(默认) backwards：在时延所指定时间内或在动画开始前应用开始属性(在第一个关键帧中定义) forwards：在动画结束后保持最后一个属性(在最后一个关键帧中定义) both：向前和向后填充模式都被应用 案例打字机1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class&#x3D;&quot;auto-typing&quot;&gt;Do You Want To Know More About CSS Development Skill&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;&#125;&lt;&#x2F;script&gt;&lt;style&gt;@mixin typing($count: 0, $duration: 0, $delay: 0) &#123; overflow: hidden; border-right: 1px solid transparent; width: #&#123;$count + 1&#125;ch; font-family: Consolas, Monaco, monospace; white-space: nowrap; animation: typing #&#123;$duration&#125;s steps($count + 1) #&#123;$delay&#125;s infinite backwards, caret 500ms steps(1) #&#123;$delay&#125;s infinite forwards;&#125;.auto-typing &#123; font-weight: bold; font-size: 30px; color: #09f; @include typing(52, 5);&#125;@keyframes caret &#123; 50% &#123; border-right-color: currentColor; &#125;&#125;@keyframes typing &#123; from &#123; width: 0; &#125;&#125;&lt;&#x2F;style&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://zxffan.github.io/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"https://zxffan.github.io/tags/css/"}]},{"title":"认识RPC","slug":"Server/认识RPC","date":"2020-10-23T16:00:00.000Z","updated":"2021-06-29T14:07:02.205Z","comments":true,"path":"posts/91c0fa71.html","link":"","permalink":"https://zxffan.github.io/posts/91c0fa71.html","excerpt":"","text":"RPC初识RPC（Remote Procedure Call）即远程过程调用。与Ajax类似。主要用于不同端之间的通信。 和Ajax的异同之处： 都是计算机之间网络通信的方式 Ajax是浏览器与服务端之间的通信方式 RPC是服务端之间的通信方式 都需要双方约定一个数据格式 Ajax约定格式为json RPC通常使用二进制 寻址方式 Ajax使用DNS进行寻址 RPC也需要寻址，可能根据ID或者一个VIP(虚拟IP)。使用DNS成本太高。 应用层协议 Ajax使用HTTP作为应用层协议 RPC通常使用二进制协议（基于TCP或UDP），传输二进制数据，这样体积小，编解码速度快（计算机本身就只能识别二进制）。 二进制编解码RPC通信传输的数据是二进制数据，而不是JSON数据。 在Nodejs中，内置了Buffer模块，它可以用来操作二进制数据 Buffer创建Buffer123456789101112// 1. 使用Buffer.from// 创建一个8字节 buffer二进制数据// 每个字符占 1个字节const buffer1 = Buffer.from(&#x27;helloRPC&#x27;); // 2. Buffer.from 的参数可以为数组// 每个数组元素 占1个字节const buffer2 = Buffer.from([1,2,3,4]);// 3. 使用Buffer.alloc// 创建一个20 字节的Bufferconst buffer3 = Buffer.alloc(20); 读写BufferBuffer内提供了众多读写Buffer方法，详情见nodejs文档-Buffer 1234567891011121314// 1. 读// 从offset开始，读一个带符号8位的整型buffer.readInt8(0) // 参数为offset，默认为0// 从offset开始，读一个32位的float// BE代表大端模式，LE代表小端模式buffer.readFloatBE(0)// 2. 写// 第一个参数是需要写入的值// 第二个参数是 offsetbuffer2.writeInt8(12, 1)buffer3.writeInt16BE(255, 2) 大端模式（big-endian, BE）和小端模式（little-endian, LE） 两者主要指存放字节的顺序不同，BE将高位放在低地址，LE将高位放在高地址 16位二进制: 0000 0010 1110 1100 使用 writeInt16BE(128, 0), 在偏移量位0的位置写入128(2进制是 1000 0000)。写入后 16位二进制：1000 0000 1110 1100（加黑为写入的） 如果使用writeInt16LE(128, 0)，在偏移量0的位置写入128(2进制是 1000 0000)。写入后 16位二进制：0000 1000 1110 1100（加黑为写入的） 可见两者写入顺序不同 小结在进行RPC通信时，需要创建Buffer对象，然后读写数据。 可是这种方式太复杂，远没有json方便。后者只需要通过JSON.stringify和JSON.parse进行序列化和反序列化即可。 Google提供了一个protocol buffers二进制编解码库，可以和使用json一样方便 Protocol BuffersProtocol Buffers是一个二进制编码库。本身提供了众多语言的实现，官方文档也介绍其是一个语言无关的库 所以可以在nodjs上使用它编码数据，在其它环境下（比如JAVA、Python）来使用它解码数据。 先安装npm install protocol-buffers 第一步需要编写proto文件，例如test.proto来约束二进制文件的格式。 12345message Column &#123; required int32 id &#x3D; 1; required string name &#x3D; 2; required float price &#x3D; 3&#125; 然后就可以导入使用 1234567891011const protobuf = require(&#x27;protocol-buffers&#x27;);const fs = require(&#x27;fs&#x27;)// 创建schemaconst schema = protobuf(fs.redFileSync(__dirname + &#x27;/test.proto&#x27;, &#x27;utf-8&#x27;));// 编码const buf = schema.Column.encode(&#123;id:1, name: &#x27;ff&#x27;, price: 99.9&#125;);// 解码const data = schema.Column.decode(buf) 搭建多路复用的RPC通道实现半双工通信原理通过使用ndoejs内置的net模块来搭建通信的双端。 nodejs内置的http模块也是基于net模块的。只是http模块用的是http协议。rpc并不用http协议。 半双工通信即同一时间只能有一个方向的数据传输。 编码数据mock 123456789101112131415161718// mock.jsconst data = &#123; 121391: &quot;第一课：北京故事&quot;, 121392: &quot;第二课：背影-朱自清&quot;, 121393: &quot;第三课：最后一课&quot;, 121394: &quot;第四课：春&quot;, 121395: &quot;第五课：济南的冬天&quot;,&#125;;exports.getDataById = function (id) &#123; return data[id];&#125;;exports.mockId = function () &#123; const index = Math.ceil(Math.random() * 4); return Object.keys(data)[index];&#125;; 服务端 监听数据，收到数据后，延时1s将结果返回。 12345678910111213141516171819// serverconst net = require(&quot;net&quot;);const &#123; getDataById &#125; = require(&quot;./mock.js&quot;);const server = net.createServer((socket) =&gt; &#123; socket.on(&quot;data&quot;, (buffer) =&gt; &#123; // 解析buffer，获取id const id = buffer.readInt32BE(); // 1秒后 返回数据 setTimeout(() =&gt; &#123; const data = getDataById(id); socket.write(Buffer.from(data)); &#125;, 1000); &#125;);&#125;);server.listen(4000); 客户端 先发送数据，当收到服务端处理结果后，输出结果并再次发送数据。 12345678910111213141516171819202122232425// clientconst net = require(&quot;net&quot;);const &#123; mockId &#125; = require(&quot;./mock.js&quot;);const socket = new net.Socket(&#123;&#125;);socket.connect(&#123; host: &quot;127.0.0.1&quot;, port: 4000,&#125;);function sendData() &#123; const id = mockId(); const buffer = Buffer.alloc(4); buffer.writeInt32BE(id); socket.write(buffer);&#125;socket.on(&quot;data&quot;, (buffer) =&gt; &#123; console.log(buffer.toString()); sendData();&#125;);sendData(); 实现全双工通信原理全双工通信即同一时刻，通信链路上可以有多个方向的数据传输。相比单双工通信会带来两个问题。 问题一：客户端同一时间发送两个数据包。服务端接收到的顺序与发送顺序不一致。因此服务端不知道数据包对应是哪次发送的。 解决：数据包增加一个首部，首部存放一个标识ID。从而识别数据包。 问题二：当客户端连续发送n的数据包，TCP底层会进行优化，将这些（二进制）数据包合并成一个，导致服务端以为只收到一个数据包。 解决：在数据包首部，再增加一个body长度标识，指明这个二进制数据的长度。收到数据后进行按照长度标识拆包。 由此，新的数据包结构如下： 编码mock.js内容不变 增加handler.js用于处理接受的数据和发送数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061module.exports = function (socket) &#123; let oldBuffer = null; let sequence = 0; function handleBuffer(buffer) &#123; const dataArray = []; if (oldBuffer) buffer = Buffer.concat([oldBuffer, buffer]); let completeLength = 0; while ((completeLength = checkComplete(buffer))) &#123; // package为一个数据包 const package = buffer.slice(0, completeLength); // 处理剩余的数据包 buffer = buffer.slice(completeLength); const header = package.slice(0, 6); const body = package.slice(6); const parsedData = &#123; sequence: header.readInt16BE(), data: body.toString(), &#125;; dataArray.push(parsedData); &#125; oldBuffer = buffer; return dataArray; // 检查buffer完整性 // 根据首部的范围标识来判断 function checkComplete(buffer) &#123; if (buffer.length &lt; 6) &#123; return 0; &#125; const bodyLength = buffer.readInt32BE(2); const packageLength = 6 + bodyLength; return buffer.length &lt; packageLength ? 0 : packageLength; &#125; &#125; function sendBuffer(data, seq) &#123; // 写入body const body = Buffer.from(data); // 写入首部 const header = Buffer.alloc(6); header.writeInt16BE(seq || sequence++); header.writeInt32BE(body.length, 2); // 拼接header和body const buffer = Buffer.concat([header, body]); socket.write(buffer); &#125; return &#123; handleBuffer, sendBuffer, &#125;;&#125;; 服务端server.js 12345678910111213141516171819202122232425// serverconst net = require(&quot;net&quot;);const &#123; getDataById &#125; = require(&quot;./mock.js&quot;);const createHandler = require(&quot;./handler.js&quot;);const server = net.createServer((socket) =&gt; &#123; const handler = createHandler(socket); socket.on(&quot;data&quot;, (buffer) =&gt; &#123; // 解析buffer，获取id const dataArray = handler.handleBuffer(buffer); dataArray.forEach((data) =&gt; &#123; console.log( `服务端收到数据：\\n\\tsequence:$&#123;data.sequence&#125;\\n\\tdata:$&#123;data.data&#125;` ); // 1秒后 返回数据 setTimeout(() =&gt; &#123; const responseData = getDataById(data.data); handler.sendBuffer(responseData); &#125;, 1000); &#125;); &#125;);&#125;);server.listen(4000); 客户端client.js 123456789101112131415161718192021222324252627282930// clientconst net = require(&quot;net&quot;);const &#123; mockId &#125; = require(&quot;./mock.js&quot;);const createHandler = require(&quot;./handler.js&quot;);const socket = new net.Socket(&#123;&#125;);socket.connect(&#123; host: &quot;127.0.0.1&quot;, port: 4000,&#125;);const handler = createHandler(socket);socket.on(&quot;data&quot;, (buffer) =&gt; &#123; const dataArray = handler.handleBuffer(buffer); dataArray.forEach((data) =&gt; &#123; console.log( `客户端收到数据：\\n\\tsequence:$&#123;data.sequence&#125;\\n\\tdata:$&#123;data.data&#125;` ); &#125;);&#125;);// 连续发送10个数据包for (let i = 0; i &lt; 10; i++) &#123; const id = mockId(); handler.sendBuffer(id);&#125; 例子过于简单，所以直接使用Buffer 实际使用推荐通过protocol buffers处理二进制数据","categories":[{"name":"Server","slug":"Server","permalink":"https://zxffan.github.io/categories/Server/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://zxffan.github.io/tags/Nodejs/"},{"name":"网络","slug":"网络","permalink":"https://zxffan.github.io/tags/%E7%BD%91%E7%BB%9C/"}]},{"title":"数组去重","slug":"Algorithm/数组去重","date":"2020-09-17T16:00:00.000Z","updated":"2021-06-29T14:03:50.077Z","comments":true,"path":"posts/d5def5e2.html","link":"","permalink":"https://zxffan.github.io/posts/d5def5e2.html","excerpt":"","text":"数组去重涉及到的场景还是比较多的，面试中也有很大频率被问到。 从数据结果角度来说：数组属于线性表。适合做查询，不适合增删。 去重的实现方案有很多，总的来说可分为原地去重和非原地去重两种 原地算法中的原地是指算法所需的辅助空间是常量，及空间复杂度O(1) 非原地算法非原地算法可能比较符合**不可变数据Immutable Data**数据的思想。也是比较推荐的风格。 用Set数据量不大的，用set即可。 123function unique(nums: number[]): number[] &#123; return Array.from(new Set(nums));&#125; 循环循环也是比较简单的 123456789101112function unique(nums: number[]): number[] &#123; let result: number[] = []; // 循环 nums.forEach((item) =&gt; &#123; // 没有就加入 if (result.indexOf(item) === -1) &#123; result.push(item); &#125; &#125;); return result;&#125; 使用高阶函数数组提供了一些高阶函数，filter、reduce等，可以用来实现去重。 使用reduce：原理和循环一样，就是用到了reduce这个api 123456function unique(nums: number[]): number[] &#123; return nums.reduce&lt;number[]&gt;((total, current) =&gt; &#123; if (total.indexOf(current) === -1) total.push(current); return total; &#125;, []);&#125; 使用filter： 123function unique(nums: number[]): number[] &#123; return nums.filter((item, index) =&gt; nums.indexOf(item) === index);&#125; 其他情况：数组元素是个对象这样的话，待比较的值就不是数组元素，而是数组元素（对象）的某个key： 题目：按照对象的id去重。 基于循环的例子： 123456789101112131415161718192021222324252627interface IElement &#123; id: number; name: string;&#125;function unique(nums: IElement[]): IElement[] &#123; let result: IElement[] = []; // 循环 nums.forEach((item) =&gt; &#123; // 没有就加入 if (result.every((r) =&gt; r.id !== item.id)) &#123; // ********这里不一样******** result.push(item); &#125; &#125;); return result;&#125;const arr = [ &#123; id: 1, name: &quot;aa&quot; &#125;, &#123; id: 1, name: &quot;bb&quot; &#125;, &#123; id: 2, name: &quot;cc&quot; &#125;, &#123; id: 3, name: &quot;dd&quot; &#125;,];console.log(unique(arr))// [ &#123; id: 1, name: &#x27;aa&#x27; &#125;, &#123; id: 2, name: &#x27;cc&#x27; &#125;, &#123; id: 3, name: &#x27;dd&#x27; &#125; ] 只是判断的方式变了，这里使用到了数组的every方法。 高阶函数reduce也同理，就是判断是否相同的方式变了。 filter的话也一样，这里使用到了findIndex方法 12345678function unique(nums: IElement[]): IElement[] &#123; return nums.filter((item, index) =&gt; &#123; // *******这里判断变了******** const firstIndex = nums.findIndex((n) =&gt; n.id === item.id); return firstIndex === index; &#125;);&#125; 以上方法本质上都一样，都是创建一个新的数组，并未对原数组做任何修改。 原地算法原地算法不需要额外的存储空间，直接修改原数组即可。 按两种情况分析：有序数组和无序数组 有序数组把原数组分成两个部分，一部分是结果数组（无重复的），另一部分是待遍历数组 初始状态下： 数组是有序的，每次遍历都判断一下j和i对应的值是否相等，如果不相等就将j对应的值插入结果数组中，反之则不做操作继续遍历。 最后再修改一下数组的长度。这种方法也叫做双指针法 12345678910111213141516171819function unique(nums: number[]): void &#123; let i = 0; // 遍历数组 for (let j = 1; j &lt; nums.length; j++) &#123; // 有序 if (nums[i] !== nums[j]) &#123; nums[++i] = nums[j]; &#125; &#125; // 修改数组长度 nums.length = i + 1;&#125;const arr = [1, 2, 2, 3, 4, 4, 5, 6, 6, 7];unique(arr);console.log(arr); 无序数组无序数组去重， 第一种思想：先排序，再用上面的方法 遍历+删除 123456789101112function unique(nums: number[]): void &#123; for (let i = 0; i &lt; nums.length; i++) &#123; const target = nums[i]; if (nums.indexOf(target) !== i) &#123; // 说明原数组 有不止一个当前元素 // 那就 删除当前元素（多余的） nums.splice(i, 1); i--; // 调整索引 &#125; &#125;&#125; 上面用到了splice这个方法，它也是基于原地算法。所以整个unique函数也是原地的。 其它情况：数组元素是个对象改一下比较对象就可以了。 基于无序数组的例子： 123456789101112131415161718192021222324252627interface IElement &#123; id: number; name: string;&#125;function unique(nums: IElement[]): void &#123; for (let i = 0; i &lt; nums.length; i++) &#123; const target = nums[i]; // ***********改一下判断规则*********** const firstIndex = nums.findIndex((n) =&gt; n.id === target.id); if (firstIndex !== i) &#123; nums.splice(i, 1); i--; &#125; &#125;&#125;const arr = [ &#123; id: 1, name: &quot;aa&quot; &#125;, &#123; id: 1, name: &quot;bb&quot; &#125;, &#123; id: 2, name: &quot;cc&quot; &#125;, &#123; id: 3, name: &quot;dd&quot; &#125;,];unique(arr);console.log(arr);","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/categories/Algorithm/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://zxffan.github.io/tags/TypeScript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/tags/Algorithm/"}]},{"title":"Rust学习笔记-Ownership","slug":"Rust/Rust笔记-Ownership","date":"2020-09-15T16:00:00.000Z","updated":"2021-06-29T14:06:45.077Z","comments":true,"path":"posts/2c967516.html","link":"","permalink":"https://zxffan.github.io/posts/2c967516.html","excerpt":"","text":"本系列文章是笔者学习Rust时所做的笔记，供日后翻阅复习。 Ownership?ownership（所有权）是一套用来高效管理内存的方案。 内存管理主要分为两种： GC(garbage collection)：如java、javascript，它们都有垃圾回收机制，会不停地检查是否存在不会被使用到的内存，然后释放它 手动方式：如C语言，需要开发者手动分配和释放内存。 Rust则是在编译时就能知道何时需要释放内存，而无需等到运行时，所以不会影响到程序的运行速度。 栈内存和堆内存栈内存： 按照获取值的顺序存储数据，按照相反的顺序删除值 栈内存存储的数据都是定长的 堆内存： 无组织的 存储数据时，内存分配器会找到一块足够存放的内存来存放，并将其标记为已使用，然后返回一个指针。指针是定长的并且存放在栈内存中 访问堆内存比访问栈内存更耗时。栈内存是相邻的，而访问堆内存需要在内存中跳跃 Ownership规则 Rust中的每一个值都有且仅有一个owner变量 owner离开其作用域时，该值会被删除 12345fn main() &#123; // 此处：s无法访问 let s = &quot;hello&quot;; // 此处：s可以访问&#125; // 此处：离开作用域，s无法访问 s是字符串字面量的owner，离开其作用域就无法访问 字符串与Ownership以字符串类型来说明Ownership。其它（存储在堆内存的）类型同理 声明一个字符串类型，可以使用字面量或者String 1234567fn main() &#123; let mut s = String::from(&quot;hello&quot;) s.push_str(&quot;, rust!&quot;); println!(&quot;&#123;&#125;&quot;, s);&#125; 区别：字符串字面量不可修改，String是可以被修改的 内存和分配对于字符串字面量，在编译时就已知其长度（并且不能改变） 而String类型，为了保持其可变性，需要满足两点： 在运行时请求内存分配：使用String::from就会在运行时来请求内存分配 当String使用完后，需要将内存返还给内存分配器（内存回收）：Rust是当变量离开其作用域时就会自动调用drop函数，来回收其内存。 Move12345fn main() &#123; let s1 = String::from(&quot;hello&quot;); let s2 = s1; // 此处：s2有效，s1无效&#125; 说明： String是存储在堆内存中的，s2 = s1只会复制栈内存的数据（含指针）而不会再拷贝一份堆内存数据 s2 = s1叫做s1的ownership移动(move)到了s2，则s1会无效即无法再访问。这么做的原因是防止变量离开作用域后对同一块堆内存回收两次。 Clone如果需要对堆内存进行深拷贝，就需要调用公共方法clone 12345fn main() &#123; let s1 = String::from(&quot;hello&quot;); let s2 = s1.clone(); // s1 s2都有效&#125; Copy前面所说的规则适用于堆内存的数据，而对于栈内存数据则不一样 12345fn main() &#123; let x = 5; let y = x; // x y 都有效&#125; 这是因为i32类型具有copy特性 具有copy特性的有： 所有整型 布尔类型 浮点类型 字符类型char 元组类型，前提：元组的成员都是具有copy特性的 函数与Ownership传参函数传参的场景涉及到了ownership的move 1234567891011121314151617fn main() &#123; let s = String::from(&quot;hello&quot;); takes_ownership(s); // s 无效，String发生move let x = 10; makes_copy(x); // x 依旧有效，x具有copy特性&#125; // x离开作用域 出栈；s离开作用域，由于已经无效了不会进行回收fn takes_ownership(some_string: String) &#123; println!(&quot;&#123;&#125;&quot;, some_string);&#125; // some_string离开作用域，进行回收fn makes_copy(some_integer: i32) &#123; println!(&quot;&#123;&#125;&quot;, some_integer);&#125; // some_integer离开作用域 出栈 内存回收(drop)针对堆内存，栈内存是出栈(pop off) 返回值和作用域函数的返回值也会转移ownership 12345678910111213141516171819202122fn main() &#123; let s1 = gives_ownership(); // gives_ownership将返回值move给s1 let s2 = String::from(&quot;hello&quot;); let s3 = takes_and_gives_back(s2); // s2 发生move // takes_and_gives_back将返回值move给s3&#125; // s3离开作用域，发生drop// s2离开作用域，但已经move了// s1离开作用域，发生dropfn gives_ownership() -&gt; String &#123; let some_string = String::from(&quot;hello&quot;); some_string // some_string move给调用函数&#125; // some_string，已经move了fn takes_and_gives_back(a_string: String) -&gt; String &#123; a_string // a_string move给调用函数&#125; // a_string 离开作用域，发生drop 由于ownership存在move，所以只有当函数将数据返回，我们才能再次使用。Rust支持多返回值，所以不会干扰其它返回值数据。 12345678910111213fn main() &#123; let s1 = String::from(&quot;hello&quot;); let (s2, len) = calculate_length(s1); println!(&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;, s2, len);&#125;fn calculate_length(s: String) -&gt; (String, usize) &#123; // 返回类型是一个元组 let length = s.len(); (s, length) // 多返回值&#125; ReferencesImmutable References在函数传参的场景下，由于ownership的存在，一旦ownership发生move。就无法在函数体之后的部分访问到该变量。 这是Rust故意设计的，但Rust又提供了另一种函数传参方式而不会发生move——引用(References) 1234567891011121314fn main() &#123; let s1 = String::from(&quot;hello&quot;); let len = calculate_length(&amp;s1); // 加个 &amp;号表示 创建一个Reference 指向s1 // s1 依旧有效&#125;// len 离开作用域，出栈// s1 离开作用域 dropfn calculate_length(s: &amp;String) -&gt; usize &#123; // 接受参数也是一个 Reference s.len()&#125;// s离开作用域，它是Reference 不会drop Reference不会获得原数据的ownership 上例中，我们称calculate_length函数租借(borrowing)s1 但是，calculate_length内部不能修改 s1，否则编译器会报错 Mutable References如果需要修改Reference，就可以使用&amp;mut s的形式声明一个Mutable References。 123456789fn main() &#123; let mut s = String::from(&quot;hello&quot;); change(&amp;mut s);&#125;fn change(some_string: &amp;mut String) &#123; some_string.push_str(&quot;, world&quot;);&#125; 但也是又限制的 同一作用域下，同一数据块只能有一个Mutable References，这是为了防止Data races 在使用Immutable Reference的同时，不能使用Mutable References Dangling References悬挂引用（空指针），看个例子 12345678910fn main() &#123; let reference_to_nothing = dangle();&#125;fn dangle() -&gt; &amp;String &#123; let s = String::from(&quot;hello&quot;); &amp;s&#125; // s离开作用域 drop// 函数返回 s的Reference，但s已经被drop。这个reference就是Dangling References Rust是不允许这种情况发生的，所以这样写会报错。 Slice字符串切片切片(slice)同样也不会发生ownership转移 12345678fn main() &#123; let s = String::from(&quot;hello world!&quot;); let s1 = &amp;s[0..3]; let s2 = &amp;s[3..12]; println!(&quot;&#123;&#125;-&#123;&#125;&quot;, s1, s2); // hel-lo world!&#125; &amp;s[0..3]会创建s中索引[0, 2]的Reference。 有几种可以省略值的写法： [0..2]和[..2]是等价的 [2..len]和[2..]等价，len为总长度 [0..len]和[..]等价 从数据结构角度看，String Slice会存储起始位置和长度： 写一个查找字符串首个单词 123456789101112131415161718fn main() &#123; let s = String::from(&quot;hello world!&quot;); let word = first_word(&amp;s); // &amp;s[..]也可以 println!(&quot;&#123;&#125;&quot;, word); // hello&#125;fn first_word(s: &amp;str) -&gt; &amp;str &#123; let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() &#123; if item == b&#x27; &#x27; &#123; return &amp;s[..i]; &#125; &#125; &amp;s[..]&#125; 字符串切片的类型是&amp;str，&amp;str类型能够兼容&amp;String和&amp;str 字符串字面量字符串字面量本身就是slice 1let s = &quot;Hello, World!&quot; s的类型就是&amp;str即一个字符串切片。&amp;str是一个Immutable Reference，所以字符串字面量不可变","categories":[{"name":"Rust","slug":"Rust","permalink":"https://zxffan.github.io/categories/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://zxffan.github.io/tags/Rust/"},{"name":"语言学习","slug":"语言学习","permalink":"https://zxffan.github.io/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"搞懂EventLoop","slug":"JavaScript/搞懂EventLoop","date":"2020-08-31T16:00:00.000Z","updated":"2021-06-29T14:05:14.840Z","comments":true,"path":"posts/d0699962.html","link":"","permalink":"https://zxffan.github.io/posts/d0699962.html","excerpt":"","text":"JavaScript&amp;单线程进程与线程进程是cpu分配资源的最小单位；线程是cpu调度的最小单位。一个进程可以包含多个线程。 cpu给进程分配资源，进程再创建线程去工作。实际干活的是线程。同一进程下的线程共享该进程的资源。 通常，进程之间是并行执行；线程之间是并发执行 浏览器的多进程模型以开源的Chromium浏览器为例，当打开浏览器就会创建一个主进程，每打开一个tab就会再创建一个子进程。这个子进程管理每个页面。而在这个子进程中又有若干线程，例如：UI线程、JS引擎线程、浏览器事件线程 、http请求线程、EventLoop轮询处理线程等。 JavaScript单线程上面提到的JS引擎线程就是运行JavaScript代码的那个线程。所以说JavaScript是单线程的，其实更加准确地说，应该是JavaScript的runtime是单线程的。 Why? 这是由JavaScript的用途决定的。JS最初是被设计成浏览器脚本语言 如果设计成多线程的话，多个线程同时访问或修改dom的话，就乱套了，这时必须引入锁了，这对脚本语言来说没有必要。 Web WorkerH5的Web Worker标准可以让主线程创建子线程，但它并未违背JavaScript设计初衷，应为它对子线程有很多限制： 子线程完全由主线程控制 子线程不能操作DOM 更多Web Worker信息，请查看阮一峰网络日志 同步任务和异步任务单线程的问题已经明确了javascript是一门单线程的语言。 但是单线程会面临一个问题： 我们的代码时一行一行地执行，当前面的没有执行完，后面地就需要等待。 如果程序中间有个请求接口代码块，那么当接口没有返回内容，后面地代码就需要一直等待。这时整个线程是卡死的。 这显然不行，JavaScript引入了同步任务和异步任务的概念来解决这个问题。 EventLoop 同步任务就是需要立即执行的任务，它没执行完后面的需要等待 异步任务就是不需要立即执行的任务，比如ajax接口请求、setTimeout等。如果是异步任务就会在Event Table中注册，当指定的事件完成之后（例如接口返回响应了），就将其回调函数放到Event Queue中 当主线程内的同步任务全部执行完毕后，会去读Event Queue中的函数，放入主线程执行。 上述过程会一直重复执行，而这个过程被称为Event Loop。 宏任务和微任务同步任务和异步任务是广义上的划分。而宏任务(macro task)和微任务(micro task)是更为精细的划分 划分宏任务： # 浏览器 Node main script ✅ ✅ I/O ✅ ✅ setTimeout ✅ ✅ setInterval ✅ ✅ setImmediate ❌ ✅ requestAnimationFrame ✅ ❌ 微任务： # 浏览器 Node process.nextTick ❌ ✅ MutationObserver ✅ ❌ Promise.then catch finally ✅ ✅ 微任务是属于宏任务的，换句话说，一个宏任务可以包含多个微任务 执行流程以浏览器为例，由两个任务队列，宏任务队列存放宏任务；微任务队列存放微任务 main script也就是script标签里的代码是第一个宏任务。存放至宏任务队列 当第一次Event Loop时，检查两个队列，首先检查微任务队列（微任务的优先级比宏任务高）发现没有任务；再去检查宏任务队列，发现有任务main script取出执行。 main script里有可能又有宏任务和微任务，再分别放入相应队列。 几个APIsetImmediate这个API是nodejs独有的，表示在一次Event Loop执行完毕后调用 process.nextTick这个API也是nodejs独有的，他会将注册的回调函数插入当前微任务队列的队首。 1234567process.nextTick(() =&gt; console.log(1));Promise.resolve().then(() =&gt; console.log(2));process.nextTick(() =&gt; console.log(3));Promise.resolve().then(() =&gt; console.log(4));console.log(5);// output: 5 1 3 2 4 Promisepromise是es2015新增的API。提供了强大的异步特性。 promise的executor是一个同步函数会立即执行，then中的回调会被注册为微任务 123456789new Promise((resolve, reject) =&gt; &#123; console.log(1); resolve();&#125;).then(() =&gt; &#123; console.log(3)&#125;)console.log(2)// output: 1 2 3 async/awaitasync/await仅仅影响的是函数内的执行，而不会影响到函数体外的执行顺序。 123456789101112131415161718192021222324async function async1() &#123; console.log(&quot;async1 start&quot;); await async2(); console.log(&quot;async1 end&quot;);&#125;async function async2() &#123; console.log(&#x27;async2&#x27;);&#125;console.log(&quot;script start&quot;);setTimeout(function () &#123; console.log(&quot;settimeout&quot;);&#125;,0);async1();// output: // script start// async1 start// async2// async1 end// settimeout await async2()相当于执行一个Promise，console.log(&#39;async2&#39;);属于executor；awaait后面的内容相当于then，会被放入微任务队列。 综合试题在网上找到这么一道综合题： 123456789101112131415161718192021222324252627async function async1() &#123; console.log(&quot;async1 start&quot;); await async2(); console.log(&quot;async1 end&quot;); // async1 end&#125;async function async2() &#123; console.log(&#x27;async2&#x27;);&#125;console.log(&quot;script start&quot;);setTimeout(function () &#123; // setTimeout1 console.log(&quot;settimeout&quot;);&#125;);async1()new Promise(function (resolve) &#123; console.log(&quot;promise1&quot;); resolve();&#125;).then(function () &#123; // promise then console.log(&quot;promise2&quot;);&#125;);setImmediate(()=&gt;&#123; // setImmediate console.log(&quot;setImmediate&quot;)&#125;)process.nextTick(()=&gt;&#123; // nextTick console.log(&quot;process&quot;)&#125;)console.log(&#x27;script end&#x27;); 分析： 输出script start，setTimeout1放入宏任务队列 宏任务队列：[setTimeout1] 微任务队列：[] 执行async1，输出async1 start，执行async2，输出async2;将async1 end放入微任务队列 宏任务队列：[setTimeout1] 微任务队列：[async1 end] 执行Promise的executor，输出promise1；将promise then放入微任务队列 宏任务队列：[setTimeout1] 微任务队列：[async1 end, promise then] 遇到setImmediate，将setImmediate放入宏任务队列 宏任务队列：[setTimeout1， setImmediate] 微任务队列：[async1 end, promise then] 遇到process.nextTick，将nextTick放入微任务队列队首 宏任务队列：[setImmediate, setTimeout1] 微任务队列：[nextTick ,async1 end, promise then] 输出script end 先依次取出微任务队列的任务执行，输出：process、async1 end、promise2 然后依次取出所有宏任务执行，输出：settimeout、setImmediate 异步是怎么实现的根据上文可以了解到。在浏览器中，通过线程切换来实现异步。 nodejs也是类似。它依赖于libuv模块。libuv通过线程池来实现异步操作","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"nodejs","slug":"nodejs","permalink":"https://zxffan.github.io/tags/nodejs/"},{"name":"browser","slug":"browser","permalink":"https://zxffan.github.io/tags/browser/"}]},{"title":"Webpack-问题梳理","slug":"engineering/Webpack-问题梳理","date":"2020-08-26T16:00:00.000Z","updated":"2021-06-29T13:42:26.037Z","comments":true,"path":"posts/378e5729.html","link":"","permalink":"https://zxffan.github.io/posts/378e5729.html","excerpt":"","text":"Webpack与其它构建工具有何不同？与Gulp和Grunt Gulp和Grunt打包的思路是： 遍历源文件→匹配规则→打包 （打包的文件指定的），webpack是按照模块的依赖关系进行打包 webpack解决了模块化的问题，而Gulp和Grunt没有 与rollup rollup最先提出tree shaking，webpack也已经支持 rollup不支持code split和dynamic import 经验法则：库使用rollup构建，应用使用webpack构建 Webpack 的有几种使用方法？通过webpack-cli和npm script，123456&#123; &quot;script&quot;: &#123; &quot;dev&quot;: &quot;webpack --mode development ./src/es/index.js --module-bind js=babel-loader&quot;, &quot;build&quot;: &quot;webpack --mode production ./src/es/index.js --module-bind js=babel-loader&quot; &#125;&#125; 编程式调用12345const &#123; webpack &#125; = require(&#x27;webpack&#x27;)const config = getWebpackConfig() // 生成配置文件const compiler = webpack(config)compiler.run() Webpack配置文件有几种写法webpack不仅支持javascript还支持Typescript、CoffeeScript 函数123456789module.exports = (env, argv) =&gt; &#123; return &#123; // 必须返回一个对象 entry: &#123; main: &#x27;./src/index.js&#x27; &#125;, mode: env.production ? &#x27;production&#x27; : &#x27;development&#x27;, plugins: [] &#125;&#125; env和argv两个参数对应这webpack-cli选项 适用场景： 需要通过一个配置文件来区分生产环境（production）和开发环境（development）， Promise12345678910module.exports = () =&gt; &#123; return new Primise((resolve, reject) =&gt; &#123; // 处理操作 setTimeout(() =&gt; &#123; resolve(&#123; entry: &#x27;./src/index.js&#x27;, &#125;) &#125;) &#125;)&#125; 适用场景：需要异步加载一些 Webpack 配置需要做的变量 数组123456789101112131415module.exports = [&#123; output: &#123; filename: &#x27;./dist-amd.js&#x27;, libraryTarget: &#x27;amd&#x27; &#125;, entry: &#x27;./app.js&#x27;, mode: &#x27;production&#x27;, &#125;, &#123; output: &#123; filename: &#x27;./dist-commonjs.js&#x27;, libraryTarget: &#x27;commonjs&#x27; &#125;, entry: &#x27;./app.js&#x27;, mode: &#x27;production&#x27;, &#125;] 数组中的每个元素为一个配置对象，所有的配置对象都会构建。 适用场景：打包库，既想打包成AMD 又想 打包成 CommonJS 单个配置对象最常用 如何指定库打包出来的规范？output.library可以指定库打包出来的名称，支持占位符如[name] output.libraryTarget可以指定库打包出来的规范，取值范围为：var、assign、this、window、global、commonjs、commonjs2、commonjs-module、amd、umd、umd2、jsonp，默认是var Webpack能够构建出哪些程序？target：可以指定构建目标，取值有以下几种： web： 默认，编译为类浏览器环境里可用； node：编译为类 Node.js 环境可用（使用 Node.js require 加载 chunk）； async-node：编译为类 Node.js 环境可用（使用 fs 和 vm 异步加载分块）； electron-main：编译为 Electron 主进程； electron-renderer：编译为 Electron 渲染进程； node-webkit：编译为 Webkit 可用，并且使用 jsonp 去加载分块。支持 Node.js 内置模块和 nw.gui 导入（实验特性）； webworker：编译成一个 WebWorker。 Webpack有几种hash？有什么区别？ [hash]：是整个项目 整个项目的 hash 值，其根据每次编译内容计算得到，每次编译之后都会生成新的 hash，即修改任 何文件都会导致所有文件的 hash 发生改变；在一个项目中虽然入口不同，但是 hash 是相同的；hash 无法实现 前端静态资源在浏览器上长缓存，这时候应该使用 chunkhash； [chunkhash]：根据不同的入口文件（entry）进行依赖文件解析，构建对应的 chunk，生成相应的 hash；只要组成 entry 的模块文件没有变化，则对应的 hash 也是不变的，所以一般项目优化时，会将公共库代码拆分到一 起，因为公共库代码变动较少的，使用 chunkhash 可以发挥最长缓存的作用； [contenthash]：使用 chunkhash 存在一个问题，当在一个 JS 文件中引入了 CSS 文件，编译后它们的 hash 是 相同的。而且，只要 JS 文件内容发生改变，与其关联的 CSS 文件 hash 也会改变，针对这种情况，可以把 CSS 从 JS 中使用mini-css-extract-plugin 或 extract-text-webpack-plugin抽离出来并使用 contenthash。 Webpack支持几种SourceMap？devtool：用来配置sourceMap，取值如下 devtool 构建速度 重新构建速度 生产环境 品质(quality) 留空，none +++ +++ yes 打包后的代码 eval +++ +++ no 生成后的代码 cheap-eval-source-map + ++ no 转换过的代码（仅限行） cheap-module-eval-source-map o ++ no 原始源代码（仅限行） eval-source-map – + no 原始源代码 cheap-source-map + o no 转换过的代码（仅限行） cheap-module-source-map o - no 原始源代码（仅限行） inline-cheap-source-map + o no 转换过的代码（仅限行） inline-cheap-module-source-map o - no 原始源代码（仅限行） source-map – – yes 原始源代码 inline-source-map – – no 原始源代码 hidden-source-map – – yes 原始源代码 nosources-source-map – – yes 无源代码内容 参数 参数解释 eval 打包后的模块都使用 eval() 执行，行映射可能不准；不产生独立的 map 文件 cheap map 映射只显示行不显示列，忽略源自 loader 的 source map inline 映射文件以 base64 格式编码，加在 bundle 文件最后，不产生独立的 map 文件 module 增加对 loader source map 和第三方模块的映射 一般在实际项目中，推荐生产环境不使用或者使用source-map （如果有 Sentry 这类错误跟踪系这类错误跟踪系统），开发环境使用 cheap-module-eval-source-map 解释一下bundle、chunk和modulemodule: 开发中每一个文件都可以看做 module，模块不局限于 js，也包含 css、图片等 chunk: 代码块，一个 chunk 可以由多个模块组成 bundle: 最终打包完成的文件，一般就是和 chunk 一一对应的关系，bundle 就是对 chunk 进行压缩打包等处理后的产出 Webpack中loader如何使用？以及loader的执行顺序如何使用 在配置文件中配置 内联配置方式const html = require(&#39;html-loader!./loader.html&#39;); 或者import html from &#39;html-loader!./loader.html&#39;; 执行顺序从右到左，从下到上 Webpack如何实现按需加载？什么是魔法注释？webpack中通过import函数实现按需加载，也被称为动态导入(dynamic import)， 该函数返回Promise 导入的文件被打包到单独的文件中，具体得看splitChunk配置 魔法注释： webpackInclude：如果是 import 的一个目录，则可以指定需要引入的文件特性，例如只加载 json 文件：/\\.json$/ webpackExclude：如果是 import 的一个目录，则可以指定需要过滤的文件，例如 /\\.noimport\\.json$/； webpackChunkName：这是 chunk 文件的名称，例如 lazy-name； webpackPrefetch: 是否预取模块，及其优先级，可选值true、或者整数优先级别，0 相当于 true，webpack 4.6+支持； webpackPreload 是否预加载模块，及其优先级，可选值true、或者整数优先级别，0 相当于 true，webpack 4.6+支持； webpackMode: 可选值lazy/lazy-once/eager/weak。 1import(/* webpackChunkName: &quot;image&quot;, webpackInclude: /\\.(png|jpg|gif)/ */ &#x27;./assets/img&#x27;); Babel的最佳实践@babel/preset-env搭配useBuiltIns: &quot;usage&quot;实现真正的按需加载。需要转换的地方会自动转换 123456789101112131415161718192021// babel.config.jsmodule.exports = function(api) &#123; api.cache(true) const presets = [ [ &#x27;@babel/preset-env&#x27;, &#123; modules: false, corejs: 3, // 指定corejs 的版本 useBuiltIns: &#x27;usage&#x27;, &#125;, ], ] const plugins = [] return &#123; presets, plugins, &#125;&#125; moudles指定将ES module 转换成其它模块规范，可能取值有 &quot;amd&quot; | &quot;umd&quot; | &quot;systemjs&quot; | &quot;commonjs&quot; | &quot;cjs&quot; | &quot;auto&quot; | false；false表示不去转换 强烈建议false，否则会影响Webpack进行优化（Tree Shaking必须基于ES moudle） Babel原理Babel的语法转换过程主要经历三个步骤： 解析（Parse）：对JavaScrpt代码解析词法语法分析，最终生成一个AST。用的是@babel/parser 转换（Transform）：对AST进行遍历，在这过程中可以进行添加、删除和修改等操作。用的是@babel/traverse 生成（Generate）：转换后得到一棵新树，然后将树转换成代码，用的是@babel/generator 如何编写一个Babel插件Babel在转换阶段会遍历AST，那么Babel插件就是在这个过程中编写visitor 12345678910// babel plugin demoexport default function(&#123; types: t &#125;) &#123; return &#123; visitor: &#123; Identifier(path, state) &#123;&#125;, FunctionDeclaration(path, state) &#123;&#125;, BinaryExpression(path, state) &#123;&#125;, &#125; &#125;;&#125;; type 字段表示遍历时每个节点的类型（如： &quot;FunctionDeclaration&quot;，&quot;Identifier&quot;，或 &quot;BinaryExpression&quot;） 遍历过程中每当在树中遇见一个 Identifier 的时候会调用 Identifier() 方法。 Identifier(path, state) &#123;&#125;代表进入节点时触发 12345678910export default function(&#123; types: t &#125;) &#123; return &#123; visitor: &#123; Identifier: &#123; enter(path, state) &#123;&#125;, exit(path, state) &#123;&#125;, // 退出时触发 &#125;, &#125; &#125;;&#125;; 关于Babel插件详细写法，请查阅文档 编写Babel插件需要熟悉AST结构，可以借助AST Exploer来学习AST Babel如何针对不同浏览器做适配Browserslist用来指定适配的浏览器的工具，Babel和Postcss等工具都会使用Browserlist。 在项目根目录创建.browserslistrc文件，写入以下内容 1234last 2 version&gt; 1%not ie &lt;= 11not dead 可以在browserl.ist上检查所支持的浏览器列表 Webpack中如何增强CSS功能CSS Modulecss都是全局的，也就是说一个文件的样式可能被另一个文件的css样式污染。以前常用解决方法就是采用BEM规范，但是规范总会有人不遵守。css module能很好解决这个问题。 css module顾名思义，就是给让css模块化。主要解决问题有： 解决 CSS 类都是全局的，容易造成全局污染（样式冲突） JS 和 CSS 共享类名，即JS 可以直接使用 CSS 的类名作为对象值 可以方便的编写出更加健壮和扩展方便的 CSS。 123456// reactimport style from &#x27;./style.css&#x27;export function Home() &#123; return &lt;div style=&#123;style.box&#125;&gt;Hello&lt;/div&gt;&#125; 123456789101112131415&lt;!-- vue --&gt;&lt;template&gt; &lt;p :class&#x3D;&quot;$style.red&quot;&gt; This should be red &lt;&#x2F;p&gt;&lt;&#x2F;template&gt;&lt;style module&gt;.red &#123; color: red;&#125;.bold &#123; font-weight: bold;&#125;&lt;&#x2F;style&gt; 开启方法：css-loader 增加 modules: true 的选项 123456789101112131415161718module.exports = &#123; //... module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &#123; loader: &#x27;css-loader&#x27;, options: &#123; modules: true &#125; &#125; ] &#125; ] &#125;&#125; CSS预处理器css预处理器就是在css本身的基础上，增强了语法。增加了循环、条件判断、运算、函数以及作用域等 常见的css预处理器有：sass(scss)、less、stylus PostCSSPostcss是一个类似Babel的工具，只不过Postcss处理的是css文件。 Postcss 核心是将 CSS 解析成 AST，然 后通过各种插件做各种转换，最终生成处理后的新 CSS，跟 Babel 在功能和实现上都类似。 在Webpack中使用需要安装postcss-loader 配置方法：在项目根目录新建一个postcss.config.js文件，写入配置内容，如下 12345678910const postcssPresetEnv = require(&#x27;postcss-preset-env&#x27;)const postcssImport = require(&#x27;postcss-import&#x27;)module.exports = &#123; plugins: [ postcssPresetEnv(&#123; autoprefixer: &#123; grid: true &#125;&#125;), postcssImport() ],&#125; postcss和babel一样都有自己的插件系统。 postcss-preset-env是postcss常用的插件集合，具体特性请查阅文档 postcss-import是让postcss规则作用的@import的CSS文件。 常用的还有一个postcss-px-to-viewport插件，用来将px转成vw，在移动端上比较常用。 Webpack如何打包多页面？Wepack实现多页面打包需要通过html-webpack-plugin来实现 1234567891011121314151617181920const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; entry: &#123; index: &#x27;./src/main.js&#x27;, post: &#x27;./src/post.js&#x27; &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &#x27;./public/index.html&#x27;, filename: &#x27;index.html&#x27;, chunks: [&#x27;index&#x27;] &#125;), new HtmlWebpackPlugin(&#123; template: &#x27;./public/post.html&#x27;, filename: &#x27;post.html&#x27;, chunks: [&#x27;post&#x27;] &#125;), ]&#125; 注意: 需要打包几个页面就增加几个HtmlWebpackPlugin实例 chunks指定当前页面包含那些chunk 还可以使用excludeChunks来排除不需要的chunk 使用webpack-dev-server时，通过http://ip:port/index访问`index`页面；通过http://ip:port/index/post访问`post`页面 解释一下webpack-dev-server的原理 webpack-dev-server是一个基于express的本地服务器。 它通过webpack-dev-middleware中间件来为webpack打包生成的资源文件提供web服务。 同时还将开启一个websocket连接来实现热更新。 webpack-dev-server的最佳实践热更新 配置devServer.hot为true；配置devServer.inline为true（默认）。这会在entry中添加相应代码 增加webpack.HotModuleReplacementPlugin这个plugin 如果使用webpack-cli，直接加上--hot就自动实现上面两步 proxydevServer.proxy可以实现本地跨域问题 12345678910module.exports = &#123; devServer: &#123; proxy: &#123; &#x27;/api&#x27;: &#123; target: &#x27;http://ip:port&#x27;, // 所有请求路径包含/api的请求，都会被转发到这个地址 pathRewrite: &#123;&#x27;^/api&#x27;, &#x27;&#x27;&#125; &#125; &#125; &#125;&#125; 自定义中间件在 webpack-dev-server 中有两个时机可以插入自己实现的中间件，分别是 devServer.before 和 devServer.after ，即webpack-dev-server加载所有内部中间件之前和之后两个时机。通常用来实现mockServer 123456789module.exports = &#123; devServer: &#123; before(app, server) &#123; app.get(&#x27;/api/get-use-info&#x27;, (req, res) =&gt; &#123; res.json(&#123;name: &#x27;zxffan&#x27;, gender: &#x27;male&#x27;&#125;) &#125;) &#125; &#125;&#125; Gzip将devServer.compress设置成true 常用API devServer.historyApiFallback：配置如果找不到页面就默认显示的页面； devServer.compress：启用 gzip 压缩； devServer.hotOnly：启用热更新，并且构建失败的时候不会刷新网页； devServer.inline：模式切换，默认为内联模式，使用false切换到 iframe 模式； devServer.open：启动后，是否自动使用浏览器打开首页； devServer.openPage：启动后，自动使用浏览器打开指定的页面； devServer.overlay：是否允许使用全屏覆盖的方式显示编译错误，默认不允许； devServer.port：监听端口号，默认 8080； devServer.host：指定 host，使用0.0.0.0可以让局域网内可访问； devServer.contentBase：告诉服务器从哪里提供内容，只有在你想要提供静态文件时才需要； devServer.publicPath：设置内存中的打包文件的虚拟路径映射，区别于output.publicPath； devServer.staticOptions：为 Expressjs 的 express.static配置参数，参考文档 devServer.clientLogLevel：在 inline 模式下用于控制在浏览器中打印的 log 级别，如error, warning, info or none； devServer.quiet：静默模式，设置为true则不在控制台输出 log； devServer.noInfo：不输出启动 log； devServer.lazy: 不监听文件变化，而是当请求来的时候再重新编译； devServer.watchOptions：watch 相关配置，可以用于控制间隔多少秒检测文件的变化； devServer.headers：自定义请求头，例如自定义 userAgent 等； devServer.https：https 需要的证书签名等配置。 Webpack优化——如何减小打包后的文件体积打包后的文件主要分为三类——js、css和其它静态资源文件（图片等） 如何减小JS文件体积 压缩代码：使用terser-webpack-plugin对es moudule的代码进行压缩 tree shaking，代码需要遵循es module 合理设置splitChunk拆分逻辑 第三方库按需引入 使用scope hoisting webpack的mode设置为production时，webpack就会自动做一些通用的优化配置 配置如下 1234567891011121314151617181920212223242526272829const TerserWebpackPluin = require(&#x27;terser-webpack-plugin&#x27;)module.exports = &#123; // ... mode: &#x27;production&#x27;, optimization: &#123; concatenateModules: true, // 开启 scope hoisting(mode为production会自动开启) minimize: true, minimizer: [ new TerserWebpackPluin(&#123; test: /\\.js(\\?.*)?$/i, include: /src/, //exclude cache: true, // 开启缓存 parallel: true, // 默认true 开启多线程 terserOptions: &#123; compress: &#123; unused: true, // 删除无用的代码 drop_debugger: true, // 删掉 debugger drop_console: true, // 移除 console dead_code: true, // 移除无用的代码 &#125; &#125; &#125;) ] &#125;&#125; 如何减小CSS文件体积 压缩代码：使用cssnao(postcss 插件)来进行代码压缩，其实css-loader已经集成了cssnano 抽离CSS：通过mini-css-extract-plugin将CSS内容抽离到CSS文件中 配置内容如下 12345678910111213141516171819202122232425262728const MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)module.exports = &#123; // ... module: &#123; rules: [ &#123; test: /\\.css$/, use: [ &#x27;style-loader&#x27;, MiniCssExtractPlugin.loader, &#123; loader: &#x27;css-loader&#x27;, options: &#123; minimize: &#123;/* CSSNano Options */&#125; &#125; &#125; ] &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: &#x27;[name].css&#x27;, &#125;) ]&#125; 如何处理图片等静态资源 url-loader可以将小图片转成Data URL内联到JS中，从而减少请求数量 对于svg，使用svg-url-loader 1234567891011121314151617module.exports = &#123; module: &#123; rules: [ &#123; test: /\\.(png|jpg|jpeg)$/, use: [ &#123; loader: &#x27;url-loader&#x27;, options: &#123; limit: 100, //单位kb，小于这个大小的会被转成Data URL &#125; &#125; ] &#125; ] &#125;&#125; Webpack优化——如何利用缓存主要思路就是，将项目中不太容易变化的代码（比如第三方库vue、react）单独抽离出来，利用CDN或配置浏览器缓存以减少对其的请求。 如何拆分出来（Code Splitting） 配置多个entry 使用dynamic import和split chunk来拆分代码 使用external不打包这些一些第三方库，然后通过cdn引入 特别说一下split chunk，以下时默认配置 1234567891011121314151617181920212223242526272829module.exports = &#123; // ... optimization: &#123; splitChunks: &#123; chunks: &#x27;async&#x27;, // 三选一： &quot;initial&quot; | &quot;all&quot; | &quot;async&quot; (默认) minSize: 30000, // 最小尺寸，30K，development 下是10k，越大那么单个文件越大，chunk 数就会变少（针对于提取公共 chunk 的时候，不管再大也不会把动态加载的模块合并到初始化模块中）当这个值很大的时候就不会做公共部分的抽取了 maxSize: 0, // 文件的最大尺寸，0为不限制，优先级：maxInitialRequest/maxAsyncRequests &lt; maxSize &lt; minSize minChunks: 1, // 默认1，被提取的一个模块至少需要在几个 chunk 中被引用，这个值越大，抽取出来的文件就越小 maxAsyncRequests: 5, // 在做一次按需加载的时候最多有多少个异步请求，为 1 的时候就不会抽取公共 chunk 了 maxInitialRequests: 3, // 针对一个 entry 做初始化模块分隔的时候的最大文件数，优先级高于 cacheGroup，所以为 1 的时候就不会抽取 initial common 了 automaticNameDelimiter: &#x27;~&#x27;, // 打包文件名分隔符 name: true, // 拆分出来文件的名字，默认为 true，表示自动生成文件名，如果设置为固定的字符串那么所有的 chunk 都会被合并成一个 cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, // 正则规则，如果符合就提取 chunk， test(module, chunks) &#123; // 还可以是函数 return module.type === &#x27;javascrtipt/auto&#x27; &#125;, priority: -10 // 缓存组优先级，当一个模块可能属于多个 chunkGroup，这里是优先级 &#125;, default: &#123; minChunks: 2, priority: -20, // 权重，如果有一个模块满足了多个缓存组的条件就会去按照权重划分，谁的权重高就 优先按照谁的规则处理。 reuseExistingChunk: true // 如果该chunk包含的modules都已经另一个被分割的chunk中存在，那么直接引用已存在的chunk，不会再重新产生一个 &#125; &#125; &#125; &#125;&#125;; chunks有三个值initial、all和async(默认) chunks为async：只有dynamic import才会被拆分出去 chunks为initial：dynamic import肯定会被拆分出去，符合cacheGroup规则并且体积大于minSize也会被拆分出去（无论是否dynamic import）;但是非动态导入和动态导入的公共部分没有拆分在一起，而在单独拆分成不同的chunk chunks为all（推荐）：非动态导入和动态导入的公共部分会拆分在一起（符合cacheGroup规则） cacheGroup(缓存组)配置了拆分逻辑。 如何设置缓存CDN没什么好说的，直接再HTML中引入即可。 对于浏览器缓存，当浏览器请求这些资源时，服务端设置Cache-Control响应头，比如Cache-Control: max-age=31536000，表示当前资源缓存一年（31536000=360024365）。只要一年内该资源不发生变化就会一直从缓存中读取。 Webpack优化——如何加快打包速度 配置路径别名——resolve.alias，以减少目录查找次数 增加默认文件后缀名——resolve.extensions 排除不需要解析的模块 module.noParse，例如noParse: /node_modules\\/jquery.js/。忽略对部分没采用模块化的文件递归解析处理，例如：jQuery、 ChartJS，它们体积庞大又没有采用模块化标准，让 Webpack 去解析这些文件耗时又没有意义 module.rules中配置合适的include和exclude。 利用多线程：thread-loader和happypack(已经不维护了) webpack的DllPlugin和DllReferencePlugin，将一些不会变化的内容抽离出来，并且避免二次打包。 缓存Cache：很多loader都提供了缓存机制 babel-loader：设置cacheDirectory:true将会开启缓存 换用高性能的loader或插件 sass：使用fast-sass-loader代替sass-loader 重点说一下DllPlugin和DllReferencePlugin： DllPlugin可以将第三方库单独打包到一个bundle中，还会生成一个manifest.json文件 DllReferencPlugin读取这个manifest.json文件，在打包过程中就不会将之前抽离内容打包进来 123456789101112131415161718192021222324// webpack.config.dll.jsconst &#123; DllPlugin &#125; = require(&#x27;webpack&#x27;)module.exports = &#123; // ... mode: &#x27;production&#x27;, entry: &#123; vendor: [&#x27;vue&#x27;, &#x27;vue-router&#x27;, &#x27;vuex&#x27;] // 将这些第三方库抽离出来 &#125;, output: &#123; filename: &#x27;dll/[name][chunkhash].js&#x27;, library: &#x27;[name][chunkhash]&#x27;, path: &#x27;./dist&#x27; &#125;, plugins: [ new DllPlugin(&#123; path: &#x27;dll/manifest.json&#x27;, // 设置manifest.json的路径 name: &#x27;[name]_[chunkhash]&#x27;, context: __dirname &#125;) ]&#125; 使用webpack.config.dll.js打包一次，将vue、vuex和vue-router打包出来。生成vender[hash].js和manifest.json 然后配置webpack.config.js 1234567891011121314151617const &#123; DllReferencePlugin &#125; = require(&#x27;webpack&#x27;)const manifest = require(&#x27;./dll/manifest.json&#x27;)module.exports = &#123; entry: &#123; main: &#x27;./src/index.js&#x27; &#125;, output: &#123; filename: &#x27;[name][chunkhash].js&#x27; &#125;, plugin: [ new DllReferencePlugin(&#123; context: __dirname manifest // 配置manifest &#125;) ]&#125; 打包最后生成的main.js中不会包含vendor里的内容。 webpack5提出了federal module（联邦模块）；也可以提取公共模块 解释一下Webpack中Tree-shaking原理？基于ES module做静态分析，在编译阶段就能分析出其模块依赖关系（无需等到运行时）。然后利用uglifyjs或terser-webpack-plugin来删除多余内容 tree shaking的注意点： 必须使用es module规范 不支持对class的tree shaking 减少副作用，具有副作用的代码不会被消除 纯函数：对于相同的输入就有相同的输出，不依赖外部环境，也不改变外部环境。 非纯函数被称为具有副作用的函数 确保代码中没有副作用 在package.json中配置sideEffects: [&quot;./src/side_effect.js&quot;](指定具有副作用的内容)或者sideEffects:false（完全没有副作用），这样webpack就会跳过副作用的代码 Checklist配置文件管理npm script配置脚本命令，例如node ./scripts/dev.js 使用编程式API，而不采用webpack-cli（个人习惯） 拆分配置文件：开发环境，生产环境等 scripts目录下有一个config目录用来存放各个环境的配置文件 合理的拆分合理设置splitchunks、DDLPlugin或Federal Module，太细不利于缓存，太粗又会影响加载速度。， 拆分原则： 变更频率小的部分拆分出来（例如第三方库） 公共部分拆分出来 按照路由拆分 Hash JavaScript 文件使用：[chunkhash]； CSS 文件使用：[contenthash]； 其他静态资源用：[hash]，例如图片、字体等，在url-loader中配置[hash] code规范 必须使用ES Module，方面Tree-Shaking，注意副作用代码 合理使用webpack magic comments 选择符合es module规范的第三方库，例如lodash-es 如何调试Webpack在vscode中打下断点，然后按F5，选择nodejs（webpack是基于node的库）。就可以进行调试 如果需要自定义debug，创建launch.json文件进一步自定义。","categories":[{"name":"工程化","slug":"工程化","permalink":"https://zxffan.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"https://zxffan.github.io/tags/webpack/"},{"name":"架构","slug":"架构","permalink":"https://zxffan.github.io/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"Rust学习笔记-变量&类型&functions&注释&控制流","slug":"Rust/Rust笔记-变量&类型&function&注释&控制流","date":"2020-08-19T16:00:00.000Z","updated":"2021-06-29T14:06:39.451Z","comments":true,"path":"posts/452059e7.html","link":"","permalink":"https://zxffan.github.io/posts/452059e7.html","excerpt":"","text":"本系列文章是笔者学习Rust时所做的笔记，供日后翻阅复习。 变量和可变性在Rust中定义一个变量很简单：let x = 100，但这个x时immutable（不可变的） 1234fn main() &#123; let x = 100; x = 200; // error&#125; 在Rust中定义一个可变变量也很简单：let mut x = 100，其中的mut代表mutable 常量在Rust中使用const来定义一个常量：const MAX_POINT: u32 = 150_000 常量即不变化的量的，那么常量和**immutable变量**有什么区别呢？ 常量必须显示注明类型。 常量可以在任何作用域下（包括全局作用域）声明，let以及其它代码内容必须在fucntion下声明 常量的值必须是一个常量表达式，不能是函数或其它必须再运行时才能计算出结果的值。 常量通常定义在全局作用域下，用来避免硬编码问题。 Rust中常量的命名规范：全部大写，用下划线连接 Rust中的数值：100_000代表100,000即100000 Shadowing在Rust中允许在同一个作用域下，一个变量被声明两次 12345fn main() &#123; let sentence = &quot;I heart you!&quot;; let sentence = sentence.len(); println!(sentence); // sentence is 12&#125; sentence第一次声明为一个string；第二次声明变成number。可以理解为第一个sentence被第二个sentence给shadowed(隐藏)了。后面访问到的都是第二个。 Shadowing最大的好处就是：第二次声明时可以修改变量类型，可以用于类型转换的场景 数据类型Rust是一门静态类型语言。在编译时Rust就必须知道所有数据的类型。 Rust中的数据类型分类两种：标量类型(Scalar Types)和复合类型(Compound Types) 标量类型标量类型有：整型、浮点型、布尔型、字符型 整型let x: u32 = 100，就是定义一个无符号的32位整型 let x: i32 = 100，是定义一个带符号的32位整型 大小 带符号（Signed） 无符号（Unsigned） 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize 表示范围：以16-bit为例 i16：带符号，最高位符号位，还剩15位，所以能表示 $$[-2^{15}, 2^{15}-1]$$ u16：不带符号即为非负数，所以能表示 $$[0, 2^{16}-1]$$ isize和usize取决于操作系统，如果是64位系统就取64；如果是32位系统就取32。 在Rust中可以以多种形式书写整型字面量： Number literals Example Decimal 98_222 Hex 0xff Octal 0o77 Binary 0b1111_0000 Byte (u8 only) b&#39;A&#39; 除了Byte字面量都可以使用类型后缀（type suffix）：let num = 120u32和let num:u32 = 120是一样的 除了Byte字面量都可以使用**_视觉分隔符**：100_000代表100,000即100000 如果不指定数值类型，Rust默认i32 整型溢出：u8只能表示[0,255]范围的值，当取256就会发生溢出 debug模式下，Rust会进行溢出检测，当溢出发生，程序发生panic release模式下，Rust不会进行检测，256会变成0;257变成1。 浮点类型浮点类型只有两种：f32和f64(默认)，前者表示单精度浮点类型，后者表示双精度浮点类型。例如 1234fn main() &#123; let x = 2.1; // f64 let x: f32 = 3.1; // f32&#125; 与绝大数语言一样，Rust的浮点类型也遵循IEEE-754标准，所以也存在0.1 + 0.2的问题。 布尔类型布尔类型有两种：true和false 布尔类型占1个字节 使用bool来声明布尔类型，例如 12345fn main() &#123; let isCheck = true; let hasExist: bool = false;&#125; 字符类型Rust的字符类型占4个字节，所以能表示很多字符，比如单个中文、日文甚至emoji字符 使用单引号定义字符字面量；使用双引号定义字符串字面量，例如 12345fn main() &#123; let word = &#x27;♥&#x27;; let sentence = &quot;I ♥ you!&quot;;&#125; 复合类型复合类型有两种：元组和数组 元组1234567891011121314fn main() &#123; // 定义元组 let tup: (i32, f64, u8) = (500, 6.4, 1); // 也可以省略类型 let tup = (500, 6.4, 1); // 元组可以解构 let (x, y, z) = tup; // 使用 元组.index 的方式访问 let first = tup.0; let second = tup.1;&#125; 数组123456789101112fn main() &#123; // 定义数组 let arr: [i32, i32, i32] = [1, 2, 3]; let arr: [i32, 3] = [1, 2, 3]; // 数组元素都一样 let arr = [1, 1, 1, 1, 1]; let arr = [1; 5]; // 通过index访问元素 let x = arr[0]；&#125; 元组与数组的异同点： 相同点： 都是定长的，长度不能变化。如果需要不定长，使用vector 都是数据集合 不同点 数组中每个元素的类型必须相同，而元组可以不一样 使用方式不一样 Functions函数是Rust中最为普遍的存在。每个程序都有一个main函数作为程序的入口函数。可以通过fn关键字来定义函数。 123456789101112131415fn main() &#123; print_hello(); // 调用函数 let result = plus_two(2); println!(&quot;The result is &#123;&#125;&quot;, result);&#125;fn print_hello() &#123; println!(&quot;hello&quot;);&#125;fn plus_two(a: i32) -&gt; i32 &#123; // -&gt; 注明函数返回值类型 a + 2 // 不加分号表示是表达式，函数体的最后一行如果是表达式默认为函数返回值&#125; 注意： 函数参数必须注明类型 有返回值必须注明返回值类型，没有返回值默认返回空元组即() 语句与表达式(Statements and Expression)语句(Statements)：执行某种行为，不会有返回值 表达式(Expression)：进行计算并将结果返回 12345678fn main() &#123; let x = 123; // 语句，不会返回123 let y = &#123; // &#123;&#125; 代表表达式 let x = 124; // 语句 x + 1 // 表达式 &#125;; // y = 125&#125; 函数返回值使用-&gt;来注明函数返回值类型； 返回可以使用return关键字；通常，函数会隐含地将最后一个表达式作为函数的返回值。 注释单行注释：// 文档注释： ///：文档注释支持markdown语法，用来注释某个函数。当使用cargo doc命令时会自动生成HTMl文件 控制流与绝大数语言一样，Rust也提供了条件判断（if）和循环（loop）来实现程序流的控制。 if表达式12345678910fn main() &#123; let number = 3; if number &lt; 2 &#123; println!(&quot;less than 2&quot;); &#125; else if number == 2 &#123; println!(&quot;equal to 2&quot;); &#125; else &#123; println!(&quot;greater than 2&quot;); &#125;&#125; 注意：if 后必须借一个 返回bool类型的表达式，不想JavaScript会自动做类型转换。 let语句和if1234fn main() &#123; let condition = 3 &gt; 2; let number = if condition &#123; 10 &#125; else &#123; 20 &#125;; // 10&#125; 花括号&#123;&#125;中是一个表达式，最终就返回这个表达式的值 条件分支表达式的值的类型必须一致，上例都是默认的i32 循环LoopsRust中提供了多种循环方式，有loop、while以及for loop12345678910fn main() &#123; let mut times = 1; loop &#123; println!(&quot;loop times: &#123;&#125;&quot;, times); times += 1; if times &gt; 10 &#123; break; &#125; &#125;&#125; loop只有遇到break语句才会推出循环 loop返回值在break后添加一个表达式，会将表达式的值返回 1234567891011121314fn main() &#123; let mut counter = 0; // result 接受值 let result = loop &#123; counter += 1; if counter == 10 &#123; break counter * 2; // 返回值 &#125; &#125;; println!(&quot;The result is &#123;&#125;&quot;, result); // 20&#125; While当循环取决于一个条件表达式时可以使用while 12345678fn main() &#123; let mut num = 0; while num &lt; 5 &#123; println!(&quot;num is &#123;&#125;&quot;, num); num += 1; &#125;&#125; for当遍历某个集合时可以使用for 123456fn main() &#123; let arr = [1, 2, 3, 4]; for ele in arr.iter() &#123; println!(&quot;current is &#123;&#125;&quot;, ele); &#125;&#125; 当已知范围时可以使用for 12345fn main() &#123; for num in (1..10).rev() &#123; println!(&quot;&#123;&#125;!&quot;, num); &#125;&#125; (1..10)表示一个范围[1, 9] rev()表示reverse 练习转换摄氏度和华氏度12345678910111213141516fn main() &#123; let temp_f = to_fahrenheit(37.0); let temp_c = to_celsius(98.6); println!(&quot;&#123;&#125;c equal to &#123;&#125;f&quot;, temp_c, temp_f);&#125;// 转换成华氏度fn to_fahrenheit(temp: f32) -&gt; f32 &#123; 32.0 + temp * 1.8&#125;// 转换成摄氏度fn to_celsius(temp: f32) -&gt; f32 &#123; (temp - 32.0) / 1.8&#125; 生成第n个斐波那契数123456789101112131415fn main() &#123; let tenth = get_nth_fibonacci(10); println!(&quot;The tenth is &#123;&#125;&quot;, tenth);&#125;fn get_nth_fibonacci(n: u32) -&gt; u32 &#123; let result = if n == 1 &#123; 0 &#125; else if n == 2 &#123; 1 &#125; else &#123; get_nth_fibonacci(n - 1) + get_nth_fibonacci(n - 2) &#125;; result&#125;","categories":[{"name":"Rust","slug":"Rust","permalink":"https://zxffan.github.io/categories/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://zxffan.github.io/tags/Rust/"},{"name":"语言学习","slug":"语言学习","permalink":"https://zxffan.github.io/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Rust学习笔记-环境搭建","slug":"Rust/Rust笔记-环境搭建","date":"2020-08-16T16:00:00.000Z","updated":"2021-06-29T14:06:42.342Z","comments":true,"path":"posts/85fd164e.html","link":"","permalink":"https://zxffan.github.io/posts/85fd164e.html","excerpt":"","text":"本系列文章是笔者学习Rust时所做的笔记，供日后翻阅复习。 安装rustup以用来进行Rust版本管理的命令行工具。 MacOS &amp;&amp; Linux1$ curl --proto &#x27;=https&#x27; --tlsv1.2 https://sh.rustup.rs -sSf | sh 该命令是用来下载一个脚本然后开始安装rustup工具 Windows前往Rust官网下载exe安装包 安装过程会提示需要C++ build tools。比较简单的办法是安装virtual studio。工作负载中选择C++桌面开发。 rustup常用命令 命令 命令 备注 show rustup show 显示已安装的工具 update rustup updaterustup self update 更新rust工具以及rustup只更新rustup check rustup check 检查rust工具是否有新版本 default rustup default stablerustup default nightly 切换版本 install rustup install nightly 安装rust工具 uninstall rustup uninstallrustup self uninstall 删除rust工具删除rust工具和rustup doc rustup doc 查看文档（可以离线使用） Hello World创建main.rs，编写代码 123fn main() &#123; println!(&quot;Hello, World&quot;)&#125; 执行代码： 编译：执行rustc main.rs，会生成可执行文件 执行：./main or ./main.exe(win) 结果：命令行显示Hello,World Cargocargo是Rust的项目管理器，提供了一键创建、运行以及buildRust项目的命令： cargo new my_project: 创建项目 cargo build: build操作，在/target/debug/目录下创建可执行文件 cargo run: build然后run cargo check：检查code是否能够通过编译，不会创建创建可执行文件 cargo build --release: build操作，会额外做优化以加快程序运行速度，在发布release版本时使用","categories":[{"name":"Rust","slug":"Rust","permalink":"https://zxffan.github.io/categories/Rust/"}],"tags":[{"name":"Rust","slug":"Rust","permalink":"https://zxffan.github.io/tags/Rust/"},{"name":"语言学习","slug":"语言学习","permalink":"https://zxffan.github.io/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"}]},{"title":"Web Animation API","slug":"JavaScript/WebAnimationAPI","date":"2020-08-15T16:00:00.000Z","updated":"2021-06-29T14:05:44.255Z","comments":true,"path":"posts/af0be6b0.html","link":"","permalink":"https://zxffan.github.io/posts/af0be6b0.html","excerpt":"","text":"Web Animation API以前，在web页面增加动画效果都是通过css来完成的。比如transition或者animation。有了Web Animation API就可以通过javascript来设置以及控制动画。 CSS实现动画通过css实现一个简单的动画，让box旋转移动，代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; width: 100px; height: 100px; background-color: red; animation: move 2s ease-in-out; position: fixed; &#125; @keyframes move &#123; from &#123; transform: rotate(0); left: 0; top: 0; &#125; to &#123; transform: rotate(1turn); left: 80%; top: 80%; &#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Javascript实现动画将上面例子改成JavaScript，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .box &#123; width: 100px; height: 100px; background-color: red; position: fixed; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; // 获取dom const ele = document.querySelector(&quot;.box&quot;); // 设置keyframes const keyframes = [ &#123; transform: &quot;rotate(0)&quot;, left: 0, top: 0, &#125;, &#123; transform: &quot;rotate(1turn)&quot;, left: &quot;80%&quot;, top: &quot;80%&quot;, &#125;, ]; // 设置动画，animate函数返回一个Animation对象 const animation = ele.animate(keyframes, &#123; easing: &quot;ease-in-out&quot;, duration: 2000, // millisecond &#125;); // 可以监听时间 animation.addEventListener(&quot;cancel&quot;, () =&gt; &#123; console.log(&quot;cancel&quot;); &#125;); animation.addEventListener(&quot;finish&quot;, () =&gt; &#123; console.log(&quot;finish&quot;); &#125;); animation.addEventListener(&quot;remove&quot;, () =&gt; &#123; console.log(&quot;remove&quot;); &#125;); // 取消 // animation.cancel() // 播放 // animation.play() &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 使用方法很简单。直接调用animate方法即可。 对比web animation api比传统的css animation方案优秀不少，能够提供更好的用户体验。 前者更加灵活，javascript灵活度大于css 前者能够控制动画，诸如：暂停、播放等 前者能够监听动画的生命周期事件，例如：finish、cancel 前者兼容性不足，ie以及一些移动端不支持。但是有polyfill啊！ Animation API介绍调用animate方法后会返回一个Animation对象。通过这个对象能够实现控制动画以及监听动画的生命周期事件。 事件 event type comment oncancel function animation.cancel()调用后触发 onfinish function 动画播放结束后或者animation.finish()调用后触发 属性 name type comment currentTime number 动画执行的当前时间（ms） playState ‘idle’ | ‘pending’ | ‘runing’ | ‘paused’ | ‘finished’ 一个用来标识播放状态的枚举值idle: 动画当前的时间是无法解析的，并且队列里没有处于等待执行的任务。pending: 动画将一直等到某些等待中的任务完成方会执行。running：动画处于正在运行状态。paused：动画中止，并且Animation.currentTime该项属性不会更新。finished:动画已经达到某一临界点，并且Animation.currentTime该项属性不会更新。 方法 name type comment cancel () =&gt; void 清除此动画的所有keyframeEffects，并中止播放。 finish () =&gt; void 立即完成，效果同中止播放（触发事件不一样）。 pause () =&gt; void 暂停播放动画 play () =&gt; void 开始或恢复播放动画，或者如果之前完成，则重新开始动画。 reverse () =&gt; void 反转播放动画，直到播放到动画开始时停止。 如果动画完成或未播放，它将从头到尾播放。 更详细的API介绍请参考MDN","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"animation","slug":"animation","permalink":"https://zxffan.github.io/tags/animation/"}]},{"title":"Electron-安全","slug":"Electron/Electron-安全","date":"2020-08-09T16:00:00.000Z","updated":"2021-06-29T14:04:09.970Z","comments":true,"path":"posts/b81ed83c.html","link":"","permalink":"https://zxffan.github.io/posts/b81ed83c.html","excerpt":"","text":"XSS进化到RCEWeb的XSS攻击能做到脚本注入，而Electron具有原生能力可以调用nodejs的模块。这就导致进化成了RCE攻击(Remote code excute) 1&lt;img onerror=&quot;require(&#x27;fs&#x27;);fs.readFile(&#x27;./data.json&#x27;)&quot;/&gt; 解决： 基本的XSS防范措施 管理node权限 主进程任何时候都允许 渲染进程加载本地资源是允许 渲染进程加载远程资源时不允许，但可以在preload中使用 限制链接跳转 https可信域允许 应用本地协议允许 file协议不允许 cookie克隆攻击将cookie文件拷贝到其它机器，可以直接使用 原因：Electron cookie没有想Chrome那样加密 解决： 生成设备指纹，将cookie与设备指纹绑定 源码安全Electron打包可以设置asar，但是asar是可以解密的。 npm i asar -g、asar e app.asar unpack、cd unpack 解决： UI与逻辑分离：UI层使用Electron，逻辑层使用C++或Rust。通过N-API、Neon连接nodejs WebAssembly 代码混淆，使用构建工具进行代码混淆 asar：防止小白 asar Hack 安全事项app层 做好Web安全 官方 安全Checklist，文档 代码混淆 npm nsp/snyk，检测npm包的安全性 关注npm官博安全文章 nodejs安全小组 Node.js Security WG electron 升级Electron至最新 有问题反馈&#x73;&#101;&#x63;&#x75;&#x72;&#105;&#116;&#121;&#64;&#x65;&#108;&#101;&#x63;&#x74;&#114;&#x6f;&#x6e;&#106;&#x73;&#x2e;&#111;&#x72;&#x67; 尝试研究electron构建，具备项目应急能力","categories":[{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/categories/Electron/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/tags/Electron/"},{"name":"桌面端软件","slug":"桌面端软件","permalink":"https://zxffan.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF%E8%BD%AF%E4%BB%B6/"}]},{"title":"Electron-测试","slug":"Electron/Electron-测试","date":"2020-08-04T16:00:00.000Z","updated":"2021-06-29T14:04:12.496Z","comments":true,"path":"posts/bc68d7e0.html","link":"","permalink":"https://zxffan.github.io/posts/bc68d7e0.html","excerpt":"","text":"测试金字塔 前端软件测试可以分为三步 单元测试（Unit Test）单元测试是用来对一个模块、一个函数、一个组件或者一个类来进行正确性检验的测试工作。 单元测试应该是最多的，而且快。 单元测试颗粒更细，更加具体。测试失败要返回错误原因 快照测试（snapshot Test）快照测试就是运行测试的时候，把结果保存一份，之后再来对比，比对不上测试就不通过。 端到端测试（E2E Test）端到端测试时模拟用户的整个交互过程。比如：点击按钮 =&gt; 显示表单 =&gt; 填写数据 =&gt; 点击提交按钮 =&gt; 验证数据发送。 Electron 测试处理Electron驱动可以使用官方提供的spectron；也可以自定义驱动 选择测试框架+工具 ava mocha+chai jest … 管理测试用例通常在项目建立一个test目录，专门存放测试用例。 按模块、功能分好类 创建测试脚本在package.json加入test命令，编写自定义脚本，test命令去执行这个脚本。 脚本主要用来执行测试用例 自动化测试流程测试准备数据mock、准备上下文。 测试用例描述用来说明这个测试用例是用来做什么的 行为要做什么事 断言得到什么结果 测试后处理清理mock的数据，清理上下文 Electron测试编码123456789101112131415161718192021222324252627const Application = require(&#x27;spectron&#x27;).Applicationconst electronPath = require(&#x27;electron&#x27;)const path = require(&#x27;path&#x27;)// jest 测试工具describe(&#x27;Application lanuch&#x27;, () =&gt; &#123; let app beforeEach(() =&gt; &#123; app = new Application(&#123; path: electronPath args: [path.join(__dirname, &#x27;../&#x27;)] &#125;) return app.start() &#125;); afterEach(() =&gt; &#123; if(app &amp;&amp; app.isRunning()) return app.stop() &#125;); test(&#x27;Check if the window is visible&#x27;, () =&gt; &#123; expect(app.browserWindow.isVisible()).toBeTruthy() &#125;); test(&#x27;Get the window\\&#x27;s title&#x27;, () =&gt; &#123; expect(app.client.getTitle()).toBe(&#x27;My App&#x27;) &#125;)&#125;)","categories":[{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/categories/Electron/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/tags/Electron/"},{"name":"桌面端软件","slug":"桌面端软件","permalink":"https://zxffan.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF%E8%BD%AF%E4%BB%B6/"}]},{"title":"Electron-集成原生能力","slug":"Electron/Electron-集成原生能力","date":"2020-08-01T16:00:00.000Z","updated":"2021-06-29T14:04:15.074Z","comments":true,"path":"posts/72ce1ec4.html","link":"","permalink":"https://zxffan.github.io/posts/72ce1ec4.html","excerpt":"","text":"NAPIN-API是nodejs的一部分，独立于v8 runtime，用来在nodejs中集成C++：同一ABI（Application Binary Interface）、无需重新编译 本身是基于C的API C++封装 node-addon-api 环境配置yarn global add windows-build-tools : 管理员身份安装 yarn global add node-gyp: gyp即generate your project 初始化项目 初始化： npm init -y yarn add bindings node-addon-api -D package.json增加&quot;gyp&quot;:true 目录结构123456|- project| |- lib # c++文件| |- fingerprint.cc| |- binding.gyp| |- index.js| |- package.json binding.gypbindings用来加载原生模块(.node文件)。不同平台不同版本rebuild出来的目录结构可能不一样。通过bindings来抹平差异。 编写binding.gyp 1234567891011121314&#123; &quot;targets&quot;: [ &#123; &quot;target_name&quot;: &quot;fingerprint&quot;, // 应用名称 &quot;cflags!&quot;: [&quot;-fno-exceptions&quot;], &quot;cflags_cc!&quot;: [&quot;-fno-exceptions&quot;], &quot;sources&quot;: [&quot;fingerprint.cc&quot;], // 需要编译的文件 &quot;include_dirs&quot;: [ // 编译时需要引入的头文件 &quot;&lt;!@(node -p \\&quot;require(&#x27;node-addon-api&#x27;).include\\&quot;)&quot; ], &quot;defines&quot;: [&quot;NAPI_DISABLE_CPP_EXCEPTIONS&quot;] &#125; ]&#125; C++实现123456789101112131415161718192021222324252627282930313233// fingerprint.cc#include &lt;napi.h&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stdlib.h&gt;std::string getFingerprint()&#123; srand(100); std::string result = std::to_string(rand()); return result;&#125;// 定义一个method，该方法返回一个设备指纹（随机数mock）Napi::String Method(const Napi::CallbackInfo &amp;info)&#123; Napi::Env env = info.Env(); std::string fingerprint = getFingerprint(); return Napi::String::New(env, fingerprint);&#125;// 初始化// 相当于 module.exports = MethodNapi::Object Init(Napi::Env env, Napi::Object exports)&#123; exports.Set(Napi::String::New(env, &quot;getFingerprint&quot;), Napi::Function::New(env, Method)); return exports;&#125;// 暴露模块// 模块名 fingerprint，Init进行初始化NODE_API_MODULE(fingerprint, Init) 构建使用node-gyp rebuild进行构建，在根目录中会生成build目录。 然后编写index.js，来导出模块 123const fingerprint = require(&quot;bindings&quot;)(&quot;fingerprint&quot;);module.exports = fingerprint; 使用通常做法是，将写好的node addon发布到npm上。在其它项目中就可以通过npm或者yarn安装，然后就require使用 123const fp = require(&quot;fingerprint&quot;); // fingerprint是npm包名console.log(fp.getFingerprint()); 集成DLL（动态链接库）node-ffi-napi，黑盒调用 12345678910111213const FFI = require(&#x27;ffi-napi&#x27;)const user32 = new FFI.libraray(&#x27;user32&#x27;, &#123; &#x27;finDWindowA&#x27;: [&#x27;int32&#x27;, [&#x27;string&#x27;, &#x27;string&#x27;]], &#x27;ShowWindow&#x27;: [&#x27;int32&#x27;, [&#x27;int32&#x27;, &#x27;int32&#x27;]],&#125;)function showWechat() &#123; let res = user32.FindWindowA(&#x27;weChatMainWinForPC&#x27;, null) let show = user32.showWindow(res, 5)&#125;module.exports = showWechat 常见错误： Dynamic Linking Error: Win32 error 126 dll 路径没写对、arch 没选对、dll 引用有问题 Dynamic Linking Error: Win32 error 127 传参有问题、dll 没有这个函数 AppleScriptmac上，还可以通过AppleScript使用获得原生能力 AppleScript语法文档 node-applescript 123456789const applescript = require(&#x27;applescript&#x27;)const script = &#x27;tell application &quot;WeChat&quot; to activate end&#x27;applescript.execString(script, (err, res) =&gt; &#123; if(err) &#123; console.log(err) return &#125; console.log(res)&#125;) 集成RUST通过Neon来将RUST程序集成到nodejs中。","categories":[{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/categories/Electron/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/tags/Electron/"},{"name":"桌面端软件","slug":"桌面端软件","permalink":"https://zxffan.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF%E8%BD%AF%E4%BB%B6/"},{"name":"C++","slug":"C","permalink":"https://zxffan.github.io/tags/C/"},{"name":"Rust","slug":"Rust","permalink":"https://zxffan.github.io/tags/Rust/"}]},{"title":"Electron-体验优化","slug":"Electron/Electron-体验优化","date":"2020-07-29T16:00:00.000Z","updated":"2021-06-29T14:04:17.624Z","comments":true,"path":"posts/60bc3abb.html","link":"","permalink":"https://zxffan.github.io/posts/60bc3abb.html","excerpt":"","text":"Electron内置了Chromium浏览器。在原生体验上，一直被诟病。在开发Electron程序时，要格外关注体验优化。 性能优化核心模块优先加载不再在入口文件把所有内容都加载进来，只需要加载程序的核心功能，其它部分按需加载 12345678910function compute(a, b) &#123; const calculator = require(&#x27;./calculator&#x27;) return calculator.complex(a, b)&#125;// 执行核心内容// ...// 执行非核心内容compute(0x12f2, 0xff21) 在Typescript通过dynamic import实现 12345678910async function compute(a, b) &#123; const calculator = await import(&#x27;./calculator&#x27;) return calculator.complex(a, b)&#125;// 执行核心内容// ...// 执行非核心内容compute(0x12f2, 0xff21) Web性能优化毕竟本质上还是Web，所以Web性能的优化技巧都可以应用得到Electron。如果使用SPA，要格外注意打包优化。 窗口预热 与 窗口池、窗口常驻 窗口预热：提前创建窗口，加载必要的资源（不显示），等需要时直接显示即可。这样的做法是以空间换时间。 窗口池：不要频繁创建和销毁窗口，当需要加载新页面时从当前的窗口池中选择窗口 窗口常驻：对于业务无关的、通用的窗口，也可以采用常驻模式，例如通知，图片查看器。这些窗口一旦创建就不会释放，打开效果会更好。 网络资源缓存PWA 主进程保持轻量Electron程序中，主进程和渲染进程有着Sync IPC（同步IPC）操作。如果主进程中有密集计算，会导致渲染进程UI阻塞。 可以使用多进程，参考node的cluster模块 或者通过web worker来实现多线程，但是web worker只能在渲染进程中使用，所以对于密集计算，可以单独开个渲染进程(开启一个不显示的窗口)来处理。 还有：不要使用remote模块！不要使用remote模块！不要使用remote模块！，remote模块本质上也是使用同步IPC，所以也会很容易造成阻塞 预加载Electronelectron中，在创建BrowserWindow时可以指定preload字段来预加载一段脚本 Browser使用requestIdleCallback，让浏览器空闲时执行一些优先级较低的任务。 当浏览器空闲时，会调用requestIdleCallback注册的回调函数，但是有可能浏览器一直很繁忙没有空闲，这是需要指定timeout，超过这个时间强制执行 1var handle = window.requestIdleCallback(callback[, options]) callback：回调，即空闲时需要执行的任务，该回调函数接收一个IdleDeadline对象作为入参。其中IdleDeadline对象包含： didTimeout，布尔值，表示任务是否超时，结合 timeRemaining 使用。 timeRemaining()，表示当前帧剩余的时间，也可理解为留给任务的时间还有多少。 options：目前 options 只有一个参数 timeout。表示超过这个时间后，如果任务还没执行，则强制执行，不必等待空闲。 原生模块ndoejs可以集成C++、RUST等，用来优化性能，详情见Electron-集成原生能力 启动优化V8 snapshotatom通过v8 snapshot优化启动时间 v8 snapshot会将javascript输出成二进制文件，文件的内容是javascript代码在内存中的表现形式即数据堆 这个二进制文件的执行速度时快于javascript代码的。 在Electron中将一些启动时的核心代码进行v8快照，这样可以起到优化启动速度的目的 说明： v8 snapshot中的代码是处于一个裸露的v8上下文中，也就是说只能使用plain javascript而无法调用Electron和nodejs的API，Atom团队的electron-link可以在一定程度上规避这个问题 生成v8 snapshot可以通过electron-mksnapshot来实现 V8 code cachenodjes v12对内部模块做了code cache，对启动速度提升很明显。 白屏问题为什么会有白屏 在show（窗口显示）到ready-to-show（页面加载完毕）之间还需要经历以下过程 preload解析，创建BrowserWindow设置的 解析HTML结构 加载外部脚本（script）以及样式表文件（link） 解析并执行脚本 Dom Tree构建完毕 资源文件（图片、音视频）加载 页面加载完成 只有完成这些过程，窗口才能显示内容。所以这段时间窗口会一直白屏。如果使用vue或react这种SPA框架，也会出现首屏加载过慢的情况。 解决方法一——不显示窗口创建BrowserWindow时，设置show:false即不显示窗口 等到ready-to-show事件触发时才显示 123456789const win = new BrowserWindow(&#123; widht: 600, height: 300, show: false&#125;)win.on(&#x27;ready-to-show&#x27;, () =&gt; &#123; win.show()&#125;) 解决方法二——骨架屏最简单的方法就是直接给窗口显示个底色 123456const win = new BrowserWindow(&#123; widht: 600, height: 300, show: false, background: &#x27;#2e2c29&#x27;&#125;) 比较好的方法就是专门设计一套骨架屏。利用BroswerView来显示骨架屏。 当窗口创建时，创建BrowserView来加载骨架屏页面，将BrowserView设置到BrowserWindow上并遮罩住，当骨架屏页准备好后时显示骨架屏。当渲染进程发送来一个stop-loading消息时，移除BrowserView 12345678910111213141516171819202122232425const mainWindow = new BrowserWindow(&#123; width: 800, height: 600, webPreferences: &#123; preload: path.join(__dirname, &quot;preload.js&quot;), &#125;, show: false, // 默认不显示窗口&#125;);let view = new BrowserView();mainWindow.setBrowserView(view);view.setBounds(&#123; x: 0, y: 0, width: 800, height: 600 &#125;); // 遮挡住窗口view.webContents.loadFile(&quot;loading.html&quot;); // 加载骨架屏页面// 当骨架屏加载完成后显示窗口view.webContents.on(&quot;dom-ready&quot;, () =&gt; &#123; console.log(&quot;show&quot;); mainWindow.show();&#125;);// 当渲染进程发来stop-loading消息时，移除骨架屏，显示真正页面ipcMain.on(&quot;stop-loading&quot;, () =&gt; &#123; console.log(&quot;stop&quot;); mainWindow.removeBrowserView(view);&#125;); 性能检测Chrome DevTools Performance 支持快捷键系统快捷键 1234567891011121314151617181920212223const &#123; app, globalShortcut &#125; = require(&#x27;electron&#x27;)app.on(&#x27;ready&#x27;, () =&gt; &#123; // 注册一个 &#x27;CommandOrControl+X&#x27; 的全局快捷键 const ret = globalShortcut.register(&#x27;CommandOrControl+X&#x27;, () =&gt; &#123; console.log(&#x27;CommandOrControl+X is pressed&#x27;) &#125;) if (!ret) &#123; console.log(&#x27;registration failed&#x27;) &#125; // 检查快捷键是否注册成功 console.log(globalShortcut.isRegistered(&#x27;CommandOrControl+X&#x27;))&#125;)app.on(&#x27;will-quit&#x27;, () =&gt; &#123; // 注销快捷键 globalShortcut.unregister(&#x27;CommandOrControl+X&#x27;) // 注销所有快捷键 globalShortcut.unregisterAll()&#125;) 本地化（i18n）Electron程序在ready事件后，可以通过app.getLocale()来获得local值(如zh-CN)，详细列表 通过i18nnext来实现国际化 Electron使用i18nnext 开机自启通过app.setLoginItemSettings来设置开机自启 123456app.setLoginItemSettings(&#123; openAtLogin: true, // Boolean 在登录时启动应用 默认false openAsHidden: true, // Boolean (可选) mac 表示以隐藏的方式启动应用。~~~~ // path: &#x27;&#x27;, String (可选) Windows - 在登录时启动的可执行文件。默认为 process.execPath. // args: [] String Windows - 要传递给可执行文件的命令行参数。默认为空数组。注意用引号将路径换行。&#125;)","categories":[{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/categories/Electron/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/tags/Electron/"},{"name":"桌面端软件","slug":"桌面端软件","permalink":"https://zxffan.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF%E8%BD%AF%E4%BB%B6/"}]},{"title":"Electron-项目打包","slug":"Electron/Electron-项目打包","date":"2020-07-25T16:00:00.000Z","updated":"2021-06-29T14:04:21.170Z","comments":true,"path":"posts/acb10ea6.html","link":"","permalink":"https://zxffan.github.io/posts/acb10ea6.html","excerpt":"","text":"打包分为几步？ 下载二进制文件 ： 添加业务代码：构建好的前端资源添加到resources app，electron壳子与业务代码结合 修改文件信息：修改 应用名称，设置图标等 制作镜像：压缩文件，制作镜像（dmg-builder、nsis） 打包工具 electron-builder electron-forge 签名 *** *** 安装包类型 *** *** 原生模块编译 *** *** 定制化 *** * 上手成本 ** * boilerplate x *** 跨平台构建 Linux、windows x 社区活跃度 *** ** 场景 打包和发布的完成解决方案，基本适用于所有场景 创建到发布的一体化解决方案，适合从0到1的项目 推荐使用electron-builder 打包准备 证书 mac: 开发者证书 window：赛门铁克(Symantec)、WoSign 对于系统的机器（mac打macos的包，windows打win的包，linux打linux的包） 软件所需图片 mac： 软件图标、icns格式，通过 image2icon 或者 iconutil 生成 dmg 背景图 安装包图标 Windows ico installerIcon-安装图标 unInstallerIcon-卸载图标 使用electron-builder来打包安装相关依赖 npm i -g --production window-build-tool（用管理员权限安装，window必备） 项目目录下执行npm i electron-builder -S 在package.json中，添加&quot;postinstall&quot;: &quot;electron-builder install-app-deps&quot;。每当使用npm install或者yarn add时，会自动安装匹配当前electron版本的依赖。 配置方式在package.json中加入build属性 使用electron-builder.yml 通过编程时API 配置项在package.json文件中添加如下 123456789101112131415161718192021222324252627282930313233343536373839&quot;build&quot;： &#123; &quot;appId&quot;: &quot;com.xxx.xxx&quot;, &quot;productName&quot;: &quot;应用名称&quot;, &quot;directories&quot;: &#123; // 目录配置 &quot;app&quot;: &quot;dist&quot;, // 打包的代码目录 &quot;buildResources&quot;: &quot;resource&quot;, // 构建包的资源目录 &quot;output&quot;: &quot;release&quot; // 存放产包的目录 &#125;, &quot;asar&quot;: true, // asar加密，保护源代码 &quot;copyright&quot;: &quot;Copyright xxxx&quot;, &quot;mac&quot;: &#123; &quot;target&quot;: [&quot;dmg&quot;, &quot;zip&quot;], // 包格式，zip用于自动更新 &quot;icon&quot;: &quot;resources/icon.icns&quot; // logo地址 &#125;, &quot;dmg&quot;: &#123; &quot;background&quot;: &quot;resources/background.png&quot;, // 背景图 &quot;window&quot;: &#123; &quot;width&quot;: 540, &quot;height&quot;: 380&#125;, // 安装窗口大小 &quot;contents&quot;: [ // dmg内容坐标 &#123;&quot;x&quot;: 410, &quot;y&quot;: 190, &quot;type&quot;: &quot;link&quot;, &quot;path&quot;: &quot;/Applications&quot;&#125;, &#123;&quot;x&quot;: 130,&quot;y&quot;: 190,&quot;type&quot;: &quot;ﬁle&quot;&#125; ], &quot;iconSize&quot;: 128, // logo大小 &#125;, &quot;win&quot;: &#123; &quot;icon&quot;: &quot;resources/icon.ico&quot;, // logo地址 &quot;target&quot;: [ &quot;nsis&quot;, &quot;squirrel&quot;] // nsis包，squirrel是一件安装包 &#125;, &quot;nsis&quot;: &#123; &quot;oneClick&quot;: false, // 一键安装 &quot;language&quot;: &quot;2052&quot;, // 2052代表中文 &quot;perMachine&quot;: true, // 是否为机器上所有用户安装 &quot;allowToChangeInstallationDirectory&quot;: true // 允许改变安装目录 &#125;, &quot;squirrelWindows&quot;: &#123; &quot;loadingGif&quot;: &quot;resources/loading.gif&quot;, // 安装动态图 &quot;iconUrl&quot;: &quot;https://xxxxx.com/icon.ico&quot; // 必须是远程的 &#125;&#125; nsis时windows下的包安装器，可以做到很细致的定制。 如果使用squirrel来打包，需要安装electron-builder-squirrel-windows 在scripts中加上&quot;pack&quot;: &quot;electron-builder&quot; 如果使用编程时API，则新建一个js或ts文件 12345678910111213// jsconst &#123; build &#125; = require(&quot;electron-builder&quot;);build(&#123; config: &#123; appId: &quot;com.xxx.xxx&quot;, productName: &quot;应用名称&quot;, // ...以下省略 &#125;&#125;)// build函数返回一个promise// 可以 借助 electron-builder的类型声明文件来查看它有哪些方法和参数类型 然后用node执行这个js文件。如果是ts文件，可以使用ts-node，或者先用tsc编译再用node执行。 electron-builder更详细的配置请查阅官网 总结 发布产品注意版本号的升级 npm version patch：自动升级patch npm version minor：自动升级minor，path会清0 npm version major：自动升级major，minor和patch会清0 证书 windows下没有证书，可能会被杀软误杀 mac下没有证书，无法实现自动更新 windows下打包可以通过修改nsis来自定义安装逻辑 开源软件可以基于 Travis, AppVeyor 持续集成","categories":[{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/categories/Electron/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/tags/Electron/"},{"name":"桌面端","slug":"桌面端","permalink":"https://zxffan.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF/"}]},{"title":"Electron-质量监控","slug":"Electron/Electron-质量监控","date":"2020-07-23T16:00:00.000Z","updated":"2021-06-29T14:04:28.494Z","comments":true,"path":"posts/34a04fbb.html","link":"","permalink":"https://zxffan.github.io/posts/34a04fbb.html","excerpt":"","text":"Electron质量保证 开发 测试 上线 监控 渲染进程 代码静态检查：eslint强类型语言：typescriptCode review 单元测试性能测试UI自动化测试冒烟测试 灰度发布回滚 性能监控异常监控用户行为监控 主进程 同上 Electron测试(Spectron) 功能开关热修复 崩溃监控 崩溃监控模型 Electron内置crashReporter模块，可以用来监控主进程和渲染检查的错误。然后将错误报告发送给服务器的crash收集服务 崩溃报告将发送下面 multipart/form-data POST 型的数据给 submitURL: ver String - Electron 的版本. platform String - 例如 ‘win32’. process_type String - 例如 ‘renderer’. guid String - 例如 ‘5e1286fc-da97-479e-918b-6bfb0c3d1c72’. _version String - package.json 里的版本号. _productName String - crashReporter options 对象中的产品名字 prod String - Name of the underlying product. In this case Electron. _companyName String - crashReporter options 对象中的公司名称 upload_file_minidump File - minidump 格式的崩溃报告 All level one properties of the extra object in the crashReporter options object. 上述数据中的upload_file_minidump是个minidump格式的文件。直接时无法打开的。需要结合electron-symbols以及node-minidump，后面再说。 实现监控服务端使用koa搭建一个crash收集服务 1234567891011121314151617const Koa = require(&#x27;koa&#x27;)const app = new Koa()const Router = require(&#x27;koa-router&#x27;)const multer = require(&#x27;koa-multer&#x27;) // 处理文件上传的库const uploadCrash = multer(&#123; dest: &#x27;crash/&#x27; &#125;) // 设置错误报告存放目录const router = new Router()router.post(&#x27;/crash&#x27;, uploadCrash.single(&#x27;upload_file_minidum&#x27;), (ctx, next) =&gt; &#123; // TODO 错误信息存储到DB ctx.request.file // minidump文件&#125;)app.use(router.routes()) .use(router.allowedMethods())app.listen(33855) ELectron端配置crashReporter 123456789101112131415161718// crash.jsconst &#123; crashReporter &#125; = require(&#x27;electron&#x27;)function init() &#123; crashReporter.start(&#123; crashReporter.start(&#123; productName: &#x27;&#x27;, companyName: &#x27;&#x27;, submitURL: &#x27;服务器 处理异常接口地址&#x27; &#125;) &#125;)&#125;modules.exports = &#123; init &#125;// main.jsapp.on(&#x27;will-finish-lanuching&#x27;, () =&gt; &#123; require(&#x27;./crash-reporter&#x27;).init()&#125;) 解析错误日志服务端收到的是minidump文件。需要使用symbols以及node-minidump来解析日志 先下载对应electron版本和对应os的symbols，下载地址 建立一个node项目（也可以集成到crash收集服务中）。安装node-minimap 执行yarn add minidump 123456789const minidump = require(&#x27;node-minidump&#x27;)const fs = require(&#x27;fs&#x27;)minidump.addSymbolPath(&#x27;./symbols/electron-v10.0.0-beta.12-darwin-x64-symbols.zip&#x27;) // 指定下载的symbols路径// 指定minidump文件地址minidump.walkStack(&#x27;./e19fb34bc3rf6812&#x27;, (err, res) =&gt; &#123; // res 解析结果 fs.writeFileSync(&#x27;./res.txt&#x27;, res) // 写入文件&#125;) 监控技巧渲染进程崩溃后提示用户重新加载通过 preload统一初始化崩溃监控主进程、渲染进程通过 process.crash()可以模拟崩溃 通过process进行异常监控 123process.on(&#x27;uncaughtException&#x27;, () =&gt; &#123; // 上报异常&#125;)","categories":[{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/categories/Electron/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/tags/Electron/"},{"name":"桌面端软件","slug":"桌面端软件","permalink":"https://zxffan.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF%E8%BD%AF%E4%BB%B6/"}]},{"title":"Electron-应用更新","slug":"Electron/Electron-应用更新","date":"2020-07-21T16:00:00.000Z","updated":"2021-06-29T14:04:25.159Z","comments":true,"path":"posts/e7227c9a.html","link":"","permalink":"https://zxffan.github.io/posts/e7227c9a.html","excerpt":"","text":"软件更新方式手动更新用户手动下载、安装新包。 手动更新简单稳定，适合更新频率低，用户粘性高的场景，通常作为其它升级技术的降级方案。 流程： 更新服务：匹配客户端版本，用户信息 检查更新器：返回包地址，更新文案 提示：新功能升级 手动操作：跳转浏览器，打开安装包覆盖 文件覆盖程序自动替换文件以实现更新。 不稳定，可能会写入失败。适合打补丁的场景 流程： 更新服务：匹配客户端版本，用户信息 检查更新器：返回包地址，更新文案 提示：新功能升级 程序操作：吊起子程序，关闭应用，将补丁复制到应用目录，重新启动 自动更新后台下载文件，重启即新版 稳定，快，用户无感知。适合更新频率高的场景，以及对用户体验要求高的场景 流程：更新服务 =&gt; 检查更新器 =&gt; 下载新包 =&gt; 重启应用加载新包 应用商店通过各平台应用商店发布，例如Microsoft store和mac app store 统一、稳定 对比 更新方式 手动更新 文件覆盖 自动更新 应用商店 优点 简单、稳定 下载过程快 稳定、快、打扰少 统一、稳定 缺点 过程繁琐、慢、影响使用、 实现复杂、稳定性差、文件写入可能失败 实现复杂 受应用商店局限 使用场景 低频更新、用户粘性高、作为各种升级技术的降级方案 打补丁 高频更新、体验要求高 需要上架商店的软件 Electron更新方式Web化将渲染进程（业务）代码，放置远程服务器。Electron通过loadURL加载 这样的话，只要更新服务器的代码就能实现系统更新。 缺点：无法离线使用，Electron壳子无法更新。 文件覆盖Electron检测服务器的release版本与本地是否一致，若有新版本提示升级。拉去服务器程序并覆盖本地，然后重启。 相关实现请参考张鑫旭的文档 Electron-UpdaterElectron-Updater是由electron-builder提出的 优点 接入简单 Windows 支持签名验证 支持进度条 基于 electron-builder 非常容易使用 缺点 Windows 更新体验没有内置的好 Windows 存在权限问题 详见 https://www.electron.build/auto-update.html 增量更新只更新需要更新的地方 原理： 当前版本与最新版本做diff算法，将不同的地方打包成patch，更新就只更新patch部分。 增量技术： bsdiff/bspatch：适用二进制文件、开源、免费、广泛使用（尤其移动端） Xdelta3：适用于二进制 Courgette：谷歌提出的方案，是bsdiff的优化 RTPatch：商业付费 对比参考：https://www.shangyexin.com/2018/09/28/delta_algorithm/ 灰度发布灰度发布就是让一部分用户继续使用原来的产品功能，对另一部分用户逐渐开发新功能。然后针对新功能在做完善和优化。等到灰度发布完成后，所有用户都将使用新的产品功能。 Electron更新实战更新准备准备证书，Mac下自动更新必须要证书。打包时候配置。 使用内置的autoUpdater模块Electron官方更新方法是基于内置的Squirrel框架和Electron的autoUpdater模块。 autoUpdater模块简介1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const &#123; autoUpdater: updater &#125; = require(&#x27;electron&#x27;)// 设置更新服务器地址updater.setFeedURL(&#123; url: &#x27;更新服务器地址&#x27;, headers: &#x27;HTTP请求头&#x27;, serverType: &#x27;default&#x27; // json or default &#125;)// 获取当前更新服务器地址updater.getFeedURL()// 检查更新，访问更新服务器地址// 调用checkForUpdates之前必须设置setFeedURLupdater.checkForUpdates()// 此方法hui关闭所有应用窗口，然后自动调用app.quit()// 这个方法通常在 update-downloaded 事件触发后调用updater.quitAndInstall()// 开始检查更新时触发updater.on(&#x27;check-for-update&#x27;, () =&gt; &#123; // TODO...&#125;)// 检查更新后，发现有新版本后触发该事件// 该事件触发后，会自动下载最新版本updater.on(&#x27;update-avaliable&#x27;, () =&gt; &#123; // TODO...&#125;)// 检查更新后，没有发现新版本（返回204）后触发该事件updater.on(&#x27;update-not-avaliable&#x27;, () =&gt; &#123; // TODO...&#125;)// 最新版下载完成后触发该事件// 在 Windows 上只有 releaseName 是有效的。updater.on(&#x27;update-downloaded&#x27;, (e, releaseNotes, releaseName, releaseDate, updateURL) =&gt; &#123; // TODO... // 显示提示框，询问用户是否自动更新&#125;)// 用户调用quitAndInstall 后触发updater.on(&#x27;before-quit-for-update&#x27;, () =&gt; &#123; // TODO...&#125;)// 更新发生错误时，触发updater.on(&#x27;error&#x27;, (error) =&gt; &#123; // TODO...&#125;) 更新流程mac更新Electron客户端请求服务器，服务器去检查是否有最新版本。如果有，服务端需要返回相应数据，没有就返回204状态码 mac下服务端需要返回这样的json结构 123456&#123; &quot;url&quot;: &quot;https://mycompany.example.com/myapp/releases/myrelease&quot;, // url为包下载地址 &quot;name&quot;: &quot;My Release Name&quot;, &quot;notes&quot;: &quot;Theses are some release notes innit&quot;, &quot;pub_date&quot;: &quot;2013-09-18T12:29:53+01:00&quot; &#125; 然后Electron客户端就会自动请求url地址去下载 windows更新Electron客户端请求服务器，服务器去检查是否有最新版本。如果有，服务端需要返回相应数据，没有就返回204状态码 window下需要返回RELEASES文件内容（使用Squirrel打包生成的），如BBC6F98A5CD32C675AAB6737A5F67176248B900C appName-1.0.1-full.nupkg 62177782 客户端收到数据发现有最新版本，又会请求feedURL/*.nupkg地址。所以服务端要响应相应的请求。 在Electron主进程加上if(require(&#39;electron-squirrel-startup&#39;)) return。作用是：如果在程序安装时、更新时以及卸载时启动程序，就直接返回（或者app.quit()）。即不启用程序（否则会报错） window更新注意： 安装包不能使用 NSIS，需要使用 Squirrel 更新需要 Squirrel 配套的 nupkg 包 服务端安装模块：yarn add koa koa-router koa-static-server compare-versions 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const Koa = require(&#x27;koa&#x27;)const app = new Koa()const Router - require(&#x27;koa-router&#x27;)const serve = require(&#x27;koa-static-server&#x27;)const compareVersions = require(&#x27;compare-versions&#x27;)// 获取最新版本通常会去查询数据库，这里就直接mock了function getNewVersion(version) &#123; if(!version) return null let maxVersion = &#123; name: &#x27;1.0.1&#x27;, pub_date: &#x27;2020-02-01T12:26:53+1:00&#x27;, notes: &#x27;新增功能AAA&#x27;, url: &#x27;http://128.0.0.1:33855/public/xxxx-1.0.1-mac.zip&#x27; &#125; if(compareVersions.compare(maxVersion.name, version, &#x27;&gt;&#x27;)) return maxVersion return null&#125;// for macrouter.get(&#x27;/darwin&#x27;, (ctx, next) =&gt; &#123; // 处理Mac更新，?version=1.0&amp;uid=123 let &#123;version&#125; = ctx.query let newVersion = getNewVersion(version) if(newVersion) &#123; ctx.body = newVersion &#125; else &#123; ctx.status = 204 // 204代表没有数据 &#125;&#125;)// for winrouter.get(&#x27;/win32&#x27;, (ctx, next) =&gt; &#123; let &#123;version&#125; = ctx.query let newVersion = getNewVersion(version) if(newVersion) &#123; ctx.body = &#x27;BBC6F23A34BC123BA123C900 xxxx-1.0.1-full.nupkg 62177782&#x27; &#125; else &#123; ctx.status = 204 // 204代表没有数据 &#125;&#125;)// 重定向去下载router.get(&#x27;/win32/*.nupkg&#x27;, (ctx, next) =&gt; &#123; ctx.redirect(`/public/$&#123;ctx.params[0].nupkg&#125;`)&#125;)app.use(server(rootDir: &#x27;public&#x27;, rootPath: &#x27;/public&#x27;))app.use(router.routes())app.listen(3385) Electron端123456789101112131415161718192021222324252627282930313233343536373839404142434445// update.jsconst &#123; autoUpdater, app, dialog &#125; = require(&#x27;electron&#x27;)if(process.platform === &#x27;darwin&#x27;) &#123; autoUpdater.setFeedURL(`http://127.0.0.1:33855/darwin?version=$&#123;app.getVersion()&#125;`)&#125; else &#123; autoUpdater.setFeedURL(`http://127.0.0.1:33855/win32?version=$&#123;app.getVersion()&#125;`)&#125;// 定时轮调 or 服务端推送autoUpdater.checkForUpdater()autoUpdater.on(&#x27;update-avaliable&#x27;, () =&gt; &#123; console.log(&#x27;update-avaliable&#x27;)&#125;)autoUpdater.on(&#x27;update-downloaded&#x27;, (e, notes, version) =&gt; &#123; app.whenReady().then(() =&gt; &#123; // 提示用户更新 let clickId = dialog.showMessageBoxSync(&#123; type: &#x27;info&#x27;, title: &#x27;升级提示&#x27;, message: &#x27;存在最新版，是否立即升级&#x27;, buttons: [&#x27;马上升级&#x27;, &#x27;取消&#x27;], cancelId: 1, // 手动重启 为 cancel &#125;) if(clickId === 0) &#123; autoUpdater.quiteAndInstall() &#125; &#125;) &#125;)autoUpdater.on(&#x27;error&#x27;, err =&gt; &#123; console.log(&#x27;error:&#x27;, error)&#125;)// main.jsconst isDev = require(&#x27;electron-is-dev&#x27;)if(require(&#x27;electron-squirrel-startup&#x27;)) app.quit()app.on(&quot;will-finish-launching&quot;, () =&gt; &#123; !isDev &amp;&amp; require(&#x27;./update.js&#x27;)&#125;) 使用Electron-Updaterelectron-updater是基于electron-builder的更新方案。 electron-updater模块简介12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const &#123; autoUpdater: updater &#125; = require(&#x27;electron&#x27;)// 设置更新服务器地址// options可以是一个url字符串 表示 安装包helatest.yml所在服务器地址// 也可以是个对象updater.setFeedURL(options) // 获取当前更新服务器地址updater.getFeedURL()// 检查更新，访问更新服务器地址// 调用checkForUpdates之前必须设置setFeedURL// 若有更新不会自动下载updater.checkForUpdates()// 检查更新，若有更新自会自动下载并通知updater.checkForUpdatesAndNotify()// 手动下载// 返回promiseupdater.downloadUpdate()// 此方法hui关闭所有应用窗口，然后自动调用app.quit()// 这个方法通常在 update-downloaded 事件触发后调用updater.quitAndInstall()// 更新通道// alpha beta lts等// 默认 latestupdater.channel = &#x27;latest&#x27;// checkForUpdates或 checkForUpdatesAndNotify调用后触发updater.on(&#x27;checking-for-update&#x27;, () =&gt; &#123; // TODO...&#125;)// 检查后，有最新版本时，触发updater.on(&#x27;update-available&#x27;, (info) =&gt; &#123; // TODO...&#125;)// 检查后，没有最新版本时，触发updater.on(&#x27;update-not-available&#x27;, () =&gt; &#123; // TODO...&#125;)// 下载过程中 轮调 触发updater.on(&#x27;download-progress&#x27;, (progress, bytesPerSecond, percent, total, transferred) =&gt; &#123; // TODO...&#125;)// 下载完成后触发updater.on(&#x27;update-downloaded&#x27;, (info) =&gt; &#123; // TODO...&#125;)// 更新发生错误时，触发updater.on(&#x27;error&#x27;, (error) =&gt; &#123; // TODO...&#125;) electro-updater的autoUpdater和electro内置的autoUpdater模块很相似，但前者比后者要强大不少，前者可以显示更新进度。 更新流程 几点补充： 在electron-builder打包配置中，一定要配置public字段，配置好后才能生成latest.yml文档。 123456&quot;publish&quot;: [ &#123; &quot;provider&quot;: &quot;generic&quot;, &quot;url&quot;: &quot;http://127.0.0.1:8000/&quot; // 放置安装包和latest.yml的服务器地址 &#125;], 将打包后的latest.yml以及安装包。放置到服务器上，可以使用nginx来搭建文件服务器。Electron检查更新就是检查这个latest.yml文件 Electron端123456789101112131415161718192021222324252627// update.jsconst &#123; autoUpdater: updater &#125; = require(&#x27;electron-updater&#x27;)updater.setFeedURL(&#x27;http://127.0.0.1:8000&#x27;)updater.checkForUpdatesAndNotify()updater.on(&#x27;update-available&#x27;, () =&gt; &#123; // TODO 可以在这提醒用户更新&#125;)updater.on(&#x27;download-progress&#x27;, (progress, bytesPerSecond, percent, total, transferred) =&gt; &#123; // TODO 显示进度条&#125;)updater.on(&#x27;update-downloaded&#x27;, () =&gt; &#123; updater.quitAndInstall()&#125;)updater.on(&#x27;error&#x27;, error =&gt; &#123; // TODO handle error&#125;)// main.jsapp.on(&quot;will-finish-launching&quot;, () =&gt; &#123; require(&#x27;./update.js&#x27;)&#125;) Nginx文件服务器123456789101112131415161718192021autoindex on;# 显示目录autoindex_exact_size on;# 显示文件大小autoindex_localtime on;# 显示文件时间server &#123; listen 8000 default_server; listen [::]:8000 default_server; server_name _; root /www/update/demo; # 文件路径 location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125;","categories":[{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/categories/Electron/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/tags/Electron/"},{"name":"桌面端软件","slug":"桌面端软件","permalink":"https://zxffan.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF%E8%BD%AF%E4%BB%B6/"}]},{"title":"浏览器中的音视频","slug":"Media/浏览器与音视频","date":"2020-07-14T16:00:00.000Z","updated":"2021-06-29T14:06:04.306Z","comments":true,"path":"posts/4dbf3745.html","link":"","permalink":"https://zxffan.github.io/posts/4dbf3745.html","excerpt":"","text":"浏览器如何采集摄像头和麦克风浏览器可以通过navigator上的mediaDevices属性来获取音视频流数据。navigator.mediaDevices返回一个MediaDevices对象 12345678910const constraints = &#123; audio: true, video: true,&#125;navigator.mediaDevices.getUserMedia(constraints).then(stream =&gt; &#123; videoElement.srcObject = stream videoElement.onloadedmetadata = () =&gt; &#123; videoElement.play() &#125;&#125;) 通过getUserMedia可以获取摄像头视频以及麦克风的音频，它接受一个MediaStreamConstraints对象作为参数。并返回一个MediaStream对象 12345678910111213const MediaStreamConstraints = &#123; video: &#123; frameRate: &#123;min: 20&#125;, // 帧率最小20 width: &#123;min: 640, ideal: 1280&#125;, // with最小640 理想1280 height: &#123;min: 360, ideal: 720&#125;, // 同理 aspectRatio: 16/9 // 宽高比 16 ：9 &#125;, audio: &#123; echoCancellation: true, // 回音消除 noiseSuppression: true, // 降噪 autoGainControl: true // 自动增益 &#125;&#125;; 具体参数见下表： 浏览器如何采集桌面navigator.mediaDevices还有一个getDisplayMedia方法，用来采集桌面（包括音视频）。用法和参数与getUserMedia一致 12345678910const constraints = &#123; audio: true, video: true,&#125;navigator.mediaDevices.getDisplayMedia(constraints).then(stream =&gt; &#123; videoElement.srcObject = stream videoElement.onloadedmetadata = () =&gt; &#123; videoElement.play() &#125;&#125;) 获取音视频设备列表1navigator.mediaDevices.enumerateDevices() 返回一个promise，结果是一个数组，包含一个个MediaDeviceInfo对象： deviceId：硬件表示，一个session内不会改变。可能会变 groupId：组标识。如果属于同一个物理设备，groupid一样。比如同一台显示其的内置相机和麦克风 kind：videoinput audioinput. audiooutput label：设备描述，例如&quot;External USB Webcam&quot; 如何录制流录制音视频流需要通过MediaRecorder对象 下例是录制麦克风 123456789101112131415161718let recordernavigator.mediaDevices.getUserMedia(constraints).then(stream =&gt; &#123; const mimeType = &#x27;video/mp4&#x27; if (MediaRecorder.isTypeSupported(mimeType)) &#123; // 判断是否支持该类型 recorder = new MediaRecorder(stream, &#123; audioBitsPerSecond : 128000, // 音频的比特率 128kbps videoBitsPerSecond : 2500000, // 视频的比特率 2.5Mbps mimeType &#125;) // 当recorder.stop() 调用后， 触发该事件 recorder.ondataavailable = e =&gt; &#123; // e.data blob对象 // ... &#125; recorder.start() &#125;&#125;) 如何解析音频有时候会遇到音频可视化的需求，比如播放器可能会显示音频的波形。这时就需要借助AudoContext对象来实现。 直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;title&gt;audio analyser&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; navigator.mediaDevices .getUserMedia(&#123; audio: true, &#125;) .then((stream) =&gt; &#123; // 获取麦克风的音频流 const audioCtx = new AudioContext(); const source = audioCtx.createMediaStreamSource(stream); // 创建 音频分析器 const analyser = audioCtx.createAnalyser(); analyser.fftSize = 2048; const bufferLength = analyser.frequencyBinCount; // 音频数据会放在 dataArray中 const dataArray = new Uint8Array(bufferLength); source.connect(analyser); analyser.connect(audioCtx.destination); function draw() &#123; const canvas = document.querySelector(&quot;#canvas&quot;); const ctx = canvas.getContext(&quot;2d&quot;); const WIDTH = canvas.width; const HEIGHT = canvas.height; // 取出音频数据，放到dataArray中 analyser.getByteTimeDomainData(dataArray); // ** 绘制波形 start ctx.fillStyle = &quot;rgb(200, 200, 200)&quot;; ctx.fillRect(0, 0, WIDTH, HEIGHT); ctx.lineWidth = 1; ctx.strokeStyle = &quot;rgb(0, 0, 0)&quot;; var sliceWidth = (WIDTH * 1.0) / bufferLength; var x = 0; ctx.beginPath(); for (var i = 0; i &lt; bufferLength; i++) &#123; let v = dataArray[i] / 128.0, y = (v * HEIGHT) / 2; if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y); x += sliceWidth; &#125; ctx.lineTo(canvas.width, canvas.height / 2); ctx.stroke(); // ** 绘制波形 end requestAnimationFrame(draw); // 绘制下一帧 &#125; draw(); &#125;) .catch((err) =&gt; &#123; console.log(err); &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Media","slug":"Media","permalink":"https://zxffan.github.io/categories/Media/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"网络","slug":"网络","permalink":"https://zxffan.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"WebRTC","slug":"WebRTC","permalink":"https://zxffan.github.io/tags/WebRTC/"},{"name":"audio","slug":"audio","permalink":"https://zxffan.github.io/tags/audio/"},{"name":"video","slug":"video","permalink":"https://zxffan.github.io/tags/video/"}]},{"title":"WebRTC Introduction","slug":"Media/webRTC_introduction","date":"2020-07-07T16:00:00.000Z","updated":"2021-06-29T14:06:06.591Z","comments":true,"path":"posts/c51bfcb4.html","link":"","permalink":"https://zxffan.github.io/posts/c51bfcb4.html","excerpt":"","text":"webRTC简介什么是webRTC？网络实时通信（Web Real Time Communication），用来实现浏览器之间的实时通信。通常用来传输音视频流，实现视频聊天、直播等功能。 兼容性 ie？ie就不应该有这种需求！！ webRTC中涉及到的概念 sdp：sdp描述了各端的能力（例如支持的音视频解放、传输协议等信息）。建立webRTC连接时，两端会交换对方的sdp。这样就知道对方的信息。 offer：通常先发送sdp一方的sdp被称为offer answer：另一方收到offer后发送的sdp被称为answer ice candidate：包含了 WebRTC 与远端通信时使用的协议、IP 地址和端口等数据。当双端交换完sdp数据后，就会收集candidate信息。同样双端也要交换candidate数据 NAT： 网络地址转换。由于ipv4地址不够用，我们的个人pc在本地使用的是内网ip（例如:192.168.1.2）。当访问公网上的资源是，请求经过路由器时，会将内网地址转换成公网地址，再发给目的服务器 p2p：点对点（peer to peer）。指连接双端直接通信，不需要经过中间服务器。webRTC就能实现p2p，只有当p2p失败才会采用服务器中继 建立连接连接流程 编码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// A 端function sendToB() &#123; // ...发送给B&#125;function onMsgFromB(callback) &#123; // 获得来自B的数据&#125;function getStreamFromA() &#123; // 获取A的音视频流&#125;// 1. 先建立rtc连接const pc = new RTCpeerConnection()// 2. 添加音视频流const stream = getStreamFromA()for (const track of stream.getTracks()) &#123; pc.addTrack(track);&#125;// 3. 创建offerpc.createOffer().then(offer =&gt; &#123; // 4.设置本地 pc.setLocalDescription(offer) // 5. 将offer发送给B sendToB(&#123;type: &#x27;offer&#x27;, data: offer&#125;)&#125;)onMsgFromB((&#123;type, data&#125;) =&gt; &#123; if(type === &#x27;answer&#x27;) &#123; // 12.设置远程answer pc.setRemoteDescription(data) &#125;&#125;)pc.ontrack = (e) =&gt; &#123; const stream = e.streams[0] video.srcObject = stream // 播放流&#125;// B端function sendToA() &#123; // ...发送给A&#125;function onMsgFromA(callback) &#123; // 获得来自A的数据&#125;function getStreamFromA() &#123; // 获取B的音视频流&#125;// 6. 先建立rtc连接const pc = new RTCpeerConnection()// 7. 添加音视频流const stream = getStreamFromA()for (const track of stream.getTracks()) &#123; pc.addTrack(track);&#125;onMsgFromB((&#123;type, data&#125;) =&gt; &#123; if(type === &#x27;offer&#x27;) &#123; // 8. 设置offer pc.setRemoteDescription(data) // 9.创建answer pc.createAnswer().then(answer =&gt; &#123; // 10.设置本地 pc.setLocalDescription(answer) // 11. 将answer发送给A sendToB(&#123;type: &#x27;answer&#x27;, data: answer&#125;) &#125;) &#125;&#125;)pc.ontrack = (e) =&gt; &#123; const stream = e.streams[0] video.srcObject = stream // 播放流&#125; 添加流用的是addTrack没有使用addStream（即将废弃）。addtrack 和 ontrack 是最新的API。 视频流的获取，请参考另一篇文章浏览器中的音视频 candidate双端交换sdp后，并未真正建立连接。然后还需要收集双方的candidate（不止一个哦）并交换。然后浏览器会按照candidate列表逐一测试连通性，直到有一条candidate连接，webRTC连接才算真正的建立。 连接流程 STUN和TURN下面会展开，暂且理解为部署在服务器上的服务，用来获取数据生成candidate的。 编码12345678910111213141516171819202122232425262728293031323334// 基于上面修改// 1. 请求， RTCpeerConnection会自己做// A 端// 2. 服务器（STUN/TURN）返回candidatepc.onicecandidate = (iceEvent) =&gt; &#123; // 3. 发送iceEvent(或者直接发送candidate也可以)给B端 sendToB(&#123;type: &#x27;candidate&#x27;, data: iceEvent&#125;)&#125;onMsgFromB((&#123;type, data&#125;) =&gt; &#123; // ... if(type === &#x27;candidate&#x27;) &#123; pc.addIceCandidate(data.candidate) &#125;&#125;)// B 端// 5. 服务器（STUN/TURN）返回candidatepc.onicecandidate = (iceEvent) =&gt; &#123; // 6. 发送iceEventf给A端 sendToA(&#123;type: &#x27;candidate&#x27;, data: iceEvent&#125;)&#125;onMsgFromB((&#123;type, data&#125;) =&gt; &#123; // ... if(type === &#x27;candidate&#x27;) &#123; // 4. 设置A端发来的的candidate pc.addIceCandidate(data.candidate) &#125;&#125;) STUN/TURNSTUN和TURN是两个服务，RTCPeerConnection会自动请求这两个服务来获取candidate。 12345678910111213// 基于上面的代码// A端 &amp; B端// 建立RTCpeerConnection时，配置服务地址const pc = new RTCpeerConnection(&#123; iceServers: [ &#123; urls: &quot;stun:47.94.xxx.xx:3478&quot; &#125;, &#123; urls: &quot;turn:47.94.xxx.xx:3478&quot;, username: &quot;usrname&quot;, credential: &quot;password&quot; &#125;, ],&#125;) STUN两个处于不同网段的客户端需要点对点通信必须知道对方的公网ip，并且在双方的NAT映射表中必须有一条映射记录。STUN服务用来获取公网地址。处于不同网段的两台客户端，需要访问STUN服务来获取其公网地址。 TURN当点对点通信失败后，将会采用中继的方式。也就是数据走服务器转发。TURN就是用来实现中继的。 部署STUN/TURNconturn应该是比较知名的STUN/TURN服务器。 如何部署请自行查阅资料，或参考官方git repo candidate列表以下测试，A端（192.168.1.134）和B端（192.168.1.134）都是我本机。 webRTC的candidate分为三类 host 类型，即本机内网的 IP 和端口 srflx 类型, 即本机 NAT 映射后的外网的 IP 和端口 relay 类型，即中继服务器的 IP 和端口 webRTC会先测试host类型的candidate。这种类型时最容易收集的。就算没有配置STUN/TURN也能收集到。如果测通了就没必要往下测试了。 srflx类型的candidate包含公网ip信息。它是从stun服务器获取的。 当前两种都没连通，就会测试relay类型的candidate，也就是通过turn服务进行中继。 信令服务前面写了这么一段代码 123456789// A端function sendToB() &#123; // ...发送给B&#125;function onMsgFromB(callback) &#123; // 获得来自B的数据&#125;// B端同理 埋了一个伏笔，sendToB如何实现。答案就是信令服务 概念信令服务就是在通信的双端之间搭建的一个用于建立webRTC连接的服务，用于转发sdp、candidate等。 信令服务可以是一个webSocket服务，用来进行A、B端之间的媒体协商。 媒体协商就是指交换sdp和candidate的过程 流程 编码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const WebSocket = require(&quot;ws&quot;);const wss = new WebSocket.Server(&#123; port: 3001 &#125;);const code2Ws = new Map();wss.on(&quot;connection&quot;, (ws, request) =&gt; &#123; ws.isAlive = true; let code; ws.sendData = (event, data) =&gt; &#123; ws.send(JSON.stringify(&#123; event, data &#125;)); &#125;; ws.sendError = (msg) =&gt; ws.sendData(&quot;error&quot;, msg); ws.on(&quot;message&quot;, (message) =&gt; &#123; try &#123; const parsedMsg = JSON.parse(message); const &#123; event, data &#125; = parsedMsg; switch (event) &#123; case &quot;login&quot;: // 为客户端生成唯一标识，也可以由客户端发送标识（如mac地址） code = data.code || Math.floor(Math.random() * (9999999 - 1000000)) + 100000 + &quot;&quot;; code2Ws.set(code, ws); // 记录 ws.sendData(&quot;login&quot;, &#123; code &#125;); // 范围标识 break; case &quot;communicate&quot;: const remote = data.remote; // 需要通信的客户端标识 if (code2Ws.has(remote)) &#123; // 存在就建立两端之间的映射关系 ws.sendData(&quot;communicate&quot;, &#123; success: true &#125;); // 通知A端 ws.sendRemote = code2Ws.get(remote).sendData; code2Ws.get(remote).sendRemote = ws.sendData; ws.sendRemote(&quot;communicate&quot;, &#123; remote: code &#125;); // 通知B端 &#125; else &#123; ws.sendData(&quot;communicate&quot;, &#123; success: false &#125;); // 没有，则通知A，失败 &#125; break; case &quot;forward&quot;: ws.sendRemote &amp;&amp; ws.sendRemote(data); // 转发消息 break; &#125; &#125; catch (e) &#123; ws.sendError(&quot;message invalid&quot;); return; &#125; &#125;); // 连接关闭 就删除当前客户端的标识 ws.on(&quot;close&quot;, () =&gt; &#123; code2Ws.delete(code); &#125;);&#125;);// 定时检测连接const interval = setInterval(function ping() &#123; wss.clients.forEach(function each(ws) &#123; if (ws.isAlive === false) return ws.terminate(); ws.isAlive = false; &#125;);&#125;, 5 * 60 * 1000);wss.on(&quot;close&quot;, function close() &#123; clearInterval(interval);&#125;); 数据通道（RTCDataChannel）媒体协商一旦完成就可以关闭与信令服务的连接即关闭webSocket连接。之后的数据传输可以通过数据通道来传输。 概念建立webRTC连接的两端能够开辟一个数据通道，用来传输非音视频流数据，比如文字聊天、文件传输、远程桌面、游戏控制、P2P 加速等。 双向通信RTCDataChannel可以实现双向通信，有两种模式 In-band(默认)：假设通信双方中的一方调用 createDataChannel 创建 RTCDataChannel 对象时，将 options 参数中的 negotiated 字段设置为 false，则通信的另一方就可以通过它的 RTCPeerConnection 对象的 ondatachannel 事件来得到与对方通信的 RTCDataChannel 对象了，这种方式就是 In-band 协商方式。 out-of-band：这种方式不再是一端调用 createDataChannel，另一端监听 ondatachannel 事件，从而实现双方的数据通信；而是两端都调用 createDataChannel 方法创建 RTCDataChannel 对象，再通过 ID 绑定来实现双方的数据通信。 实现In-band123456789101112131415161718192021222324// A端const pc = new RTCPeerConnection();const dc = pc.createDataChannel(&quot;my channel&quot;, &#123; negotiated: true &#125;);dc.onmessage = function (event) &#123; console.log(&quot;received: &quot; + event.data);&#125;;dc.onopen = function () &#123; console.log(&quot;datachannel open&quot;); ds.send(&quot;hello!&quot;)&#125;;dc.onclose = function () &#123; console.log(&quot;datachannel close&quot;);&#125;;// B端pc.ondatachannel = (e) =&gt; &#123; const dc = e.channel // 获取 dc.onmessage = (e) =&gt; &#123; console.log(e.data) &#125;;&#125;; out-of-band12345678910111213141516171819202122232425262728293031// A 端const pc = new RTCPeerConnection();const dc = pc.createDataChannel(&quot;my channel&quot;, &#123; negotiated: true, id: 0 &#125;);dc.onmessage = function (event) &#123; console.log(&quot;received: &quot; + event.data);&#125;;dc.onopen = function () &#123; console.log(&quot;datachannel open&quot;);&#125;;dc.onclose = function () &#123; console.log(&quot;datachannel close&quot;);&#125;;// B 端const pc = new RTCPeerConnection(&#123; negotiated: true, id: 0 &#125;);const dc = pc.createDataChannel(&quot;my channel&quot;);dc.onmessage = function (event) &#123; console.log(&quot;received: &quot; + event.data);&#125;;dc.onopen = function () &#123; console.log(&quot;datachannel open&quot;);&#125;;dc.onclose = function () &#123; console.log(&quot;datachannel close&quot;);&#125;; 注意：RTCDataChannel对象需要在媒体协商前创建。 WebRTC背后的原理UDPWebRTC使用的是UDP协议。这是为了保证实时性。TCP有超时重传机制，这回导致很高的传输延迟。 编码帧通过编码器（如 H264/H265、VP8/VP9）压缩后的帧称为编码帧。这里我们以 H264 为例，经过 H264 编码的帧包括以下三种类型。 I 帧：关键帧。压缩率低，可以单独解码成一幅完整的图像。 P 帧：参考帧。压缩率较高，解码时依赖于前面已解码的数据。 B 帧：前后参考帧。压缩率最高，解码时不光依赖前面已经解码的帧，而且还依赖它后面的 P 帧。换句话说就是，B 帧后面的 P 帧要优先于它进行解码，然后才能将 B 帧解码。 解码过后的帧叫做非编码帧 RTP一般情况下，在实时互动直播系统传输音视频数据流时，我们并不直接将音视频数据流交给 UDP 传输，而是先给音视频数据加个 RTP 头，然后再交给 UDP 进行传输。 这是因为一个I帧数据量是很大的。一个UDP报文是无法全部传输完的。所以发送是需要拆分并要加上首部，在接收的时候再组装 RTCPUDP是不可靠传输，所以在使用 RTP 包传输数据时，难免会发生丢包、乱序、抖动等问题。 RTCP协议则负责流媒体的传输质量保证，提供流量控制和拥塞控制等服务。在RTP会话期间，各参与者周期性彼此发送RTCP报文。报文中包含各参与者数据发送和接收等统计信息，参与者可以据此动态控制流媒体传输质量 RTCDataChannel RTCDataChannel使用的是SCTP协议（底层也是基于UDP），它基于UDP实现了流量控制和拥塞控制等功能。而且它可以配置UDP报文传输的有序性和可靠性 123456var dc = pc.createDataChannel(&quot;dc&quot;, &#123; ordered: false, // 是否有序 maxPacketLifeTime: 3000,// 重传消息失败的最长时间。也就是说超过这个时间后，即使消息重传失败了也不再进行重传了。 maxRetransmits: 10, // 重传消息失败的最大次数 &#125;); //创建 RTCDataChannel对象 通信数据 通过浏览器（chrome），可以查看通信质量信息chrome://webrtc-internals 调用RTCPeerConnection对象的getStats方法获取数据 12345678//获得速个连接的统计信息//在一个连接中有很多 reportpc.getStats().then(reports =&gt; &#123; //遍历每个 report reports.forEach(report =&gt; &#123; //将每个 report 的详细信息打印出来 console.log(report); &#125;);&#125;).catch( err=&gt;&#123; console.error(err); &#125;);); 只获取与发送/接受相关的数据 1234567891011121314var pc = new RTCPeerConnection(null);//从 PC 上获得 sender 对象var sender = pc.getSenders()[0];//调用sender的 getStats 方法 sender.getStats() .then(reports =&gt; &#123; //得到相关的报告 reports.forEach(report =&gt;&#123; //遍历每个报告 if(report.type === &#x27;outbound-rtp&#x27;)&#123; //如果是rtp输出流 // .... &#125; &#125;); 质量指标 packetsSent/packetsRecived：发送/接受包的数量，计算丢包率","categories":[{"name":"Media","slug":"Media","permalink":"https://zxffan.github.io/categories/Media/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"网络","slug":"网络","permalink":"https://zxffan.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"WebRTC","slug":"WebRTC","permalink":"https://zxffan.github.io/tags/WebRTC/"}]},{"title":"正则表达式","slug":"JavaScript/正则表达式","date":"2020-06-30T16:00:00.000Z","updated":"2021-06-29T14:05:22.936Z","comments":true,"path":"posts/2f57a694.html","link":"","permalink":"https://zxffan.github.io/posts/2f57a694.html","excerpt":"","text":"REGEXP对象两种实例化RegExp对象 字面量 构造函数 12345678910111213141516// 字面量var reg = /\\bis\\b/ // \\b表示单词边界&#x27;He is a boy. This is a dog. Where is she?&#x27;.replace(reg, &#x27;IS&#x27;) // 只会替换一处// He IS a boy. This is a dog. Where is shereg = /\\bis\\b/g // g 代表 global&#x27;He is a boy. This is a dog. Where is she?&#x27;.replace(reg, &#x27;IS&#x27;) // 指挥替换一处// He IS a boy. This IS a dog. Where IS she// 构造函数var reg = new RegExp(&#x27;\\\\bis\\\\b&#x27;, &#x27;g&#x27;)&#x27;He is a boy. This is a dog. Where is she?&#x27;.replace(reg, &#x27;IS&#x27;) // 指挥替换一处// He IS a boy. This IS a dog. Where IS she 修饰符 g：global 全文搜索 i：忽略大小写 m：多行搜索 元字符正则表达式有两种基本字符类型组成 愿意文本字符 abc 元字符（含有特殊含义的非字母字符） 字符类元字符[]来构建一个类，来匹配一类字符 [abc]来匹配a或b或c ^可以创建反向类，[^abc]表示不是a或b或c的字符 范围类[a-z]表示a到z的任意字符（包含a和z） [a-zA-z] [0-9] [0-9-]匹配0到9和横线- 预定义类 字符 等价类 含义 . [^\\r\\n] 除了回车符和换行符之外的所有字符 \\d [0-9] 数字字符 \\D [^0-9] 非数字字符 \\s [\\t\\n\\x0B\\f\\r] 空白符 \\S [^\\t\\n\\x0B\\f\\r] 非空白符 \\w [a-zA-Z_0-9] 单词字符（数字、字母下划线） \\W [^a-zA-Z_0-9] 非单词字符 边界 字符 含义 ^ 以xxx开始 $ 以xxx结束 \\b 单词边界 \\B 非单词边界 量词 字符 含义 ？ 出现零次或一次 + 出现一次或多次 * 出现零次或多次（任意次） {n} 出现n次 {n,m} 出现n到m次 {n,} 至少出现n次 贪婪模式和非贪婪模式123456&#x27;12345678&#x27;.replace(/\\d&#123;3,6&#125;/g, &#x27;X&#x27;) // 会尽量多地匹配-贪婪模式// X78// 在量词后面加上?-非贪婪模式&#x27;12345678&#x27;.replace(/\\d&#123;3,6&#125;?/g, &#x27;X&#x27;) // 非贪婪模式// XX78 分组使用()实现分组的功能 12345&#x27;a1b2c3d4&#x27;.replace(/[a-z]\\d&#123;3&#125;/g, &#x27;X&#x27;)// a1b2c3d4&#x27;a1b2c3d4&#x27;.replace(/([a-z]\\d)&#123;3&#125;/g, &#x27;X&#x27;)// Xd4 或使用|可以实现或的效果 反向引用2015-12-25 =&gt; 12-25-2015 12&#x27;2015-12-25&#x27;.replace(/(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/g, &#x27;$2-$3-$1&#x27;)// 12-25-2015 忽略分组使用?:来忽略分组 (?:Byron).(ok) $1指的是 ok 断言正则表达式从文本头部向尾部开始解析，文本尾部方向，成为“正向” 正向断言就是在正则表达式匹配到规则的时候，向前检查是否符合断言 JavaScript不支持反向断言 ES2018（ES9）新增反向断言 符合和不符合特定断言成为肯定/正向匹配和否定/反向匹配 名称 正则 含义 正向断言 exp(?=assert) 否定正向断言 exp(?!assert) 反向断言 exp(?&lt;=assert) 否定反向断言 exp(?&lt;!assert) 123456789101112&#x27;a2*34v8&#x27;.replace(/\\w(?=\\d)/g, &#x27;X&#x27;)// X2*34X8&#x27;a2*34vv&#x27;.replace(/\\w(?!\\d)/g, &#x27;X&#x27;)// aX*3XXXvar match = /(?&lt;=\\D)\\d+/.exec(&#x27;$123.89&#x27;)console.log( match[0] ); // 123var match = /(?&lt;!\\D)\\d+/.exec(&#x27;$123.89&#x27;)console.log( match[0] ); // 23 对象属性global: 是否全文搜索，默认false ignore case：是否大小写敏感，默认false multiline：多行搜索，默认false lastIndex：是当前白表达式匹配内容最后一个字符的下一个位置 source：正则表达式的文本字符串 正则表达式的方法test方法检测字符串中是否有匹配正则的内容，若有返回true，没有返回false 1234567891011var reg1 = /\\w/var reg2 = /\\w/greg1.test(&#x27;a&#x27;) // truereg2.test(&#x27;$&#x27;) // falsewhile(reg2.test(&#x27;ab&#x27;)) &#123; console.log(reg2.lastIndex)&#125;// 1// 2 坑 使用test时，正则表达式不要使用g（全局匹配），如下 123456789101112var reg = /\\w/gundefinedreg.test(&quot;wom&quot;)// truereg.test(&quot;wom&quot;)// truereg.test(&quot;wom&quot;)// truereg.test(&quot;wom&quot;)// falsereg.test(&quot;wom&quot;)// true 第四次匹配变成了false，这是因为每次匹配都会改变reg的lastIndex属性。下次匹配在从lastIndex位置开始匹配。第四次匹配前lastIndex为3，从index为3的位置开启匹配所以匹配不到，这次匹配完后lastIndex又改成0所以下次又能匹配到。 exec方法未匹配到返回null，匹配到返回一个结果数组 返回的数组 第一个元素是与正则表达式相匹配的文本 第二个元素是与RegExpObject的第一个子表达式相匹配的文本（如果有的话），子表达式就是分组，也就是指分组匹配的文本 第三个元素是与RegExp对象的第二个子表达式相匹配的文本（如果有的话），依此类推 123456789101112131415161718192021222324var reg1 = /\\d(\\w)(\\w)\\d/var reg2 = /\\d(\\w)(\\w)\\d/gvar ts = &quot;ab1cd2fg3hi4jk5mop&quot;// 非全局匹配-不存在lastIndexvar ret = reg1.exec(ts)console.log(ret)/* 输出 [&quot;1cd2&quot;, &quot;c&quot;, &quot;d&quot;, index: 2, input: &quot;ab1cd2fg3hi4jk5mop&quot;, groups: undefined]*/// 全局匹配-需要循环，每次匹配修改lastIndex的值var retwhile(ret = reg2.exec(ts)) &#123; console.log(ret)&#125;/*[&quot;1cd2&quot;, &quot;c&quot;, &quot;d&quot;, index: 2, input: &quot;ab1cd2fg3hi4jk5mop&quot;, groups: undefined][&quot;3hi4&quot;, &quot;h&quot;, &quot;i&quot;, index: 8, input: &quot;ab1cd2fg3hi4jk5mop&quot;, groups: undefined]*/ 字符串对象的方法search方法search()用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串 方法返回第一个匹配结果index，查不到返回-1 match方法match()方法将检索字符串，以找到一个或多个与regexp匹配的文本 regexp是否具有标志g对结果影响很大， 如果regexp没有标志位g，那么match（）方法就只能在字符串中执行一次匹配如果没有找到任何匹配的文本，将返回null 1234567var reg1 = /\\d(\\w)(\\w)\\d/var reg2 = /\\d(\\w)(\\w)\\d/gvar ts = &quot;ab1cd2fg3hi4jk5mop&quot;ts.match(reg1)//[&quot;1cd2&quot;, &quot;c&quot;, &quot;d&quot;, index: 2, input: &quot;ab1cd2fg3hi4jk5mop&quot;, groups: undefined] 否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息 12ts.match(reg2)// [&quot;1cd2&quot;, &quot;3hi4&quot;] split方法12&#x27;a1b2c3d4&#x27;.split(/\\d/)// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;] replace方法12345678910111213141516&#x27;a1b&#x27;.replace(&#x27;1&#x27;, 2) // a2b&#x27;a1b1c1&#x27;.replace(&#x27;1&#x27;, &#x27;2&#x27;) // a2b1c1&#x27;a1b1c1&#x27;.replace(/1/g, &#x27;2&#x27;) // a2b2c2&#x27;a1b2c3d4&#x27;.replace(/\\d/g, function(match, index, origin) &#123; console.log(match,index,origin); return +match + 1&#125;)/*1 1 a1b2c3d42 3 a1b2c3d43 5 a1b2c3d44 7 a1b2c3d4&quot;a2b3c4d5&quot;*/ 手撕题数字千分位表示12345var a = &quot;139553123.123123123&quot;// 由两部分组成// 前半部分 否定反向断言：排除有. 从而让小数部分不加逗号// 后半部分 正向断言：3个一组 以.或者边界结尾a.replace(/(?&lt;=\\b(?&lt;!\\.)\\d*)\\B(?=(\\d&#123;3&#125;)+(\\b|\\.))/g, &quot;,&quot;) // &quot;139,553,123.123123123&quot; 处理日期格式12&quot;yyyy日MM月dd天 hh:mm:ss&quot;.split(/(?&lt;=[^yMdhms])|(?=[^yMdhms])/g)// [&quot;yyyy&quot;, &quot;日&quot;, &quot;MM&quot;, &quot;月&quot;, &quot;dd&quot;, &quot;天&quot;, &quot; &quot;, &quot;hh&quot;, &quot;:&quot;, &quot;mm&quot;, &quot;:&quot;, &quot;ss&quot;]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/categories/JavaScript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"regExp","slug":"regExp","permalink":"https://zxffan.github.io/tags/regExp/"}]},{"title":"HTTPS工作流程","slug":"Network/HTTPS工作流程","date":"2020-04-01T16:00:00.000Z","updated":"2021-06-29T14:06:27.573Z","comments":true,"path":"posts/ef0f9b3a.html","link":"","permalink":"https://zxffan.github.io/posts/ef0f9b3a.html","excerpt":"","text":"HTTP与HTTPSHTTP(超文本传输协议)，有着一个致命的缺陷，那就是内容是明文传输的，没有经过任何加密，而这些明文数据会经过WiFi、路由器、运营商、机房等多个物理设备节点，如果在这中间任意一个节点被监听，传输的内容就会完全暴露，，这一攻击手法叫做MITM（Man In The Middle）中间人攻击。 常见的如运行商劫持，推送广告 HTTPS工作流程 客户端发送HTTPS请求（默认端口443） 服务端有一套CA数字证书，证书含有一个公钥public。服务端接收到请求，会将这个证书发送给客户端。服务端还有一个私钥private，私钥是一直保存再服务端不公开的。 客户端收到证书，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续。 客户端先生成一段随机key，再利用证书中的公钥public加密这段随机key，并将这个随机key密文发送给服务端。 服务端收到这个随机key密文文后，通过私钥private来解密，获取客户端真正的随机key 服务端使用随机key来加密需要传输的HTTP数据，并发送给客户端 客户端再用随机key来解密服务端传输过来的密文，获取真正的数据 后续HTTPS请求使用之前交换好的随机Key进行对称加解密。 由于随机key明文没有再网络上传输，所以”中间人”并不知道用于加密和解密的随机key，因此是安全的 对称加密和非对称加密HTTPS的工作流程其实就是 非对称加密+对称加密。 非对称加密：公钥加密，私钥解密 对称加密：随机key加密解密 非对称加解密耗时要远大于对称加解密，对性能有很大损耗 CA颁发机构上述的HTTPS工作流程中的CA证书验证十分重要。如果没有它，会发生以下情况： 服务端发送公钥A1给客户端，中间人把服务端的公钥替换为自己的公钥B1 客户端通过公钥B1加密生成K密文，并发送给服务端 中间人通过自己的私钥B2解密K密文得到K，再用公钥A1加密，发送给服务端 客户端与服务端通信的K，已被中间人获取，所以不再安全 出现这一问题的核心原因是客户端无法确认收到的公钥是不是真的是服务端发来的。为了解决这个问题，互联网引入了一个公信机构，这就是CA。 CA机构拥有自己的一对公钥和私钥 CA机构在颁发证书时对证书明文信息进行哈希 将哈希值用私钥进行加签，得到数字签名 明文数据和数字签名组成证书，传递给客户端。 客户端得到证书，分解成明文部分Text和数字签名Sig1 用CA机构的公钥进行解签，得到Sig2（由于CA机构是一种公信身份，因此在系统或浏览器中会内置CA机构的证书和公钥信息） 用证书里声明的哈希算法对明文Text部分进行哈希得到T 当自己计算得到的哈希值T与解签后的Sig2相等，表示证书可信，没有被篡改","categories":[{"name":"NetWork","slug":"NetWork","permalink":"https://zxffan.github.io/categories/NetWork/"}],"tags":[{"name":"NetWork","slug":"NetWork","permalink":"https://zxffan.github.io/tags/NetWork/"},{"name":"HTTP","slug":"HTTP","permalink":"https://zxffan.github.io/tags/HTTP/"}]},{"title":"手写webpack的plugin","slug":"engineering/手写webpack的plugin","date":"2020-03-24T16:00:00.000Z","updated":"2021-06-29T14:04:43.373Z","comments":true,"path":"posts/b6d2303e.html","link":"","permalink":"https://zxffan.github.io/posts/b6d2303e.html","excerpt":"","text":"概述 一句话：本质上来说， plugin 就是通过监听 compiler 的某些 hook 特定时机，然后处理 stats。 首先我们来看下 Webpack 插件需要包含的几个条件： Webapck 的插件必须要是一个类； 该类必须包含一个 apply 的函数，该函数接收 compiler 对象参数； 该类可以使用 Webpack 的 compiler 和 Compilation 对象的钩子； 也可以自定义自己的钩子系统。 123456789101112131415161718192021class MyPlugin &#123; constructor(options) &#123; // 自定义配置 this.options = options &#125; apply(compiler) &#123; compiler.hooks.done.tap(&#x27;MyPlugin&#x27;, () =&gt; &#123;&#125;) compiler.hooks.emit.tapPromise(&#x27;MyPlugin&#x27;, compilation =&gt; &#123; // 返回一个 Promise，在我们的异步任务完成时 resolve…… return new Promise((resolve, reject) =&gt; &#123; setTimeout(function() &#123; console.log(&#x27;异步工作完成……&#x27;); resolve(); &#125;, 1000); &#125;); &#125;); &#125;&#125;module.exports = MyPlugin 官方DEMO——FileListPlugin123456789101112131415161718192021222324252627class FileListPlugin &#123; apply(compiler) &#123; // emit 是异步 hook，使用 tapAsync 触及它，还可以使用 tapPromise/tap(同步) compiler.hooks.emit.tapAsync(&#x27;FileListPlugin&#x27;, (compilation, callback) =&gt; &#123; // 在生成文件中，创建一个头部字符串： var filelist = &#x27;In this build:\\n\\n&#x27;; // 遍历所有编译过的资源文件， // 对于每个文件名称，都添加一行内容。 for (var filename in compilation.assets) &#123; filelist += &#x27;- &#x27; + filename + &#x27;\\n&#x27;; &#125; // 将这个列表作为一个新的文件资源，插入到 webpack 构建中： compilation.assets[&#x27;filelist.md&#x27;] = &#123; source: function() &#123; return filelist; &#125;, size: function() &#123; return filelist.length; &#125; &#125;; callback(); &#125;); &#125;&#125; 自定义 Plugin——prefetch-webpack-plugin实现目标假如我们有个 lazy.js 模块需要 Prefetch，那么可以直接使用如下配置 12// 下面是魔法注释 （magic comments）import(/* webpackPrefetch: true */ &#x27;./lazy&#x27;); 有了这个注释，在获取 chunk 对象的时候，就可以拿到它的这个标注，从而根据这个注释给页面增加&lt;link rel=&quot;prefetch&quot;&gt;标签。 Tips： /* webpackPrefetch: true */ ：把主加载流程加载完毕，在空闲时在加载其它，等再点击其他时，只需 要从缓存中读取即可，性能更好，推荐使用；能够提高代码利用率，把一些交互后才能用到的代码写到异 步组件里，通过懒加载的形式，去把这块的代码逻辑加载进来，性能提升，页面访问速度更快；* /* webpackPreload: true */ : 和主加载流程一起并行加载。 原理和实现步骤 首先我们应该利用compiler.compilation这个钩子，得到Compilation对象； 然后在Compilation对象中监听 html-webpack-plugin 的钩子，拿到 HTML 对象，这里需要区分 html-webpack-plugin 的版本： 在3.x版本，html-webpack-plugin 的钩子是直接挂在 Compilation 对象上的，我们使用的是compilation.hooks.htmlWebpackPluginAfterHtmlProcessing； 在4.x版本（截稿最新版本是 4.0-beta.3）中，html-webpack-plugin 自己使用Tapable实现了自定义钩子，需要使用HtmlWebpackPlugin.getHooks(compilation)的方式获取自定义的钩子。 然后我们从Compilation对象中读取当前 HTML 页面的所有chunks，筛选异步加载的 chunk 模块，这里有两种情况： 生成多个 HTML 页面，那么 html-webpack-plugin 插件会设置chunks选项，我们需要从 Compilation.chunks来选取 HTML 页面真正用到的 chunks，然后在从 chunks 中过滤出 Prefetch chunk； 如果是单页应用，那么不存在chunks选项，这时候默认chunks=&#39;all&#39;，我们需要从全部 Compilation.chunks 中过滤出 Prefetch chunk。 最后结合 Webpack 配置的publicPath得到异步 chunk 的实际线上地址，然后修改 html-webpack-plugin 钩子得到的 HTML 对象，给 HTML 的添加内容。","categories":[{"name":"工程化","slug":"工程化","permalink":"https://zxffan.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"https://zxffan.github.io/tags/webpack/"},{"name":"架构","slug":"架构","permalink":"https://zxffan.github.io/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"手写webpack的loader","slug":"engineering/手写webpack的loader","date":"2020-03-22T16:00:00.000Z","updated":"2021-06-29T14:04:40.376Z","comments":true,"path":"posts/e0efe5dc.html","link":"","permalink":"https://zxffan.github.io/posts/e0efe5dc.html","excerpt":"","text":"概述webpack的loader本质上就是一个函数 12345module.exports = function(content, sourcemap) &#123; // 处理 content 操作... this.callback(null, content) // 或者 return content&#125; this 是 webpack 调用 loader 时候传入的自定义的特殊上下文，所以不应该使用箭头函数！ this.callback 可以传入四个参数（其中后两个参数可以省略），分别是： error ：当 loader 出错时向外抛出一个 Error 对象，成功则传入 null ； content ：经过 loader 编译后需要导出的内容，类型可以是为 String 或者 Buffer ； sourceMap ：为方便调试生成的编译后内容的 source map； ast : 本次编译生成的 AST 静态语法树，之后执行的 loader 可以直接使用这个 AST，可以省去重复生成 AST 的 过程。 loader 异步处理数据第一种方式是是使用 async/await 异步函数写法 12345678910111213module.exports = async function(content) &#123; function timeout(delay) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // 模拟一些异步操作处理 content resolve(content); &#125;, delay); &#125;); &#125; const data = await timeout(1000); return data;&#125;; 第二种方式是使用 this.async 方法获取一个异步的 callback ，然后返回它。 1234567891011121314module.exports = function(content) &#123; function timeout(delay) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; // 模拟异步操作 resolve(content) &#125;, delay) &#125;) &#125; const callback = this.async() timeout(1000).then(data =&gt; &#123; callback(null, data) &#125;)&#125; this.async 获取的 callback，参数也是跟 this.callback 的参数一致，即 error，content，sourcemap 和 ast。 处理二进制数据像 file-loader 这样的 Loader，实际处理的内容是二进制数据，那么就需要通过设置 moudle.exports.raw = true; 来告诉 Webpack 给 loader 传入二进制格式的数据。 1234567module.exports = function(source) &#123; if (source instanceof Buffer) &#123; // 一系列的操作 return source // 本身也可以返回二进制数据提供给下一个loader &#125;&#125;module.exports.raw = true // 不设置，就会拿到字符串 loader 的 pitchloader 的执行分为两个阶段，pitch阶段loader从左到右链式调用。而Normal阶段是从右到左的链式调用。 在一些场景下，loader 并不依赖上一个 loader 的结果，而只关心原输入内容。这时候，要 拿到一开始的文件原内容，就需要使用 module.exports.pitch = function(); 123456module.exports.pitch = function(remainingRequest, precedingRequest, data) &#123; if (somothingFlag()) &#123; return &#x27;module.exports = require(&#x27; + JSON.stringify(&#x27;-!&#x27; + remaining) + &#x27;);&#x27; &#125; data.value = 1&#125; pitch函数的data，在执行阶段也会暴露在 this.data 之下，并且可以用于在循环时，捕获和共享前面的信息。 loader 结果缓存Webpack 增量编译机制会观察每次编译时的变更文件，在默认情况下，Webpack 会对 loader 的执行结果进行缓 存，这样能够大幅度提升构建速度，不过我们也可以手动关闭它： 1234module.exports = function(content) &#123; this.cacheable(false) return content&#125; loader 工具库loader-utilsloader-utils 提供了各种跟 loader 选项（options）相关的工具函数 123456789101112const &#123; getOptions，stringifyRequest, parseQuery &#125; = require(&#x27;loader-utils&#x27;);module.exports = function(content) &#123; // getOptions 用于在loader里获取传入的options，返回的是对象值。 const options = getOptions(this); // stringifyRequest转换路径，避免require()或impot时使用的绝对路径 stringifyRequest(this, &#x27;./test.js&#x27;); // Result =&gt; &quot;\\&quot;./test.js\\&quot;&quot; // parseQuery获取query参数的 parseQuery(&#x27;?name=kev&amp;age=14&#x27;) // Result =&gt; &#123;name: &#x27;kev&#x27;, age: &#x27;14&#x27;&#125;&#125; schema-utilsschema-utils 是 loader 和 plugin 的参数认证器，检测传入的参数是否符合预期 12345678910111213141516171819202122232425const validateOptions = require(&#x27;schema-utils&#x27;);// 下面是一个schema描述const schema = &#123; type: &#x27;object&#x27;, properties: &#123; name: &#123; type: &#x27;string&#x27; &#125;, test: &#123; anyOf: [&#123;type: &#x27;array&#x27;&#125;, &#123;type: &#x27;string&#x27;&#125;, &#123;instanceof: &#x27;RegExp&#x27;&#125;] &#125;, transform: &#123; instanceof: &#x27;Function&#x27; &#125;, sourceMap: &#123; type: &#x27;boolean&#x27; &#125; &#125;, additionalProperties: false&#125;;module.exports = function(source) &#123; // 验证参数的类型是否正确。 validateOptions(schema, options, &#x27;loader name&#x27;);&#125;; loader 上下文loader 中 this 相关的其它方法和属性 this.context : 当前处理转换的文件所在的目录； this.resource : 当前处理转换的文件完整请求路径，包括 querystring； this.resourcePath : 当前处理转换的文件的路径； this.resourceQuery : 当前处理文件的 querystring； this.target : Webpack 配置的 target； this.loadMoudle : 处理文件时，需要依赖其它文件的处理结果时，可以使用 this.loadMoudle(request: strin g, callback: function(err, source, sourceMap, module)) 去获取到依赖文件的处理结果； this.resolve : 获取指定文件的完整路径； this.addDependency : 为当前处理文件添加依赖文件，以便依赖文件发生变化时重新调用 Loader 转换该文件， this.addDependency(file: string) ； this.addContextDependency : 为当前处理文件添加依赖文件目录，以便依赖文件目录里文件发生变化时重新调 用 Loader 转换该文件， this.addContextDependency(dir: string) ； this.clearDependencies : 清除当前正在处理文件的所有依赖； this.emitFile : 输出一个文件，使用的方法为 this.emitFile(name: string, content: Buffer | string, so urceMap: {…}) ； this.emitError ：发送一个错误信息。 markdown-loader1234567891011121314151617181920const showdown = require(&#x27;showdown&#x27;) // 第三方工具，把md转成htmlconst &#123; getOptions &#125; = require(&#x27;loader-utils&#x27;)module.exports = function(content) &#123; // 获取options const options = getOptions(this) // 获取cache this.cacheable() // 初始化showdown转换器 const converter = new showdown.Converter(options) // 处理content content = converter.makeHtml(content) // 返回结果 this.callback(null, content)&#125;","categories":[{"name":"工程化","slug":"工程化","permalink":"https://zxffan.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"https://zxffan.github.io/tags/webpack/"},{"name":"架构","slug":"架构","permalink":"https://zxffan.github.io/tags/%E6%9E%B6%E6%9E%84/"}]},{"title":"Webpack原理","slug":"engineering/Webpack原理","date":"2020-03-19T16:00:00.000Z","updated":"2021-06-29T14:04:53.649Z","comments":true,"path":"posts/e2b02a9e.html","link":"","permalink":"https://zxffan.github.io/posts/e2b02a9e.html","excerpt":"","text":"Webpack工作流程类比Webpack 可以看做是一个工厂车间， plugin 和 loader 是车间中的两类机器，工厂有一个车间主任和一个生 产车间。车间主任叫 Compiler ，负责指挥生产车间机器 Compilation 进行生产劳动， Compilation 会首先将 进来的原材料（ entry ）使用一种叫做 loader 的机器进行加工，生产出来的产品就是 Chunk ； Chunk 生产出 来之后，会被组装成 Bundle ，然后通过一类 plugin 的机器继续加工，得到最后的 Bundle ，然后运输到对应 的仓库（output）。这个工厂的生产线就是 Tapable，厂子运作的整个流程都是生产线控制的，车间中有好几 条生产线，每个生产线有很多的操作步骤（ hook ），一步操作完毕，会进入到下一步操作，直到生产线全流 程完成，再将产出传给下一个产品线处理。整个车间生产线也组成了一条最大的生产线。 工作流程三个阶段 准备阶段：主要任务是创建 Compiler 和 Compilation 对象； 编译阶段：这个阶段任务是完成 modules 解析，并且生成 chunks； module 解析：包含了三个主要步骤，创建实例、loaders 应用和依赖收集； chunks 生成，主要步骤是找到每个 chunk 所需要包含的 modules 。 产出阶段：这个阶段的主要任务是根据 chunks 生成最终文件，主要有三个步骤：模板 Hash 更新，模板渲染 chunk，生成文件。 细化 初始化参数：包括从配置文件和 shell 中读取和合并参数，然后得出最终参数；shell 中的参数要优于配置文件的 使用上一步得到的参数实例化一个 Compiler 类，注册所有的插件，给对应的 Webpack 构建生命周期绑定 Hook 开始编译：执行 Compiler 类的 run 方法开始执行编译 compiler.run 方法调用 compiler.compile ，在 compile 内实例化一个 Compilation 类， Compilation 是做构 建打包的事情，主要事情包括： 查找入口：根据 entry 配置，找出全部的入口文件 编译模块：根据文件类型和 loader 配置，使用对应 loader 对文件进行转换处理 解析文件的 AST 语法树 找出文件依赖关系 递归编译依赖的模块 递归完后得到每个文件的最终结果，根据 entry 配置生成代码块 chunk 输出所有 chunk 到对应的 output 路径 Tapable概述Tapable是webpack的核心模块。其原理和nodejs的EventEmitter 类似，但是功能更强大，包括多种类型，通过事件的注册和监听，触发 Webpack 生命周期中的函数方法。tapable 都是放到对象的 hooks 上，所以我们叫它们 钩子。 123456789101112131415161718192021222324252627282930313233// webpack 4.29.6// lib/compilerclass Compiler extends Tapable &#123; constructor(context) &#123; super(); this.hooks = &#123; shouldEmit: new SyncBailHook([&#x27;compilation&#x27;]), done: new AsyncSeriesHook([&#x27;stats&#x27;]), additionalPass: new AsyncSeriesHook([]), beforeRun: new AsyncSeriesHook([&#x27;compiler&#x27;]), run: new AsyncSeriesHook([&#x27;compiler&#x27;]), emit: new AsyncSeriesHook([&#x27;compilation&#x27;]), afterEmit: new AsyncSeriesHook([&#x27;compilation&#x27;]), thisCompilation: new SyncHook([&#x27;compilation&#x27;, &#x27;params&#x27;]), compilation: new SyncHook([&#x27;compilation&#x27;, &#x27;params&#x27;]), normalModuleFactory: new SyncHook([&#x27;normalModuleFactory&#x27;]), contextModuleFactory: new SyncHook([&#x27;contextModulefactory&#x27;]), beforeCompile: new AsyncSeriesHook([&#x27;params&#x27;]), compile: new SyncHook([&#x27;params&#x27;]), make: new AsyncParallelHook([&#x27;compilation&#x27;]), afterCompile: new AsyncSeriesHook([&#x27;compilation&#x27;]), watchRun: new AsyncSeriesHook([&#x27;compiler&#x27;]), failed: new SyncHook([&#x27;error&#x27;]), invalid: new SyncHook([&#x27;filename&#x27;, &#x27;changeTime&#x27;]), watchClose: new SyncHook([]), environment: new SyncHook([]), afterEnvironment: new SyncHook([]), afterPlugins: new SyncHook([&#x27;compiler&#x27;]), entryOption: new SyncBailHook([&#x27;context&#x27;, &#x27;entry&#x27;]) &#125;; &#125;&#125; Tapable中Hook类型Hook 类型可以分为同步（ Sync ）和异步（ Async ），异步又分为并行和串行： 根据使用方式来分，又可以分为 Basic 、 Waterfall 、 Bail 和 Loop 四类，每类 Hook 都有自己的使用要点： 类型 使用要点 hook Basic 基础类型，不关心监听函数的返回值，不根据返回值做事情 SyncHook 、 AsyncParallelHook 和 AsyncSeriesHook Bail 保险式，只要监听函数中有返回值（不为 undefined ），则跳过之后的监听函数（类比Array.find） SyncBailHook 、 AsyncSeriesBailHook 、 AsyncParallelBailHook Waterfall 瀑布式，上一步的返回值(非undefined)继续交给下一步处理和使用（类比Array.reduce） SyncWaterfallHook 和 AsyncSeriesWaterfallHook Loop 循环类型，如果该监听函数返回 true 则这个监听函数会反复执行，如果返回 undefined 则退出循环 SyncLoopHook Tapable原理解析Tapable执行分为四步 使用 tap* 对事件进行注册绑定。根据类型不同，提供三种绑定的方式： tap 、 tapPromise 、 tapAsync ，其中 tapPromise 、 tapAsync 为异步类 Hook 的绑定方法 使用 call* 对事件进行触发，根据类型不同，也提供了三种触发的方式： call 、 promise 、 callAsync 生成对应类型的代码片段（要执行的代码实际是拼字符串拼出来的） 生成第三步生成的代码片段。 总结Tapable 是 Webpack 的核心模块，Webpack 的所有工作流程都是通过 Tapable 来实现的。Tapable 本质上是提供 了多种类型的事件绑定机制，根据不同的流程特点可以选择不同类型的 Hook 来使用。Tapable 的核心实现在绑定 事件阶段跟我们平时的自定义 JavaScript事件绑定（例如EventEmitter）没有太大区别，但是在事件触发执行的时 候，会临时生成可以执行的函数代码片段。通过这种实现方式，Tapable 实现了强大的事件流程控制能力，也增加 了如 waterfall / parallel 系列方法，实现了异步/并行等事件流的控制能力。 Compiler 和 Compilationcompiler和compilation都继承Tapable，不同点是Compiler是每 个 Webpack 的配置，对应一个Compiler对象，记录着整个 Webpack 的生命周期；在构建的过程中，每次构建都 会产生一次Compilation，Compilation则是构建周期的产物。 Compiler每次执行webpack构建的时候，webpack内部都会实例化一个Compiler对象，然后调用它的run方法开始一次完整的编译过程。 1234567891011const webpack = require(&#x27;webpack&#x27;)const webpackConfig = require(&#x27;./webpack.config.js&#x27;)// 只传入configconst compiler = webapck(webpackConfig)// 执行compiler.run()// 上面两句等价于webpack(webpackConfig, callback) 使用webpack-dev-serverAPI方式时，只需要将compiler对象给dev server即可，不需要手动执行compiler.run()；如果需要手动实例化Compiler对象，可以通过const Compiler = webpack.Compiler来获取它的类。 Compiler钩子 钩子名 Tapable 类型 触发时机 传入 callback 的参数 entryOption SyncBailHook 在 webpack 中的 entry 配置处理过之后 context，entry afterPlugins SyncHook 初始化完内置插件之后 compiler afterResolvers SyncHook resolver 完成之后（后面解释resolver是什么） compiler environment SyncHook 准备编译环境，webpack plugins配置初始化完成之后 compiler afterEnvironment SyncHook 编译环境准备好之后 compiler beforeRun AsyncSeriesHook 开始正式编译之前 compiler run AsyncSeriesHook 开始编译之后，读取 records 之前；监听模式触发watch-run compiler watchRun AsyncSeriesHook 监听模式下，一个新的编译触发之后 compiler normalModuleFactory SyncHook NormalModuleFactory 创建之后 normalModuleFactory实例 contextModuleFactory SyncHook ContextModuleFactory 创建之后 contextModuleFactory实例 beforeCompile AsyncSeriesHook compilation 实例化需要的参数创建完毕之后 compilationParams compile SyncHook 一次 compilation 编译创建之前 compilationParams thisCompilation SyncHook 触发 compilation 事件之前执行 compilation，compilationParams compilation SyncHook compilation创建成功之后 compilation，compilationParams make AsyncParallelHook 完成编译之前 compilation afterCompile AsyncSeriesHook 完成编译和封存（seal）编译产出之后 compilation shouldEmit SyncBailHook 发布构建后资源之前触发，回调必须返回true/false，true则继续 compilation emit AsyncSeriesHook 生成资源到 output 目录之前 compilation afterEmit AsyncSeriesHook 生成资源到 output 目录之后 compilation done AsyncSeriesHook compilation完成之后 stats failed SyncHook compilation失败 error invalid SyncHook 监听模式下，编译无效时 fileName，changeTime watchClose SyncHook 监听模式停止 无 Tips：整个Compiler完整地展现了 Webpack 的构建流程： 准备阶段：run之前做的事情都属于准备阶段，这阶段的calback入参以compiler为主； 编译阶段：这阶段以compilation的钩子为主，calback入参以compilation为主； 产出阶段：这阶段从compilation开始，最后回到Compiler钩子上，calback传入参数是跟结果相关的数据，包括stats、error 钩子的调用需要使用tap、tapPromise或tapAsync 1compiler.hooks.someHook.tap(&#x27;MyPlugin&#x27;, params =&gt; &#123; /* ... */ &#125;); 注解1: Resolver Compiler 的 Resolver 是指来自于enhanced-resolve模块，它主要功能是一个提供异步require.resolve()，即从哪里去查找文件的路径，可以通过Webpack的resolve和resolveLoader来配置。Compiler类有三种类型的内置 Resolver： Normal：通过绝对路径或相对路径，解析一个模块； Context：通过给定的上下文（context）解析一个模块； Loader：解析一个 webpack loader。 注解2： ：thisCompilation和compilation 这里为什么会有 thisCompilation和compilation 两个钩子呢？其实是跟子编译（child compiler）有关， Compiler 实例通过 createChildCompiler 方法可以创建子编译实例 childCompiler。创建childCompiler时，childCompiler会复制 compiler 实例的任务点监听器。compilation的钩子会被复制，而 的钩子会被复制，而 thisCompilation 钩子则 钩子则不会被复制。 Compilation在 Compilation 阶段，模块会被加载(loaded)、封存(sealed)、优化(optimized)、分块(chunked)、哈希(hashed)和重新创建(restored)，Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以监听（watch）模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展，通过 Compilation 也能读取到 Compiler 对象。 Compilation钩子compilation先从单个 module 开始处理，查找依赖关系， 最后完成单个module 处理，完成全部modules 之后，开始 chunks 阶段处理，最后在根据优化配置，按需生成 assets。 带★是比较重要的 钩子名 Tapable 类型 触发时机 传入 callback 的参数 buildModule SyncHook 在模块构建开始之前触发 module rebuildModule SyncHook 在重新构建一个模块之前触发 module failedModule SyncHook 模块构建失败时执行 module，error succeedModule SyncHook 模块构建成功时执行 module finishModules SyncHook 所有模块都完成构建 module finishRebuildingModule SyncHook 一个模块完成重新构建 module seal SyncHook ★编译（compilation）停止接收新模块时触发 module unseal SyncHook 编译（compilation）开始接收新模块时触发 module optimizeDependencies SyncBailHook 依赖优化开始时触发 modules afterOptimizeDependencies SyncHook 依赖优化结束时触发 modules optimize SyncHook ★优化阶段开始时触发 modules optimizeModules SyncBailHook ★模块的优化 modules afterOptimizeModules SyncHook 模块优化结束时触发 modules optimizeChunks SyncBailHook ★优化 chunks chunks afterOptimizeChunks SyncHook chunk 优化完成之后触发 chunks optimizeTree AsyncSeriesHook 异步优化依赖树 chunks，modules afterOptimizeTree SyncHook 异步优化依赖树完成时 chunks，modules optimizeChunkModules SyncBailHook 优化单个chunk中的 modules 开始 chunks afterOptimizeChunkModules SyncHook 优化单个chunk中的 modules 结束 chunks shouldRecord SyncHook chunks reviveModules SyncHook 从 records 中恢复模块信息 modules，records optimizeModuleOrder SyncHook 将模块从最重要的到最不重要的进行排序 chunks beforeModuleIds SyncHook 处理 modulesId 之前 modules moduleIds SyncHook 处理 modulesId modules optimizeModuleIds SyncHook 优化 modulesId chunks afterOptimizeModuleIds SyncHook 优化 modulesId之后 chunks reviveChunks SyncHook 从 records 中恢复 chunk 信息 modules，records optimizeChunkOrder SyncHook 将 chunk 从最重要的到最不重要的进行排序 chunks beforeOptimizeChunkIds SyncHook chunk id 优化之前触发 chunks optimizeChunkIds SyncHook chunk id 优化开始触发 chunks afterOptimizeChunkIds SyncHook chunk id 优化结束触发 chunks recordModules SyncHook 将模块信息存储到 records modules，records recordChunks SyncHook 将 chunk 信息存储到 records chunks，records beforeHash SyncHook 在编译被哈希（hashed）之前 - afterHash SyncHook 在编译被哈希（hashed）之后 - record SyncHook 将 compilation 相关信息存储到 records 中 compilation，records beforeChunkAssets SyncHook 在创建 chunk 资源（asset）之前 chunks additionalChunkAssets SyncHook 为 chunk 创建附加资源（asset） chunks additionalAssets AsyncSeriesHook ★为编译（compilation）创建附加资源（asset） - optimizeChunkAssets AsyncSeriesHook ★优化所有 chunk 资源（asset） chunks afterOptimizeChunkAssets SyncHook chunk 资源（asset）已经被优化 chunks optimizeAssets AsyncSeriesHook ★优化存储在 compilation.assets 中的所有资源（asset） assets afterOptimizeAssets SyncHook 优化compilation.assets 中的所有资源（asset）之后 assets moduleAsset SyncHook 一个模块中的一个资源被添加到编译中 module，filename chunkAsset SyncHook 一个 chunk 中的一个资源被添加到编译中 chunk，filename assetPath SyncWaterfallHook asset 路径确认之后 filename，data childCompiler SyncHook 子编译（compiler）触发 childCompiler，compilerName，compilerIndex normalModuleLoader SyncHook ★普通模块 loader，真正（一个接一个地）加载模块图（graph）中所有模块的函数 loaderContext，module Stats在webpack的回调函数——webpack(cofnig, (err, stats) =&gt; &#123;&#125;)中会得到stats对象，这个对象实际来自于Compilation.getStats()，返回的是主要含有modules、chunks和assets三个属性值的对象。 modules： 记录了所有解析后的模块 chunks：记录了所有chunk assets：记录了所有要生成的文件 Stats对象本质是来自于lib/Stats.js的类的实例。常用的方法： stats.hasWarnings() stats.hasErrors() stats.toJson() stats.toString() Stats对象数据结构在webpack的回调中获取stats，然后再调用toJson方法获取stats的数据接口 123webpack(config, (err, stats) =&gt; &#123; console.log(stats.toJson())&#125;) Stats对象可以通过webpack-cli打包成一个json文件：webpack --profile --json &gt; compilation-stats.json 数据结构如下： 12345678910111213141516171819202122232425262728&#123; &quot;version&quot;: &quot;4.29.6&quot;, // 用来编译的 webpack 的版本 &quot;hash&quot;: &quot;11593e3b3ac85436984a&quot;, // 编译使用的 hash &quot;time&quot;: 2469, // 编译耗时 (ms) &quot;filteredModules&quot;: 0, // 当 `exclude`传入`toJson` 函数时，统计被无视的模块的数量 &quot;outputPath&quot;: &quot;/&quot;, // path to webpack 输出目录的 path 路径 &quot;assetsByChunkName&quot;: &#123; // 用作映射的 chunk 的名称 &quot;main&quot;: &quot;web.js?h=11593e3b3ac85436984a&quot;, &quot;named-chunk&quot;: &quot;named-chunk.web.js&quot;, &quot;other-chunk&quot;: [&quot;other-chunk.js&quot;, &quot;other-chunk.css&quot;] &#125;, &quot;assets&quot;: [ // asset 对象 (asset objects) 的数组 ], &quot;chunks&quot;: [ // chunk 对象 (chunk objects) 的数组 ], &quot;modules&quot;: [ // 模块对象 (module objects) 的数组 ], &quot;errors&quot;: [ // 错误字符串 (error string) 的数组 ], &quot;warnings&quot;: [ // 警告字符串 (warning string) 的数组 ]&#125; stats.toJson可以指定要不要输出对应的数据。例如不想输出 modules 和 chunks，可以使用stats. toJson({modules: false, chunks: false}) module在每个 module 中，我们可以得到它的所有信息，这些信息可以分为四大类： 基本信息：包括最基本的内容、大小、id； 依赖关系：module.reasons对象描述了这个模块被加入依赖图表的理由，包含了引入的方式、引入的 module 信息及其对应代码在第几行第几列等，可以通过这个计算出 module 之间的依赖关系图表（graph）； chunks 和 assets 关系：module.chunks和module.assets包含到 chunks 和 assets 中的对应 id 等； 被 webpack 处理的后的信息：包含module.failed、module.errors、module.warnings等。 1234567891011121314151617181920212223242526272829&#123; &quot;assets&quot;: [ // asset对象 (asset objects)的数组 ], &quot;built&quot;: true, // 表示这个模块会参与 Loaders , 解析, 并被编译 &quot;cacheable&quot;: true, // 表示这个模块是否会被缓存 &quot;chunks&quot;: [ // 包含这个模块的 chunks 的 id ], &quot;errors&quot;: 0, // 处理这个模块发现的错误的数量 &quot;failed&quot;: false, // 编译是否失败 &quot;id&quot;: 0, // 这个模块的ID (类似于 `module.id`) &quot;identifier&quot;: &quot;(webpack)\\\\test\\\\browsertest\\\\lib\\\\index.web.js&quot;, // webpack内部使用的唯一的标识 &quot;name&quot;: &quot;./lib/index.web.js&quot;, // 实际文件的地址 &quot;optional&quot;: false, // 每一个对这个模块的请求都会包裹在 `try... catch` 内 (与ESM无关) &quot;prefetched&quot;: false, // 表示这个模块是否会被 prefetched &quot;profile&quot;: &#123; // 有关 `--profile` flag 的这个模块特有的编译数据 (ms) &quot;building&quot;: 73, // 载入和解析 &quot;dependencies&quot;: 242, // 编译依赖 &quot;factory&quot;: 11 // 解决依赖 &#125;, &quot;reasons&quot;: [ // 见下文描述 ], &quot;size&quot;: 3593, // 预估模块的大小 (byte) &quot;source&quot;: &quot;// Should not break it...\\r\\nif(typeof...&quot;, // 字符串化的输入 &quot;warnings&quot;: 0 // 处理模块时警告的数量&#125; 其中module.reasons数据结构如下： 12345678&#123; &quot;loc&quot;: &quot;33:24-93&quot;, // 导致这个被加入依赖图标的代码行数 &quot;module&quot;: &quot;./lib/index.web.js&quot;, // 所基于模块的相对地址 context &quot;moduleId&quot;: 0, // 模块的 ID &quot;moduleIdentifier&quot;: &quot;(webpack)\\\\test\\\\browsertest\\\\lib\\\\index.web.js&quot;, // 模块的地址 &quot;moduleName&quot;: &quot;./lib/index.web.js&quot;, // 可读性更好的模块名称 (用于 &quot;更好的打印 (pretty-printing)&quot;) &quot;type&quot;: &quot;require.context&quot;, // 使用的请求的种类 (type of request)&#125; chunk在每个 chunk 中，信息也可以分为四大类： 基本信息：包括最基本的内容、大小、id； 来源：chunk.origins对象描述了这个模块被加入的理由，包含了引入的方式、引入的 module 信息及其对应代码在第几行第几列等，可以通过这个计算出 module 之间的依赖关系图表（graph）； 引用关系：chunk.parents和chunk.children被引用和引用的 ids； 包含和被包含：chunk.files和chunk.modules包含到 assets 和自己包含 modules 中信息等。 123456789101112131415161718192021222324252627282930&#123; &quot;entry&quot;: true, // 表示这个 chunk 是否包含 webpack 的运行时 &quot;files&quot;: [ // 一个包含这个 chunk 的文件名的数组 ], &quot;filteredModules&quot;: 0, // 见上文的 结构 &quot;id&quot;: 0, // 这个 chunk 的id &quot;initial&quot;: true, // 表示这个 chunk 是开始就要加载还是 懒加载(lazy-loading) &quot;modules&quot;: [ // 模块对象 (module objects)的数组 &quot;web.js?h=11593e3b3ac85436984a&quot; ], &quot;names&quot;: [ // 包含在这个 chunk 内的 chunk 的名字的数组 ], &quot;origins&quot;: [ // 下文详述 ], &quot;parents&quot;: [], // 父 chunk 的 ids // 生成 assets 的原因 &quot;reason&quot;: &quot;split chunk (cache group: asyncVendors) (name: async)&quot;, &quot;hash&quot;: &quot;170746935298270ad813&quot;, // 自己引用谁 &quot;children&quot;: [], // 引用的顺序 &quot;childrenByOrder&quot;: &#123;&#125;, &quot;modules&quot;: [], &quot;rendered&quot;: true, // 表示这个 chunk 是否会参与进编译 &quot;size&quot;: 188057 // chunk 的大小(byte)&#125; chunk.origins对应的格式如下： 1234567891011&#123; &quot;loc&quot;: &quot;&quot;, // 具体是哪行生成了这个chunk &quot;module&quot;: &quot;(webpack)\\\\test\\\\browsertest\\\\lib\\\\index.web.js&quot;, // 模块的位置 &quot;moduleId&quot;: 0, // 模块的ID &quot;moduleIdentifier&quot;: &quot;(webpack)\\\\test\\\\browsertest\\\\lib\\\\index.web.js&quot;, // 模块的地址 &quot;moduleName&quot;: &quot;./lib/index.web.js&quot;, // 模块的相对地址 &quot;name&quot;: &quot;main&quot;, // chunk的名称 &quot;reasons&quot;: [ // 模块对象中`reason`的数组 ]&#125; assetasset相对简单一些，内容如下： 1234567&#123; &quot;chunkNames&quot;: [], // 这个 asset 包含的 chunk &quot;chunks&quot;: [10, 6], // 这个 asset 包含的 chunk 的 id &quot;emitted&quot;: true, // 表示这个 asset 是否会让它输出到 output 目录 &quot;name&quot;: &quot;10.web.js&quot;, // 输出的文件名 &quot;size&quot;: 1058 // 文件的大小&#125;","categories":[{"name":"工程化","slug":"工程化","permalink":"https://zxffan.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"webpack","slug":"webpack","permalink":"https://zxffan.github.io/tags/webpack/"},{"name":"架构","slug":"架构","permalink":"https://zxffan.github.io/tags/%E6%9E%B6%E6%9E%84/"}]}],"categories":[{"name":"experience","slug":"experience","permalink":"https://zxffan.github.io/categories/experience/"},{"name":"self","slug":"self","permalink":"https://zxffan.github.io/categories/self/"},{"name":"CSS","slug":"CSS","permalink":"https://zxffan.github.io/categories/CSS/"},{"name":"源码","slug":"源码","permalink":"https://zxffan.github.io/categories/%E6%BA%90%E7%A0%81/"},{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/categories/Electron/"},{"name":"NetWork","slug":"NetWork","permalink":"https://zxffan.github.io/categories/NetWork/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/categories/JavaScript/"},{"name":"工程化","slug":"工程化","permalink":"https://zxffan.github.io/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/categories/Algorithm/"},{"name":"Rust","slug":"Rust","permalink":"https://zxffan.github.io/categories/Rust/"},{"name":"Server","slug":"Server","permalink":"https://zxffan.github.io/categories/Server/"},{"name":"读书","slug":"读书","permalink":"https://zxffan.github.io/categories/%E8%AF%BB%E4%B9%A6/"},{"name":"Media","slug":"Media","permalink":"https://zxffan.github.io/categories/Media/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://zxffan.github.io/tags/Nodejs/"},{"name":"crypto","slug":"crypto","permalink":"https://zxffan.github.io/tags/crypto/"},{"name":"前端","slug":"前端","permalink":"https://zxffan.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"interview","slug":"interview","permalink":"https://zxffan.github.io/tags/interview/"},{"name":"css","slug":"css","permalink":"https://zxffan.github.io/tags/css/"},{"name":"网络","slug":"网络","permalink":"https://zxffan.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"name":"vue","slug":"vue","permalink":"https://zxffan.github.io/tags/vue/"},{"name":"javascript","slug":"javascript","permalink":"https://zxffan.github.io/tags/javascript/"},{"name":"Electron","slug":"Electron","permalink":"https://zxffan.github.io/tags/Electron/"},{"name":"桌面端软件","slug":"桌面端软件","permalink":"https://zxffan.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF%E8%BD%AF%E4%BB%B6/"},{"name":"NetWork","slug":"NetWork","permalink":"https://zxffan.github.io/tags/NetWork/"},{"name":"HTTP","slug":"HTTP","permalink":"https://zxffan.github.io/tags/HTTP/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://zxffan.github.io/tags/JavaScript/"},{"name":"Promise","slug":"Promise","permalink":"https://zxffan.github.io/tags/Promise/"},{"name":"webpack","slug":"webpack","permalink":"https://zxffan.github.io/tags/webpack/"},{"name":"架构","slug":"架构","permalink":"https://zxffan.github.io/tags/%E6%9E%B6%E6%9E%84/"},{"name":"web-vitals","slug":"web-vitals","permalink":"https://zxffan.github.io/tags/web-vitals/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"https://zxffan.github.io/tags/FrontEnd/"},{"name":"安全","slug":"安全","permalink":"https://zxffan.github.io/tags/%E5%AE%89%E5%85%A8/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://zxffan.github.io/tags/TypeScript/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://zxffan.github.io/tags/Algorithm/"},{"name":"位运算","slug":"位运算","permalink":"https://zxffan.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"Number","slug":"Number","permalink":"https://zxffan.github.io/tags/Number/"},{"name":"Rust","slug":"Rust","permalink":"https://zxffan.github.io/tags/Rust/"},{"name":"语言学习","slug":"语言学习","permalink":"https://zxffan.github.io/tags/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"},{"name":"vue2","slug":"vue2","permalink":"https://zxffan.github.io/tags/vue2/"},{"name":"ssr","slug":"ssr","permalink":"https://zxffan.github.io/tags/ssr/"},{"name":"服务","slug":"服务","permalink":"https://zxffan.github.io/tags/%E6%9C%8D%E5%8A%A1/"},{"name":"Server","slug":"Server","permalink":"https://zxffan.github.io/tags/Server/"},{"name":"Nginx","slug":"Nginx","permalink":"https://zxffan.github.io/tags/Nginx/"},{"name":"Web","slug":"Web","permalink":"https://zxffan.github.io/tags/Web/"},{"name":"Serverless","slug":"Serverless","permalink":"https://zxffan.github.io/tags/Serverless/"},{"name":"云计算","slug":"云计算","permalink":"https://zxffan.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"},{"name":"functional programing","slug":"functional-programing","permalink":"https://zxffan.github.io/tags/functional-programing/"},{"name":"HTTP Header","slug":"HTTP-Header","permalink":"https://zxffan.github.io/tags/HTTP-Header/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"https://zxffan.github.io/tags/TCP-IP/"},{"name":"nodejs","slug":"nodejs","permalink":"https://zxffan.github.io/tags/nodejs/"},{"name":"browser","slug":"browser","permalink":"https://zxffan.github.io/tags/browser/"},{"name":"animation","slug":"animation","permalink":"https://zxffan.github.io/tags/animation/"},{"name":"C++","slug":"C","permalink":"https://zxffan.github.io/tags/C/"},{"name":"桌面端","slug":"桌面端","permalink":"https://zxffan.github.io/tags/%E6%A1%8C%E9%9D%A2%E7%AB%AF/"},{"name":"WebRTC","slug":"WebRTC","permalink":"https://zxffan.github.io/tags/WebRTC/"},{"name":"audio","slug":"audio","permalink":"https://zxffan.github.io/tags/audio/"},{"name":"video","slug":"video","permalink":"https://zxffan.github.io/tags/video/"},{"name":"regExp","slug":"regExp","permalink":"https://zxffan.github.io/tags/regExp/"}]}